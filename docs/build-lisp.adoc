= 从零使用C语言构建一个Lisp解释器
:icons: font
:source-highlighter: highlightjs
:toc: left
:toclevels: 4
:sectnums:

== 第一章：简介

理解事物如何工作的最好方法是尝试自己构建它。阅读别人的解释可能会满足我们的好奇心，但是如果没有踩坑的经验，就很难理解为什么某些事物是以某种方式设计的。

有人说，每个程序员都应该编写一个编译器。尽管我认为这是个不错的建议（尽管我自己并没有遵循），但是在解析诸如C之类的语言时需要付出大量的努力，以至于任何潜在的见解都有可能迷失在细节中。也许为一些简单的语言创建一个解释器将是一个很好的第一步。

早在几年前，我开始使用LISP。我阅读了《计算机程序的结构和解释》。你需要阅读一下这本书。

这本书涵盖了许多主题，但是下半部分详细介绍了如何对LISP程序进行求值(eval)，也就是使用LISP本身实现了一个 `eval` 函数。我认为这可以很好地转换为C程序，因此决定尝试创建自己的LISP实现。

作为一名专业程序员，我将大部分时间都花在编写C和C++上。其余大多数是Java。有很多语言在那里，每个都有自己的优点值得商榷，但我想证明实现一个LISP机器是一件多简单的事情，甚至使用像C语言这样的底层语言来实现。

所以这是我的LISP的玩具实现。我已经从各种方言中借用了功能，但是它比Common LISP更接近Scheme。差异是微不足道的，以至于转换不需要对解释程序进行实质性的更改。如果你不熟悉LISP，请不要担心。我将在实现LISP的过程中定义所有内容。

它既不是最小的实现，也不是最高效的，也不是最完整的实现。但是它可以说是懒惰的。我的目标是编写功能强大，易于阅读的代码，该代码完全满足其需要，并且不再需要执行任何其他操作，并且我希望它可以传达构建诸如LISP之类的功能强大的环境所需的工作量。

== 第二章：数据

我们将首先定义四种对象：

* 整数：一个数字。例如：3,-9,0。
* 符号：由字符串组成的名称。例如：FOO,BAR,ADD-TWO。我们将在此项目中将符号规范化为大写，但这不是绝对必要的。
* `NIL` ：表示“无”。有点像C语言和其他语言中的 `NULL` 。
* `Pair` ：`Pair` 由两个元素组成，出于历史原因，它们被称为 `car` 和 `cdr` 。 `Pair` 中的两个元素可以是整数，符号， `NIL` ，或者其他 `Pair` 的引用。每个元素的类型可能不同。

整数，符号和 `NIL` 被称作简单数据类型。术语 *atom* 指任何一个简单数据类型或者 `Pair` 。

请注意，整数和符号是 _不可变的_ ，因此我们可以将具有相同值的两个整数视为同一对象。这对符号特别有用，因为它允许我们通过比较指针来测试两个符号是否相等。

=== 实现

让我们声明一些C类型来保存我们的数据。有许多聪明的方法可以有效地存储LISP对象，但是对于此实现，我们将坚持一个非常简单的方案。

[source,c]
----
struct Atom {
    enum {
        AtomType_Nil,
        AtomType_Pair,
        AtomType_Symbol,
        AtomType_Integer
    } type;

    union {
        struct Pair *pair;
        const char *symbol;
        long integer;
    } value;
};

struct Pair {
    struct Atom atom[2];
};

typedef struct Atom Atom;
----

定义一些宏将很方便：

[source,c]
----
#define car(p) ((p).value.pair->atom[0])
#define cdr(p) ((p).value.pair->atom[1])
#define nilp(atom) ((atom).type == AtomType_Nil)

static const Atom nil = { AtomType_Nil };
----

整数和指向字符串的指针可以拷贝，但是我们想要初始化 `Pair` 的话，需要从堆( `Heap` )上申请内存。

[source,c]
----
Atom cons(Atom car_val, Atom cdr_val)
{
    Atom p;
    
    p.type = AtomType_Pair;
    p.value.pair = malloc(sizeof(struct Pair));
    
    car(p) = car_val;
    cdr(p) = cdr_val;
    
    return p;
}
----

`cons` 是这样一个函数，它在堆上分配一个 `Pair` ，然后对 `Pair` 的两个元素进行赋值。

=== 测试

现在我们可以创建一些LISP对象了。创建一个整数：

[source,c]
----
Atom make_int(long x)
{
    Atom a;
    a.type = AtomType_Integer;
    a.value.integer = x;
    return a;
}
----

创建一个符号：

[source,c]
----
Atom make_sym(const char *s)
{
    Atom a;
    a.type = AtomType_Symbol;
    a.value.symbol = strdup(s);
    return a;
}
----

=== 文本表示

我们可以将一个 `Pair` 写作下面这种方式：

[source,lisp]
----
(a . b)
----

`a` 是 `car` ， `b` 是 `cdr` 。

将 `pair` 中的 `cdr` 部分指向另一个 `pair` ，我们就可以创建一个链了。比如下面这样：

[source,lisp]
----
(a . (b . (c . (d . NIL))))
----

请注意，最后一个 `pair` 的 `cdr` 部分是一个 `NIL` ，这标示了链的结束。我们叫这个链为 `列表` 。为了避免写大量的括号，我们可以将上面的列表写成下面这种格式：

[source,lisp]
----
(a b c d)
----

如果列表中的最后一个 `pair` 的 `cdr` 部分不是 `NIL` 的话，可以写作如下形式：

[source,lisp]
----
(p q . r)
----

等价于：

[source,lisp]
----
(p . (q . r))
----

以上这种写法被成为 _improper list_ 。

=== 实现

打印一个符号或者 `Pair` 很简单。代码如下：

[source,c]
----
void print_expr(Atom atom)
{
    switch (atom.type) {
    case AtomType_Nil:
        printf("NIL");
        break;
    case AtomType_Pair:
        putchar('(');
        print_expr(car(atom));
        atom = cdr(atom);
        while (!nilp(atom)) {
            if (atom.type == AtomType_Pair) {
                putchar(' ');
                print_expr(car(atom));
                atom = cdr(atom);
            } else {
                printf(" . ");
                print_expr(atom);
                break;
            }
        }
        putchar(')');
        break;
    case AtomType_Symbol:
        printf("%s", atom.value.symbol);
        break;
    case AtomType_Integer:
        printf("%ld", atom.value.integer);
        break;
    }
}
----

通过使用递归的方式，我们可以打印任意复杂的数据结构。当然如果打印一个嵌套很深的数据结构时，可能会出现栈空间不足。而打印一个存在循环引用的数据结构时，也会出现死循环。

=== 测试

[cols="1,1"]
|===
| *Atom* | *Output*
| make_int(42) | 42
| make_sym("FOO") | FOO
| cons(make_sym("X"), make_sym("Y")) | (X . Y)
| cons(make_int(1),
  cons(make_int(2),
  cons(make_int(3),
  nil))) | (1 2 3)
|===

可以看到，这些事情很简单。下一章我们将会搞一些更复杂的事情。

=== 最后一件事情

还记得我们说过我们将相同的符号视为相同的对象吗？我们可以强制跟踪每一个创建的符号，如果创建了一个之前已经创建过的字符序列，我们将返回同一个符号。

如果实现的语言是内置了集合或者哈希表数据结构的语言的话，实现这个功能将会很容易。但是我们也可以使用已经实现的LISP数据结构，将符号存储在一个列表中。

[source,c]
----
static Atom sym_table = { AtomType_Nil };

Atom make_sym(const char *s)
{
    Atom a, p;

    p = sym_table;
    while (!nilp(p)) {
        a = car(p);
        if (strcmp(a.value.symbol, s) == 0)
            return a;
        p = cdr(p);
    }

    a.type = AtomType_Symbol;
    a.value.symbol = strdup(s);
    sym_table = cons(a, sym_table);

    return a;
}
----

这个实现看起来不是很高效，是吗？但足够用了，代码可读性也很好。

== 第三章：解析器

下一个阶段就是解析了。就是读取一行文本，然后创建这个文本所表示的对象。如果这行文本并不表示我们定义过的对象，我们需要抛出错误。

=== 错误处理

错误的定义如下：

[source,c]
----
typedef enum {
    Error_OK = 0,
    Error_Syntax
} Error;
----

如果像我一样，你学过BASIC编程，那么你将很熟悉可怕的 `SYNTAX ERROR` 。现在是我们从栅栏另一侧看东西的机会。从现在开始，我们的大多数函数都将返回错误，以指示是否出了问题以及出了什么问题。

=== 词法分析（Lexer）

我没有接受过CS的正式培训，但是据我了解，它的想法是将字符串拆分成 `token` 的列表，这些 `token` 既是“单词”又是“标点符号”，并丢弃所有无关紧要的空格。因此，如果输入为：

[source,lisp]
----
(foo bar)
----

那么经过词法分析生成的4个 `token` 应该是：

|===
| ( | foo | bar | )
|===

让我们先来创建一个词法分析器（lexer），词法分析器将返回 `token` 的开始位置的指针和结束位置的指针。

[source,c]
----
int lex(const char *str, const char **start, const char **end)
{
    const char *ws = " \t\n";
    const char *delim = "() \t\n";
    const char *prefix = "()";

    // C 库函数 size_t strspn(const char *str1, const char *str2) 检索字符串 str1 中第一个不在字符串 str2 中出现的字符下标。
    // 检索字符串 str 中第一个不在字符串 ws 中出现的字符下标
    str += strspn(str, ws);

    if (str[0] == '\0') {
        *start = *end = NULL;
        return Error_Syntax;
    }

    *start = str;

    // C 库函数 char *strchr(const char *str, int c) 在参数 str 所指向的字符串中搜索第一次出现字符 c（一个无符号字符）的位置。
    if (strchr(prefix, str[0]) != NULL)
        *end = str + 1;
    else
        // C 库函数 size_t strcspn(const char *str1, const char *str2) 检索字符串 str1 开头连续有几个字符都不含字符串 str2 中的字符。
        *end = str + strcspn(str, delim);

    return Error_OK;
}
----

如果我们的词法分析器在没有找到 `token` 的情况下已经来到了字符串的末尾（即，字符串的其余部分完全是空格），则它将返回语法错误并将开始和结束设置为NULL。

=== 解析器

现在我们可以考虑解析器本身。入口点是 `read_expr` 函数，它将读取单个（可能是复杂的）对象，并返回错误状态和指向输入其余部分的指针。

[source,c]
----
int read_expr(const char *input, const char **end, Atom *result);
----

我们将首先处理简单的数据：整数，符号和NIL。如果有一个正则表达式库，那么这很容易，但是使用C语言也不复杂。

[source,c]
----
int parse_simple(const char *start, const char *end, Atom *result)
{
    char *buf, *p;

    /* Is it an integer? */
    long val = strtol(start, &p, 10);
    if (p == end) {
        result->type = AtomType_Integer;
        result->value.integer = val;
        return Error_OK;
    }

    /* NIL or symbol */
    buf = malloc(end - start + 1);
    p = buf;
    while (start != end)
        *p++ = toupper(*start), ++start;
    *p = '\0';

    if (strcmp(buf, "NIL") == 0)
        *result = nil;
    else
        *result = make_sym(buf);

    free(buf);

    return Error_OK;
}
----

注意两件事：首先，我们将输入转换为大写。这不是严格必要的-区分大小写的lisp没有错-但这是传统的行为。其次， `NIL` 是一个特例：它直接解析为 `AtomType_Nil` ，而不是将其解析为符号。

如果你熟悉LISP的各种方言，那么你将知道 `NIL` 不一定与 `()` 空列表相同。我们可以选择将 `NIL` 视为求值结果是自身的符号，但是对于本项目，我们将认为两种表示形式完全相同。

接下来是列表（包括 improper 列表和对）。简化的列表语法使此操作有些复杂，因此我们将其全部保留在辅助函数中。递归再次使我们能够处理嵌套列表。

[source,c]
----
int read_list(const char *start, const char **end, Atom *result)
{
    Atom p;

    *end = start;
    p = *result = nil;

    for (;;) {
        const char *token;
        Atom item;
        Error err;

        err = lex(*end, &token, end);
        if (err)
            return err;

        if (token[0] == ')')
            return Error_OK;

        if (token[0] == '.' && *end - token == 1) {
            /* Improper list */
            if (nilp(p))
                return Error_Syntax;

            err = read_expr(*end, end, &item);
            if (err)
                return err;

            cdr(p) = item;

            /* Read the closing ')' */
            err = lex(*end, &token, end);
            if (!err && token[0] != ')')
                err = Error_Syntax;

            return err;
        }

        err = read_expr(token, end, &item);
        if (err)
            return err;

        if (nilp(p)) {
            /* First item */
            *result = cons(item, nil);
            p = *result;
        } else {
            cdr(p) = cons(item, nil);
            p = cdr(p);
        }
    }
}
----

我不喜欢写无限循环，但这是我到目前为止写出的结构最清晰的代码。

最后，我们有了 `read_expr` 本身，由于我们已经完成了所有艰苦的工作，所以这很简单：

[source,c]
----
int read_expr(const char *input, const char **end, Atom *result)
{
    const char *token;
    Error err;

    err = lex(input, &token, end);
    if (err)
        return err;

    if (token[0] == '(')
        return read_list(*end, end, result);
    else if (token[0] == ')')
        return Error_Syntax;
    else
        return parse_simple(token, *end, result);
}
----

这里对右括号的检查将会捕获一些不合法的代码形式，例如：

[source,scheme]
----
)
----

以及

[source,scheme]
----
(X .)
----

=== 测试

如果使用解析器创建一个简单的读取-打印循环（read-print-loop），则可以在控制台上键入对象的表示形式并检查是否正确解析了它们。

[source,c]
----
int main(int argc, char **argv)
{
    char *input;

    while ((input = readline("> ")) != NULL) {
        const char *p = input;
        Error err;
        Atom expr;

        err = read_expr(p, &p, &expr);

        switch (err) {
        case Error_OK:
            print_expr(expr);
            putchar('\n');
            break;
        case Error_Syntax:
            puts("Syntax error");
            break;
        }

        free(input);
    }

    return 0;
}
----

上面的代码使用了 `readline` 库，该库显示提示并从控制台读取一行文本。它支持的编辑功能很强大，但是围绕 `fgets()` 的简单封装也可以做到相同的事情。

[source,text]
----
> 42
42
> (foo bar)
(FOO BAR)
> (s (t . u) v . (w . nil))
(S (T . U) V W)
> ()
NIL
----

=== 完整代码

[source,c]
----
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <ctype.h>
#include <readline/readline.h>

typedef enum {
    Error_OK = 0,
    Error_Syntax
} Error;

struct Atom
{
    enum {
        AtomType_Nil,
        AtomType_Pair,
        AtomType_Symbol,
        AtomType_Integer
    } type;

    union {
        struct Pair *pair;
        const char *symbol;
        long integer;
    } value;
};

struct Pair {
    struct Atom atom[2];
};

typedef struct Atom Atom;

#define car(p) ((p).value.pair->atom[0])
#define cdr(p) ((p).value.pair->atom[1])
#define nilp(atom) ((atom).type == AtomType_Nil)

static const Atom nil = { AtomType_Nil };

Atom cons(Atom car_val, Atom cdr_val)
{
    Atom p;

    p.type = AtomType_Pair;
    p.value.pair = malloc(sizeof(struct Pair));

    car(p) = car_val;
    cdr(p) = cdr_val;

    return p;
}

Atom make_int(long x)
{
    Atom a;
    a.type = AtomType_Integer;
    a.value.integer = x;
    return a;
}

Atom make_sym(const char *s)
{
    Atom a;
    a.type = AtomType_Symbol;
    a.value.symbol = strdup(s);
    return a;
}

int lex(const char *str, const char **start, const char **end)
{
    const char *ws = " \t\n";
    const char *delim = "() \t\n";
    const char *prefix = "()";

    str += strspn(str, ws);

    if (str[0] == '\0') {
        *start = *end = NULL;
        return Error_Syntax;
    }

    *start = str;

    // strchr函数功能为在一个串中查找给定字符的第一个匹配之处
    if (strchr(prefix, str[0]) != NULL)
        *end = str + 1;
    else
    // 该函数返回 str1 开头连续都不含字符串 str2 中字符的字符数。
        *end = str + strcspn(str, delim);

    return Error_OK;
}

int read_expr(const char *input, const char **end, Atom *result);

int parse_simple(const char *start, const char *end, Atom *result)
{
    char *buf, *p;

    long val = strtol(start, &p, 10);
    if (p == end) {
        result->type = AtomType_Integer;
        result->value.integer = val;
        return Error_OK;
    }

    buf = malloc(end - start + 1);
    p = buf;
    while (start != end)
        *p++ = toupper(*start), ++start;
    *p = '\0';

    if (strcmp(buf, "NIL") == 0) {
        *result = nil;
    } else {
        *result = make_sym(buf);
    }

    free(buf);
    
    return Error_OK;
}

int read_list(const char *start, const char **end, Atom *result)
{
    Atom p;

    *end = start;
    p = *result = nil;

    for (;;) {
        const char *token;
        Atom item;
        Error err;

        err = lex(*end, &token, end);
        if (err) {
            return err;
        }

        if (token[0] == ')') {
            return Error_OK;
        }

        if (token[0] == '.' && *end - token == 1) {
            if (nilp(p)) {
                return Error_Syntax;
            }

            err = read_expr(*end, end, &item);
            if (err) {
                return err;
            }

            cdr(p) = item;

            err = lex(*end, &token, end);
            if (!err && token[0] != ')') {
                err = Error_Syntax;
            }

            return err;
        }

        err = read_expr(token, end, &item);
        if (err) {
            return err;
        }

        if (nilp(p)) {
            *result = cons(item, nil);
            p = *result;
        } else {
            cdr(p) = cons(item, nil);
            p = cdr(p);
        }
    }
}

int read_expr(const char *input, const char **end, Atom *result)
{
    const char *token;
    Error err;

    err = lex(input, &token, end);
    if (err) return err;

    if (token[0] == '(') {
        return read_list(*end, end, result);
    } else if (token[0] == ')') {
        return Error_Syntax;
    } else {
        return parse_simple(token, *end, result);
    }
}

void print_expr(Atom atom)
{
    switch (atom.type)
    {
    case AtomType_Nil:
        printf("NIL");
        break;

    case AtomType_Pair:
        putchar('(');
        print_expr(car(atom));
        atom = cdr(atom);
        while (!nilp(atom)) {
            if (atom.type == AtomType_Pair) {
                putchar(' ');
                print_expr(car(atom));
                atom = cdr(atom);
            } else {
                printf(" . ");
                print_expr(atom);
                break;
            }
        }
        putchar(')');
        break;

    case AtomType_Symbol:
        printf("%s", atom.value.symbol);
        break;

    case AtomType_Integer:
        printf("%ld", atom.value.integer);
        break;
    
    default:
        break;
    }
}

int main(int argc, char const *argv[])
{
    char *input;

    while ((input = readline("> ")) != NULL) {
        const char *p = input;
        Error err;
        Atom expr;

        err = read_expr(p, &p, &expr);

        switch (err)
        {
        case Error_OK:
            print_expr(expr);
            putchar('\n');
            break;
        case Error_Syntax:
            puts("Syntax error");
            break;
        }

        free(input);
    }

    return 0;
}
----

在Ubuntu环境下，可以安装 readline 库，然后再编译的时候需要链接上这个库。

[source,bash]
----
$ sudo apt-get install libreadline6-dev
$ gcc lisp.c -lreadline -o lisp
----

== 第四章：表达式、环境和求值

=== 表达式

在LISP中，一切都是表达式。表达式可以是字面量，标识符或由运算符和一个或多个参数组成的列表。

字面量是具有内在值的对象。在我们的系统中，它可以是整数或NIL（如果你认为"nothing"是一个值的话）。

标识符是对象的名称。符号可以是标识符。

其他所有内容都是形式为 `(运算符 参数...)` 的列表，其中 `参数...` 表示零个或多个参数。

=== 环境

为了将标识符和对象关联起来，我们需要 _环境_ 。环境是一系列绑定（binding）的集合。每一个绑定由一个标识符和标识符所对应的值组成。例如：

.绑定（bindings） 
|===
| *标识符* | *值*
| FOO | 42
| BAR | NIL
| BAZ | (X Y Z)
|===

注意：所有的标识符都是符号。但是值可以是任意对象。例如BAZ就是一个包含三个符号的列表。

一个环境可能会有一个 _父环境_ 。如果在一个环境里面，不存在某个标识符对应的绑定，那么就会去父环境里去找这个标识符的绑定，如果还找不到，那么就会去父环境的父环境寻找标识符的绑定。所以可以看到，我们这里其实是创建了一棵环境树，一个环境会共享它的父环境的绑定。

==== 实现

下面的代码是表达环境的一种传统方式，使用了LISP中的数据类型。

[source,scheme]
----
(parent (identifier . value)...)
----

所以上面的表：绑定所对应的环境如下（没有parent）：

[source,scheme]
----
(NIL (FOO . 42) (BAR . NIL) (BAZ . (X Y Z)))
----

以下的C代码创建了一个空环境，这个空环境的父环境是parent（parent也可以是NIL）

[source,c]
----
Atom env_create(Atom parent)
{
    return cons(parent, nil);
}
----

接下来我们写两个函数用来获取和创建环境中的绑定。

[source,c]
----
int env_get(Atom env, Atom symbol, Atom *result)
{
    Atom parent = car(env);
    Atom bs = cdr(env);

    while (!nilp(bs)) {
        Atom b = car(bs);
        if (car(b).value.symbol == symbol.value.symbol) {
            *result = cdr(b);
            return Error_OK;
        }
        bs = cdr(bs);
    }

    if (nilp(parent))
        return Error_Unbound;

    return env_get(parent, symbol, result);
}
----

由于我们禁止命名两个相同名字的符号，所以我们这里不需要调用 `strcmp` 函数，这意味着 `lookup` 函数运行起来速度不会太慢。

[source,c]
----
int env_set(Atom env, Atom symbol, Atom value)
{
    Atom bs = cdr(env);
    Atom b = nil;

    while (!nilp(bs)) {
        b = car(bs);
        if (car(b).value.symbol == symbol.value.symbol) {
            cdr(b) = value;
            return Error_OK;
        }
        bs = cdr(bs);
    }

    b = cons(symbol, value);
    cdr(env) = cons(b, cdr(env));

    return Error_OK;
}
----

只有 `env_get` 函数会递归的去检查父环境。因为我们并不想修改父环境的绑定。

=== 求值

我们需要对表达式进行求值。求值过程的输入是一个表达式和一个环境，输出是一个值。让我们规定一下求值的规则。

* 字面量的求值结果是它本身。
* 环境可以让我们找到一个标识符所对应的值是什么。如果环境中不存在一个标识符所对应的值，那么对这个标识符求值会返回错误。
* 一个列表表达式如果具有以下某个操作符，就成为一个 _特殊形式_ (special form)：
    * *QUOTE* ：表达式 `(QUOTE EXPR)` 的求值结果是： `EXPR` 。这个 `EXPR` 被直接返回，并没有进行求值。
    * *DEFINE* ：对表达式 `(DEFINE SYMBOL EXPR)` 进行求值将会创建一个针对 `SYMBOL` 在环境中的绑定，或者修改这个 `SYMBOL` 在环境中的绑定。 `SYMBOL` 将会绑定到 `EXPR` 的求值结果。 `DEFINE` 表达式的求值结果将返回 `SYMBOL` 。
* 对其他任何形式的表达式进行求值都是无效的。

==== 实现

我们需要检查一下一个表达式是否是正规列表（proper list）。

[source,c]
----
int listp(Atom expr)
{
    while (!nilp(expr)) {
        if (expr.type != AtomType_Pair)
            return 0;
        expr = cdr(expr);
    }
    return 1;
}
----

Error枚举类型需要一些更多的选项：

|===
| Error_Unbound | 试图去对一个不存在绑定的符号求值
| Error_Args    | 一个列表表达式比预期的长或者短
| Error_Type    | 表达式中对象的类型和预期的不一样（类型错误）
|===

我们直接将表达式的求值规则翻译成C语言就可以了。

[source,c]
----
int eval_expr(Atom expr, Atom env, Atom *result)
{
    Atom op, args;
    Error err;

    if (expr.type == AtomType_Symbol) {
        return env_get(env, expr, result);
    } else if (expr.type != AtomType_Pair) {
        *result = expr;
        return Error_OK;
    }

    if (!listp(expr))
        return Error_Syntax;

    op = car(expr);
    args = cdr(expr);

    if (op.type == AtomType_Symbol) {
        if (strcmp(op.value.symbol, "QUOTE") == 0) {
            if (nilp(args) || !nilp(cdr(args)))
                return Error_Args;

            *result = car(args);
            return Error_OK;
        } else if (strcmp(op.value.symbol, "DEFINE") == 0) {
            Atom sym, val;

            if (nilp(args) || nilp(cdr(args)) || !nilp(cdr(cdr(args))))
                return Error_Args;

            sym = car(args);
            if (sym.type != AtomType_Symbol)
                return Error_Type;

            err = eval_expr(car(cdr(args)), env, &val);
            if (err)
                return err;

            *result = sym;
            return env_set(env, sym, val);
        }
    }

    return Error_Syntax;
}
----

==== 测试

将读取-打印循环扩展成为 `读取-求值-打印` 循环（REPL）。REPL是LISP解释器的核心功能。

[source,c]
----
int main(int argc, char **argv)
{
    Atom env;
    char *input;

    env = env_create(nil);

    while ((input = readline("> ")) != NULL) {
        const char *p = input;
        Error err;
        Atom expr, result;

        err = read_expr(p, &p, &expr);		

        if (!err)
            err = eval_expr(expr, env, &result);

        switch (err) {
        case Error_OK:
            print_expr(result);
            putchar('\n');
            break;
        case Error_Syntax:
            puts("Syntax error");
            break;
        case Error_Unbound:
            puts("Symbol not bound");
            break;
        case Error_Args:
            puts("Wrong number of arguments");
            break;
        case Error_Type:
            puts("Wrong type");
            break;
        }

        free(input);
    }

    return 0;
}
----

让我们看一下结果：

[source,text]
----
> foo
Symbol not bound
> (quote foo)
FOO
> (define foo 42)
FOO
> foo
42
> (define foo (quote bar))
FOO
> foo
BAR
----

== 第五章：内建函数

到目前为止，在我们的实现中，我们已经使用了 `car` ， `cdr` 和 `cons` 函数来构造和访问LISP数据。现在，我们将在解释环境中提供相同的功能。

我们将扩展列表表达式语法以添加一些新的运算符：

* `(CAR EXPR)` ：对 `EXPR` 进行求值，然后返回求值结果的 `car` 部分。如果 `EXPR` 的求值结果既不是 `pair` 也不是 `NIL` ，则返回错误。
* `(CDR EXPR)` ：对 `EXPR` 进行求值，然后返回求值结果的 `cdr` 部分。如果 `EXPR` 的求值结果既不是 `pair` 也不是 `NIL` ，则返回错误。
* `(CONS A B)` ：Evaluates both arguments A and B, and returns a newly constructed pair containing the results.对 `A` 和 `B` 进行求值，然后返回包含 `A` 和 `B` 的求值结果的 `pair` 。

在上面的定义中，我们允许对 `NIL` 取 `car` 部分和 `cdr` 部分，不像我们之前C版本对 `car` 和 `cdr` 的实现。如果对 `NIl` 取 `car` 和 `cdr` 的值定义为 `NIL` ，那么一些算法会相对容易实现一些。

我们选择在 `eval_expr` 函数中添加一些分支条件来实现上面定义的内置函数，就像我们之前实现 `QUOTE` 和 `DEFINE` 一样。尽管如此，我们想在未来添加更多的运算符，而将每个运算符都添加到 `eval_expr` 中会让函数变得很长。所以我们现在来介绍一下函数的概念。

*函数*

一个函数就是一个代码片段，这个代码片段将一些参数转换成了一个值。如果 `eval_expr` 碰到了一个列表表达式，而列表表达式中有一个函数是运算符，那么 `eval_expr` 所要做的就是执行函数的代码片段，然后将所得到的求值结果作为表达式的结果返回。

实现函数的方式就是创建一些C函数，可以被 `eval_expr` 所调用。我们称这些函数为内置函数或者原始函数。让我们来看一下如何扩展我们的LISP解释器将函数包含进来。

=== 一种新的Atom类型

`eval_expr` 将通过C的函数指针来调用内置函数，所以内置函数的类型必须一样：

[source,c]
----
typedef int (*Builtin)(struct Atom args, struct Atom *result);
----

上面是一个函数指针类型，这个函数指针的类型是 `Builtin` ，接收两个参数，返回值是 `int` 。

为了可以在表达式中出现函数，我们需要一种新的 `atom` 类型来表示它们。

[source,c]
----
struct Atom {
    enum {
        .
        .
        .
        AtomType_Builtin
    } type;

    union {
        .
        .
        .
        Builtin builtin;
    } value;
};
----

我们之前写过的代码用". . ."表示省略。为了代码的完整性， `print_expr` 需要知道如何显示新的 `atom` 类型：

[source,c]
----
void print_expr(Atom atom)
{
    switch (atom.type) {
    .
    .
    .
    case AtomType_Builtin:
        printf("#<BUILTIN:%p>", atom.value.builtin);
        break;
    }
}
----

最终，我们写一个辅助方法来创建新的 `atom` 类型：

[source,c]
----
Atom make_builtin(Builtin fn)
{
    Atom a;
    a.type = AtomType_Builtin;
    a.value.builtin = fn;
    return a;
}
----

=== 扩展求值器

我们将对参数列表进行 _浅拷贝_ 。

[source,c]
----
Atom copy_list(Atom list)
{
    Atom a, p;

    if (nilp(list))
        return nil;

    a = cons(car(list), nil);
    p = a;
    list = cdr(list);

    while (!nilp(list)) {
        cdr(p) = cons(car(list), nil);
        p = cdr(p);
        list = cdr(list);
    }

    return a;
}
----

*apply* 仅仅只是针对一个参数列表调用内置函数。我们将在后面扩展这个函数，因为我们需要处理一些其他的求值函数。

[source,c]
----
int apply(Atom fn, Atom args, Atom *result)
{
    if (fn.type == AtomType_Builtin)
        return (*fn.value.builtin)(args, result);

    return Error_Type;
}
----

如果列表表达式不是我们之前定义过的 _特殊形式_ ，那么我们将假设运算符将会被求值成一个函数。我们将对参数列表中的每一个参数进行求值，然后使用 `apply` 来将函数作用到参数列表求值以后的结果列表上。

[source,c]
----
int eval_expr(Atom expr, Atom env, Atom *result)
{
    Atom op, args, p;
    Error err;

    .
    .
    .

    if (op.type == AtomType_Symbol) {
        .
        .
        .
    }

    /* Evaluate operator */
    err = eval_expr(op, env, &op);
    if (err)
        return err;

    /* Evaulate arguments */
    args = copy_list(args);
    p = args;
    while (!nilp(p)) {
        err = eval_expr(car(p), env, &car(p));
        if (err)
            return err;

        p = cdr(p);
    }

    return apply(op, args, result);
}
----

我们在对参数列表进行求值时，先对参数列表进行浅拷贝。这样就避免了把旧的参数列表覆盖掉。因为我们可能会再一次使用旧的参数列表。

=== 初始环境

之前我们为LISP的 `读取——求值——打印` 循环创建过一个空环境。用户没有办法创建表示内置函数的 `atom` 类型。所以我们会在初始环境中绑定好内置函数。

以下是函数：

[source,c]
----
int builtin_car(Atom args, Atom *result)
{
    if (nilp(args) || !nilp(cdr(args)))
        return Error_Args;

    if (nilp(car(args)))
        *result = nil;
    else if (car(args).type != AtomType_Pair)
        return Error_Type;
    else
        *result = car(car(args));

    return Error_OK;
}
----

函数中的大部分代码都是错误处理和类型检查。这样来创建函数真是一件烦人的事情。

[source,c]
----
int builtin_cdr(Atom args, Atom *result)
{
    if (nilp(args) || !nilp(cdr(args)))
        return Error_Args;

    if (nilp(car(args)))
        *result = nil;
    else if (car(args).type != AtomType_Pair)
        return Error_Type;
    else
        *result = cdr(car(args));

    return Error_OK;
}
----

`builtin_cdr` 和 `builtin_car` 几乎是一样的。

[source,c]
----
int builtin_cons(Atom args, Atom *result)
{
    if (nilp(args) || nilp(cdr(args)) || !nilp(cdr(cdr(args))))
        return Error_Args;

    *result = cons(car(args), car(cdr(args)));

    return Error_OK;
}
----

有了以上的函数，我们就可以使用 `env_set` 函数来创建绑定了。

[source,c]
----
int main(int argc, char **argv)
{
    Atom env;
    char *input;

    env = env_create(nil);

    /* Set up the initial environment */
    env_set(env, make_sym("CAR"), make_builtin(builtin_car));
    env_set(env, make_sym("CDR"), make_builtin(builtin_cdr));
    env_set(env, make_sym("CONS"), make_builtin(builtin_cons));

    while ((input = readline("> ")) != NULL) {
        .
        .
        .
    }

    return 0;
}
----

=== 测试

[source,text]
----
> (define foo 1)
FOO
> (define bar 2)
BAR
> (cons foo bar)
(1 . 2)
> (define baz (quote (a b c)))
BAZ
> (car baz)
A
> (cdr baz)
(B C)
----

NOTE: `(CONS FOO BAR)` 和 `(QUOTE (FOO . BAR))` 是不一样的。前者将会对参数列表进行求值，然后创建一个新的 `pair` 。

== 第六章：算术表达式

到目前为止，我们所能做的就是创建和命名对象。这些对象中有些是数字——自然，我们想对这些数字进行计算。

在上一章中，我们看到了如何创建内置函数来告诉eval_expr如何将参数处理为返回值。现在，我们将再创建四个内建函数来执行基本的算术运算。

|===
| Expression | Result
| (+ X Y) | The sum of X and Y
| (- X Y) | The difference of X and Y
| (* X Y) | The product of X and Y
| (/ X Y) | The quotient of X and Y
|===

在上面的定义中，当我们写“X和Y的总和”时，我们真正的意思是“通过求值X和Y所获得的值的总和”。请记住，默认情况下，eval_expr将对函数的所有参数求值；这通常是我们想要发生的事情，因此从现在开始，我们将不会在意图明显的地方明确声明这一点。

=== 实现

再一次，几乎我们所有的函数都包括检查是否提供了正确的参数。最后，通过调用 `make_int` 构造结果。

[source,c]
----
int builtin_add(Atom args, Atom *result)
{
    Atom a, b;

    if (nilp(args) || nilp(cdr(args)) || !nilp(cdr(cdr(args))))
        return Error_Args;

    a = car(args);
    b = car(cdr(args));

    if (a.type != AtomType_Integer || b.type != AtomType_Integer)
        return Error_Type;

    *result = make_int(a.value.integer + b.value.integer);

    return Error_OK;
}
----

其他三个函数仅相差一个字符，因此在此将其省略。

最后，我们需要在初始环境中为我们的新功能创建绑定：

[source,c]
----
env_set(env, make_sym("+"), make_builtin(builtin_add));
env_set(env, make_sym("-"), make_builtin(builtin_subtract));
env_set(env, make_sym("*"), make_builtin(builtin_multiply));
env_set(env, make_sym("/"), make_builtin(builtin_divide));
----

=== 测试

现在，我们有了自己的LISP风格的计算器。

[source,text]
----
> (+ 1 1)
2
> (define x (* 6 9))
X
> x
54
> (- x 12)
42
----

在上面的最后一个表达式中，请注意X是一个符号，而不是整数。我们必须对参数进行求值，以便builtin_subtract可以对绑定到X的整数值进行运算，而不是对符号X本身进行运算。同样，绑定到X的值是计算表达式（* 6 9）的整数结果。

== 第七章：Lambda表达式和闭包

这是事情开始变得有趣的地方。现在，我们将实现对lambda表达式的支持，这是一种在我们已经可以处理的LISP表达式之外动态构建函数的方法。

Lambda表达式是具有特定语法的列表表达式：

[source,scheme]
----
(LAMBDA (arg...) expr...)
----

求值lambda表达式的结果是一种新型的对象，我们称其为闭包。闭包可以以与内置函数相同的方式在列表表达式中使用。在这种情况下，参数将绑定到lambda表达式中以 `arg...` 列出的符号。函数的主体由表达式 `expr...` 组成，这些表达式将依次求值。求值最终表达式的结果是将参数应用于闭包的结果。

这是一个非常密集的定义，因此这是一个我们如何使用lambda表达式的示例：

[source,scheme]
----
(DEFINE SQUARE (LAMBDA (X) (* X X)))
----

`SQUARE` 现在是一个函数，有一个参数X，返回值是X的平方。所以对 `(SQUARE 3)` 进行求值应该返回9。

=== 实现

我们将使用列表来表示闭包：

[source,scheme]
----
(env (arg...) expr...)
----

env是定义闭包的环境。这是必需的，以允许lambda函数使用绑定而不必将其作为参数传递。例如，回想一下，CAR在初始环境中绑定到了我们原始的builtin_car函数。

第一个任务是为Atom结构的type字段添加一个新的常量：

[source,c]
----
struct Atom {
    enum {
        .
        .
        .
        AtomType_Closure
    } type;

    union {
        .
        .
        .
    } value;
};
----

由于闭包只是常规列表，因此无需添加任何值。

像其他原子类型一样，我们将创建一个实用程序函数来初始化它们。 `make_closure` 与其他命令不同，对参数执行一些验证，因此需要返回错误代码。

[source,c]
----
int make_closure(Atom env, Atom args, Atom body, Atom *result)
{
    Atom p;

    if (!listp(args) || !listp(body))
        return Error_Syntax;

    /* Check argument names are all symbols */
    p = args;
    while (!nilp(p)) {
        if (car(p).type != AtomType_Symbol)
            return Error_Type;
        p = cdr(p);
    }

    *result = cons(env, cons(args, body));
    result->type = AtomType_Closure;

    return Error_OK;
}
----

接下来是eval中的另一种特殊情况，每当遇到lambda表达式时都创建一个闭包。

[source,c]
----
int eval_expr(Atom expr, Atom env, Atom *result)
{
    .
    .
    .
    if (op.type == AtomType_Symbol) {
        if (strcmp(op.value.symbol, "QUOTE") == 0) {
        .
        .
        .
        } else if (strcmp(op.value.symbol, "LAMBDA") == 0) {
            if (nilp(args) || nilp(cdr(args)))
                return Error_Args;

            return make_closure(env, car(args), cdr(args), result);
        }
    }
    .
    .
    .
}
----

上面的SQUARE示例的函数体用X表示。为了对函数体进行求值，我们需要创建一个新环境，其中X绑定到参数的值：

[source,scheme]
----
(closure-env (X . 3))
----

父环境 `closure-env` 是存储在闭包中的环境。

最后，我们扩展 `apply` 函数以创建新环境，并为函数体中的每个表达式调用eval。

[source,c]
----
int apply(Atom fn, Atom args, Atom *result)
{
    Atom env, arg_names, body;

    if (fn.type == AtomType_Builtin)
        return (*fn.value.builtin)(args, result);
    else if (fn.type != AtomType_Closure)
        return Error_Type;

    env = env_create(car(fn));
    arg_names = car(cdr(fn));
    body = cdr(cdr(fn));

    /* Bind the arguments */
    while (!nilp(arg_names)) {
        if (nilp(args))
            return Error_Args;
        env_set(env, car(arg_names), car(args));
        arg_names = cdr(arg_names);
        args = cdr(args);
    }
    if (!nilp(args))
        return Error_Args;

    /* Evaluate the body */
    while (!nilp(body)) {
        Error err = eval_expr(car(body), env, result);
        if (err)
            return err;
        body = cdr(body);
    }

    return Error_OK;
}
----

=== 测试

让我们检查一下我们的SQUARE函数是否按预期工作。

[source,scheme]
----
> (define square (lambda (x) (* x x)))
SQUARE
> (square 3)
9
> (square 4)
16
----

当然，lambda表达式不必绑定到符号——我们可以创建匿名函数。

[source,scheme]
----
> ((lambda (x) (- x 2)) 7)
5
----

函数式编程的爱好者将很高兴看到我们现在可以做这种事情：

[source,scheme]
----
> (define make-adder (lambda (x) (lambda (y) (+ x y))))
MAKE-ADDER
> (define add-two (make-adder 2))
ADD-TWO
> (add-two 5)
7
----

你知道值“2”存储在哪里吗？

== 第八章：布尔值和短路求值

=== 布尔值

布尔值是称为true和false的两类值之一。如果我们希望将值解释为布尔值，则如果它属于true值类，则认为它为true，否则为false。

=== 短路求值

到目前为止，我们求值了传递给eval的每个表达式。除特殊形式（如DEFINE和LAMBDA）存储了供以后求值的表达式外，eval必须在遍历整个树之前返回结果。

在本章中，我们将定义另一种特殊形式的IF，它将使eval选择要求值的两个可能表达式中的哪个，而舍弃另一个表达式。

语法如下：

[source,scheme]
----
(IF test true-expr false-expr)
----

其中test，true-expr和false-expr是任意表达式。如果对test求值的结果为真，则IF表达式的结果为true-expr的求值结果，否则为false-expr的求值结果。仅对true-expr和false-expr之一进行求值；另一个表达式将被忽略。

但是什么样的值才是真的？在我们的环境中，我们将NIL定义为false。任何其他值都为true。

这是处理IF表达式的代码。

[source,c]
----
int eval_expr(Atom expr, Atom env, Atom *result)
{
    .
    .
    .
    if (op.type == AtomType_Symbol) {
        if (strcmp(op.value.symbol, "QUOTE") == 0) {
        .
        .
        .
        } else if (strcmp(op.value.symbol, "IF") == 0) {
            Atom cond, val;

            if (nilp(args) || nilp(cdr(args)) || nilp(cdr(cdr(args)))
                    || !nilp(cdr(cdr(cdr(args)))))
                return Error_Args;

            err = eval_expr(car(args), env, &cond);
            if (err)
                return err;

            val = nilp(cond) ? car(cdr(cdr(args))) : car(cdr(args));
            return eval_expr(val, env, result);
        }
    }
    .
    .
    .
}
----

传统上，如果LISP函数需要返回布尔值并且没有明显的对象可用，则返回符号T。T是绑定到自身的，因此对其进行求值将再次返回符号T。如果符号不是NIL，那就是true。

将T的绑定添加到初始环境：

[source,c]
----
env_set(env, make_sym("T"), make_sym("T"));
----

请记住，如果多次调用具有相同字符串的同一个符号对象，make_sym将返回该对象。

==== 测试

[source,text]
----
> (if t 3 4)
3
> (if nil 3 4)
4
> (if 0 t nil)
T
----

和C不一样，0是true，而不是false。

=== 谓词

虽然我们可以在这里停下来，但进行一些测试（除了“is it NIL”之外）会很有用。这是谓词出现的地方。谓词是一个根据某些条件返回true/false值的函数。

我们将定义两个内置谓词，“=”测试数字相等性，“<”测试一个数字是否小于另一个。

函数类似于我们的其他数字内置函数。

[source,c]
----
int builtin_numeq(Atom args, Atom *result)
{
    Atom a, b;

    if (nilp(args) || nilp(cdr(args)) || !nilp(cdr(cdr(args))))
        return Error_Args;

    a = car(args);
    b = car(cdr(args));

    if (a.type != AtomType_Integer || b.type != AtomType_Integer)
        return Error_Type;

    *result = (a.value.integer == b.value.integer) ? make_sym("T") : nil;

    return Error_OK;
}
----

`builtin_less` 遵循相同的模式，此处未显示。

最后，我们必须将它们添加到初始环境中。

[source,c]
----
env_set(env, make_sym("="), make_builtin(builtin_numeq));
env_set(env, make_sym("<"), make_builtin(builtin_less));
----

==== 测试

[source,text]
----
> (= 3 3)
T
> (< 11 4)
NIL
----

除非存在内存和堆栈限制，否则我们的LISP环境现在已经图灵完备！如果你一直在写代码，则可以确认我们已经在1000行以下C代码中实现了可用编程语言的核心。

=== 完整代码

[source,c]
----
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <ctype.h>
#include <readline/readline.h>

typedef enum {
    Error_OK = 0,
    Error_Syntax,
    Error_Unbound,
    Error_Args,
    Error_Type
} Error;

typedef struct Atom Atom;
typedef int (*Builtin)(struct Atom args, struct Atom *result);

struct Atom
{
    enum {
        AtomType_Nil,
        AtomType_Pair,
        AtomType_Symbol,
        AtomType_Integer,
        AtomType_Builtin,
        AtomType_Closure
    } type;

    union {
        struct Pair *pair;
        const char *symbol;
        long integer;
        Builtin builtin;
    } value;
};

struct Pair {
    struct Atom atom[2];
};

#define car(p) ((p).value.pair->atom[0])
#define cdr(p) ((p).value.pair->atom[1])
#define nilp(atom) ((atom).type == AtomType_Nil)

static const Atom nil = { AtomType_Nil };
static Atom sym_table = { AtomType_Nil };

Atom cons(Atom car_val, Atom cdr_val)
{
    Atom p;

    p.type = AtomType_Pair;
    p.value.pair = malloc(sizeof(struct Pair));

    car(p) = car_val;
    cdr(p) = cdr_val;

    return p;
}

int listp(Atom expr);
int env_get(Atom env, Atom symbol, Atom *result);
int env_set(Atom env, Atom symbol, Atom value);
int eval_expr(Atom expr, Atom env, Atom *result);

int listp(Atom expr)
{
    while (!nilp(expr)) {
        if (expr.type != AtomType_Pair)
            return 0;
        expr = cdr(expr);
    }
    return 1;
}

Atom make_int(long x)
{
    Atom a;
    a.type = AtomType_Integer;
    a.value.integer = x;
    return a;
}

Atom make_sym(const char *s)
{
    Atom a, p;

    p = sym_table;
    while (!nilp(p)) {
        a = car(p);
        if (strcmp(a.value.symbol, s) == 0)
            return a;
        p = cdr(p);
    }

    a.type = AtomType_Symbol;
    a.value.symbol = strdup(s);
    sym_table = cons(a, sym_table);

    return a;
}

Atom make_builtin(Builtin fn)
{
    Atom a;
    a.type = AtomType_Builtin;
    a.value.builtin = fn;
    return a;
}

int make_closure(Atom env, Atom args, Atom body, Atom *result)
{
    Atom p;

    if (!listp(args) || !listp(body))
        return Error_Syntax;

    p = args;
    while (!nilp(p)) {
        if (car(p).type != AtomType_Symbol)
            return Error_Type;
        p = cdr(p);
    }

    *result = cons(env, cons(args, body));
    result->type = AtomType_Closure;

    return Error_OK;
}

Atom copy_list(Atom list)
{
    Atom a, p;

    if (nilp(list))
        return nil;

    a = cons(car(list), nil);
    p = a;
    list = cdr(list);

    while (!nilp(list)) {
        cdr(p) = cons(car(list), nil);
        p = cdr(p);
        list = cdr(list);
    }

    return a;
}

Atom env_create(Atom parent)
{
    return cons(parent, nil);
}

int apply(Atom fn, Atom args, Atom *result)
{
    Atom env, arg_names, body;

    if (fn.type == AtomType_Builtin)
        return (*fn.value.builtin)(args, result);
    else if (fn.type != AtomType_Closure)
        return Error_Type;

    env = env_create(car(fn));
    arg_names = car(cdr(fn));
    body = cdr(cdr(fn));

    while (!nilp(arg_names)) {
        if (nilp(args))
            return Error_Args;
        env_set(env, car(arg_names), car(args));
        arg_names = cdr(arg_names);
        args = cdr(args);
    }
    if (!nilp(args))
        return Error_Args;

    while (!nilp(body)) {
        Error err = eval_expr(car(body), env, result);
        if (err)
            return err;
        body = cdr(body);
    }

    return Error_OK;
}

int env_get(Atom env, Atom symbol, Atom *result)
{
    Atom parent = car(env);
    Atom bs = cdr(env);

    while(!nilp(bs)) {
        Atom b = car(bs);
        if (car(b).value.symbol == symbol.value.symbol) {
            *result = cdr(b);
            return Error_OK;
        }
        bs = cdr(bs);
    }

    if (nilp(parent))
        return Error_Unbound;

    return env_get(parent, symbol, result);
}

int env_set(Atom env, Atom symbol, Atom value)
{
    Atom bs = cdr(env);
    Atom b = nil;

    while (!nilp(bs)) {
        b = car(bs);
        if (car(b).value.symbol == symbol.value.symbol) {
            cdr(b) = value;
            return Error_OK;
        }
        bs = cdr(bs);
    }

    b = cons(symbol, value);
    cdr(env) = cons(b, cdr(env));

    return Error_OK;
}


int eval_expr(Atom expr, Atom env, Atom *result)
{
    Atom op, args, p;
    Error err;

    if (expr.type == AtomType_Symbol) {
        return env_get(env, expr, result);
    } else if (expr.type != AtomType_Pair) {
        *result = expr;
        return Error_OK;
    }

    if (!listp(expr))
        return Error_Syntax;

    op = car(expr);
    args = cdr(expr);

    if (op.type == AtomType_Symbol) {
        if (strcmp(op.value.symbol, "QUOTE") == 0) {
            if (nilp(args) || !nilp(cdr(args)))
                return Error_Args;

            *result = car(args);
            return Error_OK;
        } else if (strcmp(op.value.symbol, "IF") == 0) {
            Atom cond, val;

            if (nilp(args) || nilp(cdr(args)) || nilp(cdr(cdr(args))) || !nilp(cdr(cdr(cdr(args)))))
                return Error_Args;

            err = eval_expr(car(args), env, &cond);
            if (err)
                return err;

            val = nilp(cond) ? car(cdr(cdr(args))) : car(cdr(args));
            return eval_expr(val, env, result);
        } else if (strcmp(op.value.symbol, "LAMBDA") == 0) {
            if (nilp(args) || nilp(cdr(args)))
                return Error_Args;

            return make_closure(env, car(args), cdr(args), result);
        } else if (strcmp(op.value.symbol, "DEFINE") == 0) {
            Atom sym, val;

            if (nilp(args) || nilp(cdr(args)) || !nilp(cdr(cdr(args))))
                return Error_Args;

            sym = car(args);
            if (sym.type != AtomType_Symbol)
                return Error_Type;

            err = eval_expr(car(cdr(args)), env, &val);
            if (err)
                return err;

            *result = sym;
            return env_set(env, sym, val);
        }
    }

    err = eval_expr(op, env, &op);
    if (err)
        return err;

    args = copy_list(args);
    p = args;
    while (!nilp(p)) {
        err = eval_expr(car(p), env, &car(p));
        if (err)
            return err;

        p = cdr(p);
    }

    return apply(op, args, result);
}

int lex(const char *str, const char **start, const char **end)
{
    const char *ws = " \t\n";
    const char *delim = "() \t\n";
    const char *prefix = "()";

    str += strspn(str, ws);

    if (str[0] == '\0') {
        *start = *end = NULL;
        return Error_Syntax;
    }

    *start = str;

    // strchr函数功能为在一个串中查找给定字符的第一个匹配之处
    if (strchr(prefix, str[0]) != NULL)
        *end = str + 1;
    else
    // 该函数返回 str1 开头连续都不含字符串 str2 中字符的字符数。
        *end = str + strcspn(str, delim);

    return Error_OK;
}

int read_expr(const char *input, const char **end, Atom *result);

int parse_simple(const char *start, const char *end, Atom *result)
{
    char *buf, *p;

    long val = strtol(start, &p, 10);
    if (p == end) {
        result->type = AtomType_Integer;
        result->value.integer = val;
        return Error_OK;
    }

    buf = malloc(end - start + 1);
    p = buf;
    while (start != end)
        *p++ = toupper(*start), ++start;
    *p = '\0';

    if (strcmp(buf, "NIL") == 0) {
        *result = nil;
    } else {
        *result = make_sym(buf);
    }

    free(buf);

    return Error_OK;
}

int read_list(const char *start, const char **end, Atom *result)
{
    Atom p;

    *end = start;
    p = *result = nil;

    for (;;) {
        const char *token;
        Atom item;
        Error err;

        err = lex(*end, &token, end);
        if (err) {
            return err;
        }

        if (token[0] == ')') {
            return Error_OK;
        }

        if (token[0] == '.' && *end - token == 1) {
            if (nilp(p)) {
                return Error_Syntax;
            }

            err = read_expr(*end, end, &item);
            if (err) {
                return err;
            }

            cdr(p) = item;

            err = lex(*end, &token, end);
            if (!err && token[0] != ')') {
                err = Error_Syntax;
            }

            return err;
        }

        err = read_expr(token, end, &item);
        if (err) {
            return err;
        }

        if (nilp(p)) {
            *result = cons(item, nil);
            p = *result;
        } else {
            cdr(p) = cons(item, nil);
            p = cdr(p);
        }
    }
}

int read_expr(const char *input, const char **end, Atom *result)
{
    const char *token;
    Error err;

    err = lex(input, &token, end);
    if (err) return err;

    if (token[0] == '(') {
        return read_list(*end, end, result);
    } else if (token[0] == ')') {
        return Error_Syntax;
    } else {
        return parse_simple(token, *end, result);
    }
}

void print_expr(Atom atom)
{
    switch (atom.type) {
    case AtomType_Nil:
        printf("NIL");
        break;
    case AtomType_Pair:
        putchar('(');
        print_expr(car(atom));
        atom = cdr(atom);
        while (!nilp(atom)) {
            if (atom.type == AtomType_Pair) {
                putchar(' ');
                print_expr(car(atom));
                atom = cdr(atom);
            } else {
                printf(" . ");
                print_expr(atom);
                break;
            }
        }
        putchar(')');
        break;
    case AtomType_Symbol:
        printf("%s", atom.value.symbol);
        break;
    case AtomType_Integer:
        printf("%ld", atom.value.integer);
        break;
    case AtomType_Builtin:
        printf("#<BUILTIN:%p>", atom.value.builtin);
        break;
    }
}

int builtin_car(Atom args, Atom *result)
{
    if (nilp(args) || !nilp(cdr(args)))
        return Error_Args;

    if (nilp(car(args)))
        *result = nil;
    else if (car(args).type != AtomType_Pair)
        return Error_Type;
    else
        *result = car(car(args));

    return Error_OK;
}

int builtin_cdr(Atom args, Atom *result)
{
    if (nilp(args) || !nilp(cdr(args)))
        return Error_Args;

    if (nilp(car(args)))
        *result = nil;
    else if (car(args).type != AtomType_Pair)
        return Error_Type;
    else
        *result = cdr(car(args));

    return Error_OK;
}

int builtin_cons(Atom args, Atom *result)
{
    if (nilp(args) || nilp(cdr(args)) || !nilp(cdr(cdr(args))))
        return Error_Args;

    *result = cons(car(args), car(cdr(args)));

    return Error_OK;
}

int builtin_add(Atom args, Atom *result)
{
    Atom a, b;

    if (nilp(args) || nilp(cdr(args)) || !nilp(cdr(cdr(args))))
        return Error_Args;

    a = car(args);
    b = car(cdr(args));

    if (a.type != AtomType_Integer || b.type != AtomType_Integer)
        return Error_Type;

    *result = make_int(a.value.integer + b.value.integer);

    return Error_OK;
}

int builtin_subtract(Atom args, Atom *result)
{
    Atom a, b;

    if (nilp(args) || nilp(cdr(args)) || !nilp(cdr(cdr(args))))
        return Error_Args;

    a = car(args);
    b = car(cdr(args));

    if (a.type != AtomType_Integer || b.type != AtomType_Integer)
        return Error_Type;

    *result = make_int(a.value.integer - b.value.integer);

    return Error_OK;
}

int builtin_multiply(Atom args, Atom *result)
{
    Atom a, b;

    if (nilp(args) || nilp(cdr(args)) || !nilp(cdr(cdr(args))))
        return Error_Args;

    a = car(args);
    b = car(cdr(args));

    if (a.type != AtomType_Integer || b.type != AtomType_Integer)
        return Error_Type;

    *result = make_int(a.value.integer * b.value.integer);

    return Error_OK;
}

int builtin_divide(Atom args, Atom *result)
{
    Atom a, b;

    if (nilp(args) || nilp(cdr(args)) || !nilp(cdr(cdr(args))))
        return Error_Args;

    a = car(args);
    b = car(cdr(args));

    if (a.type != AtomType_Integer || b.type != AtomType_Integer)
        return Error_Type;

    *result = make_int(a.value.integer / b.value.integer);

    return Error_OK;
}

int builtin_numeq(Atom args, Atom *result)
{
    Atom a, b;

    if (nilp(args) || nilp(cdr(args)) || !nilp(cdr(cdr(args))))
        return Error_Args;

    a = car(args);
    b = car(cdr(args));

    if (a.type != AtomType_Integer || b.type != AtomType_Integer)
        return Error_Type;

    *result = (a.value.integer == b.value.integer) ? make_sym("T") : nil;

    return Error_OK;
}

int builtin_less(Atom args, Atom *result)
{
    Atom a, b;

    if (nilp(args) || nilp(cdr(args)) || !nilp(cdr(cdr(args))))
        return Error_Args;

    a = car(args);
    b = car(cdr(args));

    if (a.type != AtomType_Integer || b.type != AtomType_Integer)
        return Error_Type;

    *result = (a.value.integer < b.value.integer) ? make_sym("T") : nil;

    return Error_OK;
}

int main(int argc, char **argv)
{
    Atom env;
    char *input;

    env = env_create(nil);

    env_set(env, make_sym("CAR"), make_builtin(builtin_car));
    env_set(env, make_sym("CDR"), make_builtin(builtin_cdr));
    env_set(env, make_sym("CONS"), make_builtin(builtin_cons));
    env_set(env, make_sym("+"), make_builtin(builtin_add));
    env_set(env, make_sym("-"), make_builtin(builtin_subtract));
    env_set(env, make_sym("*"), make_builtin(builtin_multiply));
    env_set(env, make_sym("/"), make_builtin(builtin_divide));
    env_set(env, make_sym("T"), make_sym("T"));
    env_set(env, make_sym("="), make_builtin(builtin_numeq));
    env_set(env, make_sym("<"), make_builtin(builtin_less));

    while ((input = readline("> ")) != NULL) {
        const char *p = input;
        Error err;
        Atom expr, result;

        err = read_expr(p, &p, &expr);

        if (!err)
            err = eval_expr(expr, env, &result);

        switch (err) {
        case Error_OK:
            print_expr(result);
            putchar('\n');
            break;
        case Error_Syntax:
            puts("Syntax error");
            break;
        case Error_Unbound:
            puts("Symbol not bound");
            break;
        case Error_Args:
            puts("Wrong number of arguments");
            break;
        case Error_Type:
            puts("Wrong type");
            break;
        }

        free(input);
    }

    return 0;
}
----

编译：

[source,bash]
----
$ gcc lisp.c -lreadline -o lisp
----

== 第九章：语法糖

我们将定义一些其他语法，以方便输入一些常用表达式。回想一下，我们已经允许用户输入

[source,scheme]
----
(A B C)
----

用来替换

[source,scheme]
----
(A . (B . (C . NIL)))
----

=== 单引号

为了在表达式中包含文字符号或列表，我们需要使用QUOTE运算符。作为快捷方式，我们将定义

[source,scheme]
----
'EXPR
----

相当于

[source,scheme]
----
(QUOTE EXPR)
----

因此，例如以下形式是等效的：

|===
| Abbreviation | Canonical form | Evaluates to
| 'FOO | (QUOTE FOO) | FOO
| '(+ 1 2) | (QUOTE (+ 1 2)) | (+ 1 2)
| '(A . B) | (QUOTE (A . B)) | (A . B)
|===

词法分析器需要知道引号是前缀（即，引号可以紧接在另一个 `token` 之前出现，但不一定是分隔符）。

[source,c]
----
int lex(const char *str, const char **start, const char **end)
{
    const char *ws = " \t\n";
    const char *delim = "() \t\n";
    const char *prefix = "()\'";
    .
    .
    .
}
----

同样，read_expr必须将其转换为正确的列表表达式。

[source,c]
----
int read_expr(const char *input, const char **end, Atom *result)
{
    const char *token;
    Error err;

    err = lex(input, &token, end);
    if (err)
        return err;

    if (token[0] == '(') {
        return read_list(*end, end, result);
    } else if (token[0] == ')') {
        return Error_Syntax;
    } else if (token[0] == '\'') {
        *result = cons(make_sym("QUOTE"), cons(nil, nil));
        return read_expr(*end, end, &car(cdr(*result)));
    } else {
        return parse_simple(token, *end, result);
    }
}
----

==== 测试

[source,text]
----
> (define x '(a b c))
X
> x
(A B C)
> 'x
X
> (define foo 'bar)
FOO
> foo
BAR
> ''()
(QUOTE NIL)
----

=== 函数定义

每次我们想要定义一个函数时都必须键入一个lambda表达式，因此很麻烦，因此我们将修改DEFINE运算符来避免这种情况。

[source,scheme]
----
(DEFINE (name args...) body...)
----

相当于

[source,scheme]
----
(DEFINE name (LAMBDA (args...) body...))
----

下面是实现代码：

[source,c]
----
int eval_expr(Atom expr, Atom env, Atom *result)
{
    .
    .
    .
    if (op.type == AtomType_Symbol) {
        if (strcmp(op.value.symbol, "QUOTE") == 0) {
        .
        .
        .
        } else if (strcmp(op.value.symbol, "DEFINE") == 0) {
            Atom sym, val;

            if (nilp(args) || nilp(cdr(args)))
                return Error_Args;

            sym = car(args);
            if (sym.type == AtomType_Pair) {
                err = make_closure(env, cdr(sym), cdr(args), &val);
                sym = car(sym);
                if (sym.type != AtomType_Symbol)
                    return Error_Type;
            } else if (sym.type == AtomType_Symbol) {
                if (!nilp(cdr(cdr(args))))
                    return Error_Args;
                err = eval_expr(car(cdr(args)), env, &val);
            } else {
                return Error_Type;
            }

            if (err)
                return err;

            *result = sym;
            return env_set(env, sym, val);
        } else if (strcmp(op.value.symbol, "LAMBDA") == 0) {
        .
        .
        .
        }
    }
    .
    .
    .
}
----

==== 测试

[source,text]
----
> (define (square x) (* x x))
SQUARE
> (square 3)
9
----

== 第十章：变长参数的函数

到目前为止，所有函数都具有指定数量的命名参数。现在，我们将介绍一种用于定义可变参数的语法，该语法可以采用固定数量的命名参数和可变数量的附加参数，这些参数被收集到命名列表中。

可变参数函数的参数声明是不正规的列表（improper list）：

|===
| | λ-syntax | Combined DEFINE
| 3 args | (LAMBDA (arg1 arg2 arg3) body...) | (DEFINE (name arg1 arg2 arg3) body...)
| ≥2 args | (LAMBDA (arg1 arg2 . rest) body...) | (DEFINE (name arg1 arg2 . rest) body...)
| ≥1 args | (LAMBDA (arg1 . rest) body...) | (DEFINE (name arg1 . rest) body...)
| ≥0 args | (LAMBDA args body...) | (DEFINE (name . args) body...)
|===

在上面的定义中，参数的绑定如下：

[cols="^1,^2a"]
|===
| 定义 |

[cols="^1"]
!===
! (f a b c)
!===

!===
! Value of a ! Value of b ! Value of c
!===

| (DEFINE (f a b c) body...) |

!===
! 1 ! 2 ! 3
!===

| (DEFINE (f a b . c) body...) |

!===
! 1 ! 2 ! (3)
!===

| (DEFINE (f . a) body...) |

!===
! 1 ! (2 3) !
!===


| (DEFINE (f . a) body...) |

!===
! (1 2 3) ! !
!===

|===

=== 实现

所需要做的只是对make_closure进行一个小的修改以接受该声明：

[source,c]
----
int make_closure(Atom env, Atom args, Atom body, Atom *result)
{
    Atom p;

    if (!listp(body))
        return Error_Syntax;

    /* Check argument names are all symbols */
    p = args;
    while (!nilp(p)) {
        if (p.type == AtomType_Symbol)
            break;
        else if (p.type != AtomType_Pair
                || car(p).type != AtomType_Symbol)
            return Error_Type;
        p = cdr(p);
    }

    *result = cons(env, cons(args, body));
    result->type = AtomType_Closure;

    return Error_OK;
}
----

另一个适用于将其他参数绑定到列表中的方法：

[source,c]
----
int apply(Atom fn, Atom args, Atom *result)
{
    .
    .
    .
    /* Bind the arguments */
    while (!nilp(arg_names)) {
        if (arg_names.type == AtomType_Symbol) {
            env_set(env, arg_names, args);
            args = nil;
            break;
        }

        if (nilp(args))
            return Error_Args;
        env_set(env, car(arg_names), car(args));
        arg_names = cdr(arg_names);
        args = cdr(args);
    }
    if (!nilp(args))
        return Error_Args;
    .
    .
    .
}
----

=== 测试

一个繁琐的例子

[source,text]
----
> ((lambda (a . b) a) 1 2 3)
1
> ((lambda (a . b) b) 1 2 3)
(2 3)
> ((lambda args args) 1 2 3)
(1 2 3)
----

我们可以创建一个变长参数的累加器：

[source,text]
----
> (define (sum-list xs)
    (if xs
        (+ (car xs) (sum-list (cdr xs)))
        0))
SUM-LIST
> (sum-list '(1 2 3))
6
> (define (add . xs) (sum-list xs))
ADD
> (add 1 2 3)
6
> (add 1 (- 4 2) (/ 9 3))
6
----

由于始终可以将列表传递给常规函数，因此这实际上只是另一种语法糖。

== 第十一章：宏

宏允许我们在运行时创建新的特殊形式。与函数不同，不会对宏的参数进行求值。然后，对宏的函数体的求值结果进行求值。

注意：这些（基本上是）常见的LISP宏。Scheme具有不同的宏系统，该系统避免了由宏引入的标识符的问题，但更为复杂。

我们将使用以下语法定义宏：

[source,scheme]
----
(DEFMACRO (name arg...) body...)
----

这有点像我们定义函数时的DEFINE语法，但和Common LISP中的形式有点区别。

=== 例子

我们先来定义一个宏IGNORE

[source,scheme]
----
(DEFMACRO (IGNORE X)
  (CONS 'QUOTE
    (CONS X NIL)))
----

如果我们对以下表达式进行求值：

[source,scheme]
----
(IGNORE FOO)
----

由于FOO没有绑定存在，所以IGNORE的宏代码将会把参数X绑定到未求值的符号FOO。那么对嵌套的CONS表达式在这个环境中求值的结果如下：

[source,scheme]
----
(QUOTE . (FOO . NIL))
----

当然上面的表达式等价于

[source,scheme]
----
(QUOTE FOO)
----

最终，对上面的表达式进行求值（也就是对宏的代码进行求值的结果）就是：

[source,scheme]
----
FOO
----

=== 实现

我们将会定义一个新的 atom 类型：

[source,c]
----
AtomType_Macro
----

上面类型的值和AtomType_Closure是一样的，我们只需要告诉eval_expr如何对我们新的宏类型进行求值就好了。

[source,c]
----
int eval_expr(Atom expr, Atom env, Atom *result)
{
    .
    .
    .
    if (op.type == AtomType_Symbol) {
        if (strcmp(op.value.symbol, "QUOTE") == 0) {
        .
        .
        .
        } else if (strcmp(op.value.symbol, "DEFMACRO") == 0) {
            Atom name, macro;
            Error err;

            if (nilp(args) || nilp(cdr(args)))
                return Error_Args;

            if (car(args).type != AtomType_Pair)
                return Error_Syntax;

            name = car(car(args));
            if (name.type != AtomType_Symbol)
                return Error_Type;

            err = make_closure(env, cdr(car(args)),
                cdr(args), &macro);
            if (err)
                return err;

            macro.type = AtomType_Macro;
            *result = name;
            return env_set(env, name, macro);
        }
    }

    /* Evaluate operator */
    .
    .
    .

    /* Is it a macro? */
    if (op.type == AtomType_Macro) {
        Atom expansion;
        op.type = AtomType_Closure;
        err = apply(op, args, &expansion);
        if (err)
            return err;
        return eval_expr(expansion, env, result);
    }

    /* Evaulate arguments */
    .
    .
    .
}
----

=== 测试

[source,text]
----
> (defmacro (ignore x) (cons 'quote (cons x nil)))
IGNORE
> (ignore foo)
FOO
> foo
Symbol not bound
----

我们在后面将使用宏来定义一些新的特殊形式。

== 第十二章：库

现在，我们将为LISP系统创建一个有用的函数的小型库。让我们利用以下事实：我们可以利用较低级别的功能在LISP本身中实现许多LISP标准库，而不是为每个构建新的内建函数。

首先，我们需要一个函数来从磁盘读取库定义。

[source,c]
----
char *slurp(const char *path)
{
    FILE *file;
    char *buf;
    long len;

    file = fopen(path, "r");
    if (!file)
        return NULL;
    fseek(file, 0, SEEK_END);
    len = ftell(file);
    fseek(file, 0, SEEK_SET);

    buf = malloc(len + 1);
    if (!buf)
        return NULL;

    fread(buf, 1, len, file);
    buf[len] = 0;
    fclose(file);

    return buf;
}
----

还有一个类似于我们的REPL的例程，用于处理这些定义。因为我们一次性读取了整个文件，所以将定义拆分成几行是没有问题的。

[source,c]
----
void load_file(Atom env, const char *path)
{
    char *text;

    printf("Reading %s...\n", path);
    text = slurp(path);
    if (text) {
        const char *p = text;
        Atom expr;
        while (read_expr(p, &p, &expr) == Error_OK) {
            Atom result;
            Error err = eval_expr(expr, env, &result);
            if (err) {
                printf("Error in expression:\n\t");
                print_expr(expr);
                putchar('\n');
            } else {
                print_expr(result);
                putchar('\n');
            }
        }
        free(text);
    }
}
----

设置完内置函数后，最后在库中读取。

[source,c]
----
int main(int argc, char **argv)
{
    .
     .
    .

    /* Set up the initial environment */
    .
    .
    .

    load_file(env, "library.lisp");

    /* Main loop */
    .
    .
    .
}
----

=== 测试

使用下面的定义创建一个 `library.lisp` 文件：

[source,scheme]
----
(define (abs x) (if (< x 0) (- x) x))
----

运行解释器

[source,text]
----
Reading library.lisp...
ABS
> (abs -2)
2
----

`ABS` 函数现在在每一个lisp代码中都可以使用了，不需要每次都定义一遍。

=== fold

`foldl` 和 `foldr` 允许我们轻松的创建聚合列表的函数。

[source,scheme]
----
(define (foldl proc init list)
  (if list
      (foldl proc
             (proc init (car list))
             (cdr list))
      init))

(define (foldr proc init list)
  (if list
      (proc (car list)
            (foldr proc init (cdr list)))
      init))
----

看一下怎么用

[source,scheme]
----
(define (list . items)
  (foldr cons nil items))

(define (reverse list)
  (foldl (lambda (a x) (cons x a)) nil list))
----

==== 测试

[source,text]
----
> (list (+ 3 5) 'foo)
(8 FOO)
> (reverse '(1 2 3))
(3 2 1)
----

这比我们用C实现成内置函数要容易多了吧。

=== 更多内置函数

有一些原始函数需要访问系统的内部API。

==== apply

apply 函数

[source,scheme]
----
(APPLY fn arg-list)
----

将fn中的参数列表绑定到arg-list，然后执行fn的函数体。

[source,c]
----
int builtin_apply(Atom args, Atom *result)
{
    Atom fn;

    if (nilp(args) || nilp(cdr(args)) || !nilp(cdr(cdr(args))))
        return Error_Args;

    fn = car(args);
    args = car(cdr(args));

    if (!listp(args))
        return Error_Syntax;

    return apply(fn, args, result);
}
----

==== eq?

`eq?` 测试两个原子类型是不是同一个对象。

[source,c]
----
int builtin_eq(Atom args, Atom *result)
{
    Atom a, b;
    int eq;

    if (nilp(args) || nilp(cdr(args)) || !nilp(cdr(cdr(args))))
        return Error_Args;

    a = car(args);
    b = car(cdr(args));

    if (a.type == b.type) {
        switch (a.type) {
        case AtomType_Nil:
            eq = 1;
            break;
        case AtomType_Pair:
        case AtomType_Closure:
        case AtomType_Macro:
            eq = (a.value.pair == b.value.pair);
            break;
        case AtomType_Symbol:
            eq = (a.value.symbol == b.value.symbol);
            break;
        case AtomType_Integer:
            eq = (a.value.integer == b.value.integer);
            break;
        case AtomType_Builtin:
            eq = (a.value.builtin == b.value.builtin);
            break;
        }
    } else {
        eq = 0;
    }

    *result = eq ? make_sym("T") : nil;
    return Error_OK;
}
----

==== pair?

测试一个原子类型是不是 `pair` 。

[source,c]
----
int builtin_pairp(Atom args, Atom *result)
{
    if (nilp(args) || !nilp(cdr(args)))
        return Error_Args;

    *result = (car(args).type == AtomType_Pair) ? make_sym("T") : nil;
    return Error_OK;
}
----

别忘了将内置函数绑定到初始环境中。

[source,c]
----
env_set(env, make_sym("APPLY"), make_builtin(builtin_apply));
env_set(env, make_sym("EQ?"), make_builtin(builtin_eq));
env_set(env, make_sym("PAIR?"), make_builtin(builtin_pairp));
----

==== map

我们使用 `foldr` 和 `apply` 来实现另一个重要的函数 `map` ，也就是将列表中的每一个元素都一一对应的转换成另一种元素。

[source,scheme]
----
(define (unary-map proc list)
  (foldr (lambda (x rest) (cons (proc x) rest))
         nil
         list))

(define (map proc . arg-lists)
  (if (car arg-lists)
      (cons (apply proc (unary-map car arg-lists))
            (apply map (cons proc
                             (unary-map cdr arg-lists))))
      nil))
----

注意还有其他实现方式。

这样使用map：

[source,scheme]
----
> (map + '(1 2 3) '(4 5 6))
(5 7 9)
----

结果列表中包含的结果是：(+ 1 4)，(+ 2 5)和(+ 3 6)的求值结果。

== 第十三章：准引用(QUASIQUOTE)

QUASIQUOTE是QUOTE特殊形式的扩展，可以方便地编写宏。

对于符号和其他简单数据，QUASIQUOTE的行为类似于QUOTE，返回未经求值的数据结构。列表也将返回而不进行求值，但有两个例外。如果列表（或子列表）的元素具有 `(UNQUOTE expr)` 形式，则将求值expr，并将结果插入到列表中。 `(UNQUOTE-SPLICING expr)` 相似，但是求值expr的结果必须是一个列表，其项被拼接到父列表中。

=== 例子

[source,scheme]
----
(QUASIQUOTE (+ 1 (UNQUOTE (+ 2 3))))
----

将会求值为：

[source,scheme]
----
(+ 1 5)
----

If we define L to be the list (3 4 5) then

如果我们定义L为列表(3 4 5)，那么

[source,scheme]
----
(QUASIQUOTE (1 2 (UNQUOTE-SPLICING L)))
----

将会求值为：

[source,scheme]
----
(1 2 3 4 5)
----

=== 语法糖

就像QUOTE一样，我们可以定义下列缩写形式：

|===
| Abbreviation | Equivalent to
| `expr | (QUASIQUOTE expr)
| ,expr | (UNQUOTE expr)
| ,@expr | (UNQUOTE-SPLICING expr)
|===

将上面的例子用语法糖重写一下

[source,scheme]
----
`(+ 1 ,(+ 2 3))
----

以及

[source,scheme]
----
`(1 2 ,@L)
----

=== 实现

我们将扩展词法分析器来理解上面那些特殊的 `token` 。

[source,c]
----
int lex(const char *str, const char **start, const char **end)
{
    const char *ws = " \t\n";
    const char *delim = "() \t\n";
    const char *prefix = "()\'`";

    str += strspn(str, ws);

    if (str[0] == '\0') {
        *start = *end = NULL;
        return Error_Syntax;
    }

    *start = str;

    if (strchr(prefix, str[0]) != NULL)
        *end = str + 1;
    else if (str[0] == ',')
        *end = str + (str[1] == '@' ? 2 : 1);
    else
        *end = str + strcspn(str, delim);

    return Error_OK;
}
----

read_expr 需要扩展上面那些缩写形式，像对 QUOTE 那么扩展

[source,c]
----
int read_expr(const char *input, const char **end, Atom *result)
{
    .
    .
    .
    if (token[0] == '(') {
    .
    .
    .
    } else if (token[0] == '`') {
        *result = cons(make_sym("QUASIQUOTE"), cons(nil, nil));
        return read_expr(*end, end, &car(cdr(*result)));
    } else if (token[0] == ',') {
        *result = cons(make_sym(
            token[1] == '@' ? "UNQUOTE-SPLICING" : "UNQUOTE"),
            cons(nil, nil));
        return read_expr(*end, end, &car(cdr(*result)));
    } else {
        .
        .
        .
    }
}
----

QUASIQUOTE运算符可以定义为一个宏。我们先来定义一些辅助函数。

[source,scheme]
----
(define (append a b) (foldr cons b a))

(define (caar x) (car (car x)))

(define (cadr x) (car (cdr x)))
----

(append a b) 将列表a和b拼接在一起。宏如下定义：

[source,scheme]
----
(defmacro (quasiquote x)
  (if (pair? x)
      (if (eq? (car x) 'unquote)
          (cadr x)
          (if (eq? (caar x) 'unquote-splicing)
              (list 'append
                    (cadr (car x))
                    (list 'quasiquote (cdr x)))
              (list 'cons
                    (list 'quasiquote (car x))
                    (list 'quasiquote (cdr x)))))
      (list 'quote x)))
----

上面的宏定义有一些难理解，因为结果表达式也是用LIST构建的，并且也调用了其他的QUASIQUOTE。

Quasiquotation允许我们在写宏定义的函数体时看起来像这个宏返回的表达式一样。例如在十一章中写过的IGNORE宏

[source,scheme]
----
(DEFMACRO (IGNORE X)
  (CONS 'QUOTE (CONS X NIL)))
----

可以改写成

[source,scheme]
----
(DEFMACRO (IGNORE X)
  `(QUOTE ,X))
----

这样IGNORE看起来就好理解了。

==== 测试

[source,text]
----
> `(+ 1 ,(+ 2 3))
(+ 1 5)
> (define l '(3 4 5))
L
> `(1 2 ,@l)
(1 2 3 4 5)
----

=== let

我们现在使用QUASITUOTE来定义一种新的特殊形式：

[source,scheme]
----
(LET ((sym1 expr1)
      (sym2 expr2)
      ...)
  body...)
----

LET先对expr1求值，并绑定到sym1,再对expr2求值，并绑定到sym2,等等。然后将body的求值结果返回。定义很简单：

[source,scheme]
----
(defmacro (let defs . body)
  `((lambda ,(map car defs) ,@body)
    ,@(map cadr defs)))
----

==== 例子

当我们对下面的形式进行求值时：

[source,scheme]
----
(LET ((X 3) (Y 5)) (+ X Y))
----

它将会被LET宏转换成：

[source,scheme]
----
((LAMBDA (X Y) (+ X Y)) 3 5)
----

==== 测试

[source,text]
----
> (let ((x 3) (y 5)) (+ x y))
8
> x
Symbol not bound
----

LET表达式可以让我们定义临时变量。

=== 一个小技巧

我们可以使用LET来扩展内置运算符 `+` ，使得可以对任意数量的参数进行相加。

[source,scheme]
----
(define +
  (let ((old+ +))
    (lambda xs (foldl old+ 0 xs))))
----

将上面的定义和在第十章中定义的ADD对比一下。

==== 测试

[source,text]
----
> (+ 1 2 3 4)
10
----

我们甚至不需要触碰builtin_add函数或者重新编译解释器。

== 第十四章：延续和尾递归

延续 -> continuation

尾递归 -> tail recursion

我们的eval_expr函数是递归实现的——也就是说，当在求值表达式的过程中有必要求值子表达式时，eval_expr调用自身以获得结果。

这工作得很好，并且易于遵循，但是在我们的LISP环境中，递归的深度受到解释器堆栈大小的限制。传统上，LISP代码大量使用递归，因此我们希望在可用内存限制内支持此功能。

以以下不太好的递归示例为例：

[source,scheme]
----
(define (count n)
  (if (= n 0)
      0
      (+ 1 (count (- n 1)))))
----

COUNT函数将递归到深度n，并返回n的总和。诸如(COUNT 10)之类的表达式应使用我们当前的解释器计算确定，但即使(COUNT 10000)也足以导致我的计算机上的堆栈溢出。

为此，我们将eval_expr重写为一个循环，并使用辅助函数来跟踪进行中的求值并返回要求值的下一个表达式。如果没有更多的表达式了，eval_expr可以将最终结果返回给调用者。

当eval_expr在表达式树中工作时，我们将在一系列帧（链接在一起形成一个堆栈）中跟踪已求值的参数和待求值的参数。这与以递归方式编写的eval_expr的版本的工作方式大致相同；在这种情况下，我们将使用LISP数据结构替换机器代码堆栈，并对其进行显式操作。

一旦计算了当前表达式，堆栈也可以被认为代表了计算的未来。从这个意义上讲，它被称为当前延续。

由于eval_expr调用的任何函数都不能调用eval_expr（以避免递归），因此我们必须将apply和buildin_apply集成到eval_expr的函数体中。

=== 实现

一个栈帧拥有以下形式：

[source,scheme]
----
(parent env evaluated-op (pending-arg...) (evaluated-arg...) (body...))
----

`parent` 是与父表达式（即正在等待当前表达式的结果的表达式）相对应的堆栈帧。 `env` 是当前环境， `evaluated-op` 是求值的运算符， `pending-arg...` 和 `evaluated-arg...` 分别是未决和后续求值的参数。 `body...` 是函数体中待执行的表达式。

与其写出包含很多的 `car()` 和 `cdr()` 的代码，我们不如定义一些辅助函数来操纵列表中的成员。

[source,c]
----
Atom list_get(Atom list, int k)
{
    while (k--)
        list = cdr(list);
    return car(list);
}

void list_set(Atom list, int k, Atom value)
{
    while (k--)
        list = cdr(list);
    car(list) = value;
}

void list_reverse(Atom *list)
{
    Atom tail = nil;
    while (!nilp(*list)) {
        Atom p = cdr(*list);
        cdr(*list) = tail;
        tail = *list;
        *list = p;
    }
    *list = tail;
}
----

另一个函数用来创建一个新的栈帧，来对新的函数调用求值。这个新的函数有特定的parent，环境，以及一个将要求值的参数列表（tail）。

[source,c]
----
Atom make_frame(Atom parent, Atom env, Atom tail)
{
    return cons(parent,
        cons(env,
        cons(nil, /* op */
        cons(tail,
        cons(nil, /* args */
        cons(nil, /* body */
        nil))))));
}
----

下面是我们新的 `exec_expr` 函数中最核心的部分。这个函数将 expr 设置到了函数体的下一个部分中，然后当我们到达函数体的最后时，将栈弹出。

[source,c]
----
int eval_do_exec(Atom *stack, Atom *expr, Atom *env)
{
    Atom body;

    *env = list_get(*stack, 1);
    body = list_get(*stack, 5);
    *expr = car(body);
    body = cdr(body);
    if (nilp(body)) {
        /* Finished function; pop the stack */
        *stack = car(*stack);
    } else {
        list_set(*stack, 5, body);
    }

    return Error_OK;
}
----

这个辅助函数将函数的参数绑定到一个新的环境中，前提是这些参数没有被绑定过。然后调用 `eval_do_exec` 方法获取函数体中的下一个表达式。

[source,c]
----
int eval_do_bind(Atom *stack, Atom *expr, Atom *env)
{
    Atom op, args, arg_names, body;

    body = list_get(*stack, 5);
    if (!nilp(body))
        return eval_do_exec(stack, expr, env);

    op = list_get(*stack, 2);
    args = list_get(*stack, 4);

    *env = env_create(car(op));
    arg_names = car(cdr(op));
    body = cdr(cdr(op));
    list_set(*stack, 1, *env);
    list_set(*stack, 5, body);

    /* Bind the arguments */
    while (!nilp(arg_names)) {
        if (arg_names.type == AtomType_Symbol) {
            env_set(*env, arg_names, args);
            args = nil;
            break;
        }

        if (nilp(args))
            return Error_Args;
        env_set(*env, car(arg_names), car(args));
        arg_names = cdr(arg_names);
        args = cdr(args);
    }
    if (!nilp(args))
        return Error_Args;

    list_set(*stack, 4, nil);

    return eval_do_exec(stack, expr, env);
}
----

一旦参数都被求值以后，下一个函数将被调用。下一个函数负责要么产生一个调用内置函数的表达式，要么代理到 `eval_do_bind` 函数。

[source,c]
----
int eval_do_apply(Atom *stack, Atom *expr, Atom *env, Atom *result)
{
    Atom op, args;

    op = list_get(*stack, 2);
    args = list_get(*stack, 4);

    if (!nilp(args)) {
        list_reverse(&args);
        list_set(*stack, 4, args);
    }

    if (op.type == AtomType_Symbol) {
        if (strcmp(op.value.symbol, "APPLY") == 0) {
            /* Replace the current frame */
            *stack = car(*stack);
            *stack = make_frame(*stack, *env, nil);
            op = car(args);
            args = car(cdr(args));
            if (!listp(args))
                return Error_Syntax;

            list_set(*stack, 2, op);
            list_set(*stack, 4, args);
        }
    }

    if (op.type == AtomType_Builtin) {
        *stack = car(*stack);
        *expr = cons(op, args);
        return Error_OK;
    } else if (op.type != AtomType_Closure) {
        return Error_Type;
    }

    return eval_do_bind(stack, expr, env);
}
----

这个部分将会在一个表达式求值以后就调用。它负责存储结果。这个结果可能是一个运算符，一个参数，或者一个中间函数体表达式，然后获取下一个将要求值的表达式。

[source,c]
----
int eval_do_return(Atom *stack, Atom *expr, Atom *env, Atom *result)
{
    Atom op, args, body;

    *env = list_get(*stack, 1);
    op = list_get(*stack, 2);
    body = list_get(*stack, 5);

    if (!nilp(body)) {
        /* Still running a procedure; ignore the result */
        return eval_do_apply(stack, expr, env, result);
    }

    if (nilp(op)) {
        /* Finished evaluating operator */
        op = *result;
        list_set(*stack, 2, op);

        if (op.type == AtomType_Macro) {
            /* Don't evaluate macro arguments */
            args = list_get(*stack, 3);
            *stack = make_frame(*stack, *env, nil);
            op.type = AtomType_Closure;
            list_set(*stack, 2, op);
            list_set(*stack, 4, args);
            return eval_do_bind(stack, expr, env);
        }
    } else if (op.type == AtomType_Symbol) {
        /* Finished working on special form */
        if (strcmp(op.value.symbol, "DEFINE") == 0) {
            Atom sym = list_get(*stack, 4);
            (void) env_set(*env, sym, *result);
            *stack = car(*stack);
            *expr = cons(make_sym("QUOTE"), cons(sym, nil));
            return Error_OK;
        } else if (strcmp(op.value.symbol, "IF") == 0) {
            args = list_get(*stack, 3);
            *expr = nilp(*result) ? car(cdr(args)) : car(args);
            *stack = car(*stack);
            return Error_OK;
        } else {
            goto store_arg;
        }
    } else if (op.type == AtomType_Macro) {
        /* Finished evaluating macro */
        *expr = *result;
        *stack = car(*stack);
        return Error_OK;
    } else {
    store_arg:
        /* Store evaluated argument */
        args = list_get(*stack, 4);
        list_set(*stack, 4, cons(*result, args));
    }

    args = list_get(*stack, 3);
    if (nilp(args)) {
        /* No more arguments left to evaluate */
        return eval_do_apply(stack, expr, env, result);
    }

    /* Evaluate next argument */
    *expr = car(args);
    list_set(*stack, 3, cdr(args));
    return Error_OK;
}
----

最后来到了我们新的 `eval_expr` 。有很多代码来构建特殊形式，剩下的就仅仅是一个循环，负责等待栈被清空。

[source,c]
----
int eval_expr(Atom expr, Atom env, Atom *result)
{
    Error err = Error_OK;
    Atom stack = nil;

    do {
        if (expr.type == AtomType_Symbol) {
            err = env_get(env, expr, result);
        } else if (expr.type != AtomType_Pair) {
            *result = expr;
        } else if (!listp(expr)) {
            return Error_Syntax;
        } else {
            Atom op = car(expr);
            Atom args = cdr(expr);

            if (op.type == AtomType_Symbol) {
                /* Handle special forms */

                if (strcmp(op.value.symbol, "QUOTE") == 0) {
                    if (nilp(args) || !nilp(cdr(args)))
                        return Error_Args;

                    *result = car(args);
                } else if (strcmp(op.value.symbol, "DEFINE") == 0) {
                    Atom sym;

                    if (nilp(args) || nilp(cdr(args)))
                        return Error_Args;

                    sym = car(args);
                    if (sym.type == AtomType_Pair) {
                        err = make_closure(env, cdr(sym), cdr(args), result);
                        sym = car(sym);
                        if (sym.type != AtomType_Symbol)
                            return Error_Type;
                        (void) env_set(env, sym, *result);
                        *result = sym;
                    } else if (sym.type == AtomType_Symbol) {
                        if (!nilp(cdr(cdr(args))))
                            return Error_Args;
                        stack = make_frame(stack, env, nil);
                        list_set(stack, 2, op);
                        list_set(stack, 4, sym);
                        expr = car(cdr(args));
                        continue;
                    } else {
                        return Error_Type;
                    }
                } else if (strcmp(op.value.symbol, "LAMBDA") == 0) {
                    if (nilp(args) || nilp(cdr(args)))
                        return Error_Args;

                    err = make_closure(env, car(args), cdr(args), result);
                } else if (strcmp(op.value.symbol, "IF") == 0) {
                    if (nilp(args) || nilp(cdr(args)) || nilp(cdr(cdr(args)))
                            || !nilp(cdr(cdr(cdr(args)))))
                        return Error_Args;

                    stack = make_frame(stack, env, cdr(args));
                    list_set(stack, 2, op);
                    expr = car(args);
                    continue;
                } else if (strcmp(op.value.symbol, "DEFMACRO") == 0) {
                    Atom name, macro;

                    if (nilp(args) || nilp(cdr(args)))
                        return Error_Args;

                    if (car(args).type != AtomType_Pair)
                        return Error_Syntax;

                    name = car(car(args));
                    if (name.type != AtomType_Symbol)
                        return Error_Type;

                    err = make_closure(env, cdr(car(args)),
                        cdr(args), &macro);
                    if (!err) {
                        macro.type = AtomType_Macro;
                        *result = name;
                        (void) env_set(env, name, macro);
                    }
                } else if (strcmp(op.value.symbol, "APPLY") == 0) {
                    if (nilp(args) || nilp(cdr(args)) || !nilp(cdr(cdr(args))))
                        return Error_Args;

                    stack = make_frame(stack, env, cdr(args));
                    list_set(stack, 2, op);
                    expr = car(args);
                    continue;
                } else {
                    goto push;
                }
            } else if (op.type == AtomType_Builtin) {
                err = (*op.value.builtin)(args, result);
            } else {
            push:
                /* Handle function application */
                stack = make_frame(stack, env, args);
                expr = op;
                continue;
            }
        }

        if (nilp(stack))
            break;

        if (!err)
            err = eval_do_return(&stack, &expr, &env, result);
    } while (!err);

    return err;
}
----

==== 测试

让我们再来试一下之前的COUNT函数。

[source,text]
----
> (count 100000)
100000
----

万岁！现在，我们可以根据需要进行尽可能多的递归操作，而不会引起堆栈溢出。如果有大量的RAM，那么甚至应该能够完成一百万个级别的深度。

=== 尾递归

如果函数中的最后一个表达式是对另一个函数的调用，则结果可以直接返回给第一个函数的调用者。这被称为尾调用。如果被调用的函数通过一系列的尾调用导致第一个函数被调用，则我们具有尾递归。

尾调用不需要保留调用者的栈帧，因此尾递归函数可以在不增加堆栈深度的情况下递归所需的多个级别。

可以将count函数表示为尾递归过程，如下所示：

[source,scheme]
----
(define (count n a)
  (if (= n 0)
      a
      (count (- n 1) (+ a 1))))

(count 100000 0)
----

如果使用调试器观看eval_expr，则可以确认堆栈从不超过几层。

剩下要做的就是清理新求值程序创建的所有临时对象。

== 第十五章：垃圾收集

垃圾收集 -> Garbage collection

我们将实现一个非常简单的标记——清除垃圾收集器。这不是要在实际应用程序中使用的东西，但可以满足我们的目的。

请记住，我们所有的LISP数据都是通过cons函数分配的。首先，我们对其进行修改以跟踪链表中的每个分配。

[source,c]
----
struct Allocation {
    struct Pair pair;
    int mark : 1;
    struct Allocation *next;
};

struct Allocation *global_allocations = NULL;

Atom cons(Atom car_val, Atom cdr_val)
{
    struct Allocation *a;
    Atom p;

    a = malloc(sizeof(struct Allocation));
    a->mark = 0;
    a->next = global_allocations;
    global_allocations = a;

    p.type = AtomType_Pair;
    p.value.pair = &a->pair;

    car(p) = car_val;
    cdr(p) = cdr_val;

    return p;
}
----

下面的函数将整个树的 `pair` 标记为 `in user` 。

[source,c]
----
void gc_mark(Atom root)
{
    struct Allocation *a;

    if (!(root.type == AtomType_Pair
        || root.type == AtomType_Closure
        || root.type == AtomType_Macro))
        return;

    a = (struct Allocation *)
        ((char *) root.value.pair
            - offsetof(struct Allocation, pair));

    if (a->mark)
        return;

    a->mark = 1;

    gc_mark(car(root));
    gc_mark(cdr(root));
}
----

垃圾收集器将释放所有未标记的内容，然后清除这些标记，以备下次运行。我们也标记符号表，因为这些符号表是由静态变量引用的。

[source,c]
----
void gc()
{
    struct Allocation *a, **p;

    gc_mark(sym_table);

    /* Free unmarked allocations */
    p = &global_allocations;
    while (*p != NULL) {
        a = *p;
        if (!a->mark) {
            *p = a->next;
            free(a);
        } else {
            p = &a->next;
        }
    }

    /* Clear marks */
    a = global_allocations;
    while (a != NULL) {
        a->mark = 0;
        a = a->next;
    }
}
----

为了避免在深度递归下耗尽内存，我们需要在eval_expr的每几次迭代中调用一次垃圾收集器。该时间间隔将大致确定在垃圾回收之间进行多少内存的分配。

[source,c]
----
int eval_expr(Atom expr, Atom env, Atom *result)
{
    static int count = 0;
    Error err = Error_OK;
    Atom stack = nil;

    do {
        if (++count == 100000) {
            gc_mark(expr);
            gc_mark(env);
            gc_mark(stack);
            gc();
            count = 0;
        }

    .
    .
    .
}
----

=== 测试

来看一下之前写的COUNT的例子：

[source,text]
----
> (define (count n) (if (= n 0) t (count (- n 1))))
COUNT
> (count 1000000)
T
----

瞧！操作完成而不会耗尽我们的所有RAM。

== 第十六章：接下来做什么？

该项目的目的是演示LISP的轻松实现。优化或不经意地实现库函数没有多大意义——这项工作已经在其他项目中完成。

以下是一些可能有趣的扩展：

* 使用 `call/cc` 关键字将延续暴露出来
* 其他数值类型 (float, rational, bignum, complex)
* 字符串、向量和布尔类型
* I/O支持
* 调用系统库
* 即时编译(JIT)
* Slab allocation
* 可配置GC

现在是时候停止在C语言中搞乱了，而是在LISP中构建东西了！
