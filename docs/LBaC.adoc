= 构建一个编译器
:icons: font
:source-highlighter: pygments
:toc: left
:toclevels: 4
:sectnums:

== 简介

这个系列的文章是一个开发语言的语法分析器和编译器的教程。在我们完成编译器之前，我们将会覆盖构建编译器的每一方面的知识：设计一门新的编程语言，然后构建一个可以工作的编译器。

尽管我不是一个科班出身的计算机科学家（我的博士学位是物理学方面的），我对编译器却已经感兴趣很多年了。我购买了编译器方面的所有书籍并尝试着消化所有的内容。我不介意告诉你这个消化的过程非常的缓慢。编译器方面的书都是写给计算机专业的学生的，而对于我们这些业余爱好者则读起来非常的困难。但经过了很多年的消化，我终于开始学到一点东西了。改变发生于我开始自己鼓捣自己的编译器。现在我决定和你们分享一下我所学到的东西。当这个教程的系列结束时，你当然不可能成为一个计算机科学家，你也不可能学到所有有关编译器的知识。因为我想做的就是忽略掉所有编译器的理论。而你所能学到的就是构建一个可以工作的编译器所需要的方方面面的有关实践的知识。

所以这是一个边做边学的教程。在这一系列教程中，我将会不断的写程序做实验。你最好跟上我的脚步，把我写过的代码自己也写一遍，最好也能添加一些你自己写的代码。我将使用Turbo Pascal 4.0编译器。我将在TP中不断的编写代码。这些代码都是可以执行的代码，可能你会想把这些代码粘贴到你的电脑上然后运行。如果你没有一份Turbo Pascal的拷贝，那么可能会影响你写代码的进程。你最好搞一份拷贝。毕竟，这是一个伟大的产品，能用在很多的地方。

一些有关编译器的文章会包含一些示例代码，或者包含一个完整的编译器代码（例如Small-C编译器），然后你可以拷贝代码然后运行，但无法理解整个代码是如何工作的。我希望做的比那些文章多一些。我希望能教给你如何搞定这些东西，然后你就可以自己搞定这一切，甚至可以鼓捣自己的编译器，或者改进我写的编译器，而不只是重复一遍我的工作。

毫无疑问写一个编译器是一个很有野心的工作，所以不可能一页纸就搞定。我希望在一系列的文章中把这些工作搞定。每一篇文章将会覆盖编译器的某个单独的主题，这些主题独立性很强。如果你某个时间段只对某个主题感兴趣，那你只需要看那个主题的文章就可以了。每篇文章都比较完整，所以在最终完成之前，你只需要等待最新的文章就可以了。所以请耐心。

我的系列教程将不会讲解编译器理论涉及到的很多的方面。正统的编译器课本会遵循以下教学过程：

* 一个介绍性的章节，用来介绍什么是编译器。
* 一个或者两个章节，用来介绍编程语法方面的东西，使用巴科斯-诺尔范式（Backus-Naur Form，BNF）。
* 一个或者两个章节，用来介绍词法分析。重点讲解确定性和非确定性有限自动机。
* 多个章节。用来介绍语法分析理论，从自顶向下递归下降语法分析开始，到LALR语法分析器结束。
* 一个章节，用来介绍中间语言。重点介绍P-code，以及相似的逆波兰表示形式。
* 多个章节。用来介绍处理子程序、传递参数和类型声明的多种方式。
* 一个章节。用来介绍代码生成。通常针对一个拥有简单指令集的虚拟CPU生成代码。大部分读者（事实上，大部分大学的课程）都不会走到这么远。
* 最后的一个或者两个章节。用来介绍优化。读者通常也不会走到这一章。

在我的系列教程中，我将会走一条很不同的路线。我不会给你很多的技术选项，我只会给你一条路。如果你想探索编译器技术各阶段的各种实现技术，好吧，我会鼓励你这么做，但我只会教你我会的那一条路。我也会跳过很多会让人昏昏欲睡的理论知识。别误解我：我并不是鄙视理论，只是当我们去探索一门给定的编程语言的充满各种奇技淫巧的实现时，才会需要理论。但我一直坚信，我们先得把最终要的事情搞定。在教程中，我们将会搞定95%的编译器方面的技术，而这些是不需要那么多理论就能搞定的。

我将会只讨论一种语法分析技术：自顶向下递归下降语法分析器。这个技术是手工打造一个编译器所能使用的唯一的一种技术。如果使用其他方法实现语法分析器，那你就必须使用工具了，例如YACC。而且使用工具的话，我们无法控制最终的编译器会消耗多少内存。

我也借鉴了Ron Cain写的书的部分内容，他是Small C的作者。很多编译器的作者都会使用一种中间语言（例如P-code），也就是将编译器分割成两部分（一个是编译器的前端，用来将代码编译成P-code，一个是编译器的后端，用来将P-code编译成目标机器的指令集代码）。Ron给我们展示了一种方法，那就是我们可以直接将代码编译成目标机器的可执行代码（也就是目标机器的汇编语言程序）。当然编译成的汇编语言代码肯定不是最紧凑的代码，因为编译出紧凑的代码，也就是优化是一个很难的工作。但编译出来的汇编代码是可以工作的，这就够了。当然我也不想让你们觉得我们写的编译器是毫无价值的，所以我会告诉你一些优化的方法。

最后，我会在教程中使用一些技巧，来帮助我们理解编译器的构造过程。这里面我使用的最主要的技巧就是单字符token（token里没有空格）的使用。因为我发现一旦我能够写出一个识别I-T-L这些token的语法分析器，那么写一个识别IF-THEN-ELSE的语法分析器就很简单了。在第二课中，我会向你展示如何编写一个语法分析器来识别任意长度的token。还有一个技巧，就是我会忽略掉文件I/O，因为我发现如果我能够处理来自键盘的输入以及将结果输出到屏幕上，我就可以处理来自硬盘的文件读写。经验表明，如果一个翻译器可以正常工作，那么将翻译器和文件I/O连接起来将会很简单。最后一个技巧就是，我不会去做错误处理和错误恢复方面的工作。我们编写的程序将会识别错误，但不会崩溃，而是直接停止运行，停止的位置是编译器发现的第一个错误，就像Turbo Pascal做的那样。你也可以发明一些其他的技巧。这些技巧不会出现在编译器的课本里，但他们很好使。

有关编程风格和效率的一点补充。就像你看到的那样，我写代码倾向于写非常小而且容易理解的代码片段。我所写的代码不会超过15到20行。我是KISS（keep it simple，sidney）的忠实信徒。所以当简单的代码能搞定时，我不会写技巧性很强或者很复杂的代码。这样写代码或许效率不够高？或许吧，但你会喜欢这样的风格的。就像Brian Kernighan所说的那样，先把代码跑起来，再去让代码跑的更快。如果后面你再想去优化之前所写的代码，你可以这样去做，因为之前写的代码很容易理解。如果你要这样做，那么最好在代码都能跑起来时，再去这样做。

我写代码还有一个倾向就是直到我需要时，我才会去构建一个模块。想要预测未来碰到的所有的情况，会把人逼疯，而且很容易出错。在现在这个充满了好用的编辑器和快速的编译器的时代，如果需要，我会毫不犹豫的重构一个模块。到那时候，我可能才会写出我真正想要的代码。

最后一点：我们这里所遵循的原则是不和P-code以及虚拟CPU指令集搞在一起。当我们写完第一天的代码，我们的代码就可以产生可执行的汇编代码。不过你可能并不喜欢我这里选择的汇编语言：68000汇编语言。我电脑运行的就是这种汇编语言。但是你会发现，将我们的代码修改成能够编译出80x86汇编语言代码的程序，也是很容易的，所以我不觉得这是一个问题。实际上，我很希望某个熟悉8086汇编语言的朋友能够写一份和我的代码所对应的编译器。因为这正是我们所需要的。

摇篮代码

每一个程序都有一些固定的写法...I/O的处理，错误信息的处理等等。我们要写的程序也不例外。我会尽可能将这些样板代码浓缩到最小，这样我们可以集中精力写最重要的部分，而不是迷失在样板代码中。下面的代码就是我们要写出的一些样板代码。包括I/O程序，错误处理程序，一个骨架程序和主程序。我把这些程序叫做我们的摇篮（cradle）。当我们编写其他程序时，会把它们添加到摇篮里面，然后添加一些对这些程序的调用程序。拷贝一份摇篮程序吧，因为我们会在多处使用这些代码。

有很多种方法来组织一个语法分析器的扫描活动。在Unix系统中，人们倾向于使用getc方法和ungetc方法来读取和回退字符。我这里使用的方法是，用一个单独的全局变量来记录向前看到的一个字符。初始化的部分（唯一的一个初始化部分）读取输入流中的第一个字符。我们没有用到Turbo 4.0的任何的特殊的技术。每个接下来的GetChar方法的调用，都将读取输入流中的下一个字符。

[source,pascal]
----
program Cradle;

{ 声明常量 }

const TAB = ^I;

{ 声明变量 }

var Look: char;              { 向前看字符 }
                              
{ 从输入流中读取新的字符 }

procedure GetChar;
begin
   Read(Look);
end;

{ 打印错误信息 }

procedure Error(s: string);
begin
   WriteLn;
   WriteLn(^G, 'Error: ', s, '.');
end;

{ 打印错误信息然后将程序挂起 }

procedure Abort(s: string);
begin
   Error(s);
   Halt;
end;

{ 打印预期看到的信息 }

procedure Expected(s: string);
begin
   Abort(s + ' Expected');
end;

{ 匹配一个特定的输入字符 }

procedure Match(x: char);
begin
   if Look = x then GetChar
   else Expected('''' + x + '''');
end;

{ 识别一个字母 }

function IsAlpha(c: char): boolean;
begin
   IsAlpha := upcase(c) in ['A'..'Z'];
end;

{ 识别一个十进制数字 }

function IsDigit(c: char): boolean;
begin
   IsDigit := c in ['0'..'9'];
end;

{ 获取一个标识符 }

function GetName: char;
begin
   if not IsAlpha(Look) then Expected('Name');
   GetName := UpCase(Look);
   GetChar;
end;

{ 获取一个数值 }

function GetNum: char;
begin
   if not IsDigit(Look) then Expected('Integer');
   GetNum := Look;
   GetChar;
end;

{ 输出一个带有制表符TAB的字符串 }

procedure Emit(s: string);
begin
   Write(TAB, s);
end;

{ 输出带有制表符TAB和CRLF字符的字符串 }

procedure EmitLn(s: string);
begin
   Emit(s);
   WriteLn;
end;

{ 初始化 }

procedure Init;
begin
   GetChar;
end;

{ 主程序 }

begin
   Init;
end.
----

简介结束了。将上面的代码拷贝到TP中，然后编译它们。要保证编译能够通过然后正确的运行起来。接下来我们将要开始第一课，也就是表达式的语法分析。