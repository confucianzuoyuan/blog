= 构建一个编译器
:icons: font
:source-highlighter: pygments
:toc: left
:toclevels: 4
:sectnums:

== 简介

这个系列的文章是一个开发语言的语法分析器和编译器的教程。在我们完成编译器之前，我们将会覆盖构建编译器的每一方面的知识：设计一门新的编程语言，然后构建一个可以工作的编译器。

尽管我不是一个科班出身的计算机科学家（我的博士学位是物理学方面的），我对编译器却已经感兴趣很多年了。我购买了编译器方面的所有书籍并尝试着消化所有的内容。我不介意告诉你这个消化的过程非常的缓慢。编译器方面的书都是写给计算机专业的学生的，而对于我们这些业余爱好者则读起来非常的困难。但经过了很多年的消化，我终于开始学到一点东西了。改变发生于我开始自己鼓捣自己的编译器。现在我决定和你们分享一下我所学到的东西。当这个教程的系列结束时，你当然不可能成为一个计算机科学家，你也不可能学到所有有关编译器的知识。因为我想做的就是忽略掉所有编译器的理论。而你所能学到的就是构建一个可以工作的编译器所需要的方方面面的有关实践的知识。

所以这是一个边做边学的教程。在这一系列教程中，我将会不断的写程序做实验。你最好跟上我的脚步，把我写过的代码自己也写一遍，最好也能添加一些你自己写的代码。我将使用Turbo Pascal 4.0编译器。我将在TP中不断的编写代码。这些代码都是可以执行的代码，可能你会想把这些代码粘贴到你的电脑上然后运行。如果你没有一份Turbo Pascal的拷贝，那么可能会影响你写代码的进程。你最好搞一份拷贝。毕竟，这是一个伟大的产品，能用在很多的地方。

一些有关编译器的文章会包含一些示例代码，或者包含一个完整的编译器代码（例如Small-C编译器），然后你可以拷贝代码然后运行，但无法理解整个代码是如何工作的。我希望做的比那些文章多一些。我希望能教给你如何搞定这些东西，然后你就可以自己搞定这一切，甚至可以鼓捣自己的编译器，或者改进我写的编译器，而不只是重复一遍我的工作。

毫无疑问写一个编译器是一个很有野心的工作，所以不可能一页纸就搞定。我希望在一系列的文章中把这些工作搞定。每一篇文章将会覆盖编译器的某个单独的主题，这些主题独立性很强。如果你某个时间段只对某个主题感兴趣，那你只需要看那个主题的文章就可以了。每篇文章都比较完整，所以在最终完成之前，你只需要等待最新的文章就可以了。所以请耐心。

我的系列教程将不会讲解编译器理论涉及到的很多的方面。正统的编译器课本会遵循以下教学过程：

* 一个介绍性的章节，用来介绍什么是编译器。
* 一个或者两个章节，用来介绍编程语法方面的东西，使用巴科斯-诺尔范式（Backus-Naur Form，BNF）。
* 一个或者两个章节，用来介绍词法分析。重点讲解确定性和非确定性有限自动机。
* 多个章节。用来介绍语法分析理论，从自顶向下递归下降语法分析开始，到LALR语法分析器结束。
* 一个章节，用来介绍中间语言。重点介绍P-code，以及相似的逆波兰表示形式。
* 多个章节。用来介绍处理子程序、传递参数和类型声明的多种方式。
* 一个章节。用来介绍代码生成。通常针对一个拥有简单指令集的虚拟CPU生成代码。大部分读者（事实上，大部分大学的课程）都不会走到这么远。
* 最后的一个或者两个章节。用来介绍优化。读者通常也不会走到这一章。

在我的系列教程中，我将会走一条很不同的路线。我不会给你很多的技术选项，我只会给你一条路。如果你想探索编译器技术各阶段的各种实现技术，好吧，我会鼓励你这么做，但我只会教你我会的那一条路。我也会跳过很多会让人昏昏欲睡的理论知识。别误解我：我并不是鄙视理论，只是当我们去探索一门给定的编程语言的充满各种奇技淫巧的实现时，才会需要理论。但我一直坚信，我们先得把最终要的事情搞定。在教程中，我们将会搞定95%的编译器方面的技术，而这些是不需要那么多理论就能搞定的。

我将会只讨论一种语法分析技术：自顶向下递归下降语法分析器。这个技术是手工打造一个编译器所能使用的唯一的一种技术。如果使用其他方法实现语法分析器，那你就必须使用工具了，例如YACC。而且使用工具的话，我们无法控制最终的编译器会消耗多少内存。

我也借鉴了Ron Cain写的书的部分内容，他是Small C的作者。很多编译器的作者都会使用一种中间语言（例如P-code），也就是将编译器分割成两部分（一个是编译器的前端，用来将代码编译成P-code，一个是编译器的后端，用来将P-code编译成目标机器的指令集代码）。Ron给我们展示了一种方法，那就是我们可以直接将代码编译成目标机器的可执行代码（也就是目标机器的汇编语言程序）。当然编译成的汇编语言代码肯定不是最紧凑的代码，因为编译出紧凑的代码，也就是优化是一个很难的工作。但编译出来的汇编代码是可以工作的，这就够了。当然我也不想让你们觉得我们写的编译器是毫无价值的，所以我会告诉你一些优化的方法。

最后，我会在教程中使用一些技巧，来帮助我们理解编译器的构造过程。这里面我使用的最主要的技巧就是单字符token（token里没有空格）的使用。因为我发现一旦我能够写出一个识别I-T-L这些token的语法分析器，那么写一个识别IF-THEN-ELSE的语法分析器就很简单了。在第二课中，我会向你展示如何编写一个语法分析器来识别任意长度的token。还有一个技巧，就是我会忽略掉文件I/O，因为我发现如果我能够处理来自键盘的输入以及将结果输出到屏幕上，我就可以处理来自硬盘的文件读写。经验表明，如果一个翻译器可以正常工作，那么将翻译器和文件I/O连接起来将会很简单。最后一个技巧就是，我不会去做错误处理和错误恢复方面的工作。我们编写的程序将会识别错误，但不会崩溃，而是直接停止运行，停止的位置是编译器发现的第一个错误，就像Turbo Pascal做的那样。你也可以发明一些其他的技巧。这些技巧不会出现在编译器的课本里，但他们很好使。

有关编程风格和效率的一点补充。就像你看到的那样，我写代码倾向于写非常小而且容易理解的代码片段。我所写的代码不会超过15到20行。我是KISS（keep it simple，sidney）的忠实信徒。所以当简单的代码能搞定时，我不会写技巧性很强或者很复杂的代码。这样写代码或许效率不够高？或许吧，但你会喜欢这样的风格的。就像Brian Kernighan所说的那样，先把代码跑起来，再去让代码跑的更快。如果后面你再想去优化之前所写的代码，你可以这样去做，因为之前写的代码很容易理解。如果你要这样做，那么最好在代码都能跑起来时，再去这样做。

我写代码还有一个倾向就是直到我需要时，我才会去构建一个模块。想要预测未来碰到的所有的情况，会把人逼疯，而且很容易出错。在现在这个充满了好用的编辑器和快速的编译器的时代，如果需要，我会毫不犹豫的重构一个模块。到那时候，我可能才会写出我真正想要的代码。

最后一点：我们这里所遵循的原则是不和P-code以及虚拟CPU指令集搞在一起。当我们写完第一天的代码，我们的代码就可以产生可执行的汇编代码。不过你可能并不喜欢我这里选择的汇编语言：68000汇编语言。我电脑运行的就是这种汇编语言。但是你会发现，将我们的代码修改成能够编译出80x86汇编语言代码的程序，也是很容易的，所以我不觉得这是一个问题。实际上，我很希望某个熟悉8086汇编语言的朋友能够写一份和我的代码所对应的编译器。因为这正是我们所需要的。

摇篮代码

每一个程序都有一些固定的写法...I/O的处理，错误信息的处理等等。我们要写的程序也不例外。我会尽可能将这些样板代码浓缩到最小，这样我们可以集中精力写最重要的部分，而不是迷失在样板代码中。下面的代码就是我们要写出的一些样板代码。包括I/O程序，错误处理程序，一个骨架程序和主程序。我把这些程序叫做我们的摇篮（cradle）。当我们编写其他程序时，会把它们添加到摇篮里面，然后添加一些对这些程序的调用程序。拷贝一份摇篮程序吧，因为我们会在多处使用这些代码。

有很多种方法来组织一个语法分析器的扫描活动。在Unix系统中，人们倾向于使用getc方法和ungetc方法来读取和回退字符。我这里使用的方法是，用一个单独的全局变量来记录向前看到的一个字符。初始化的部分（唯一的一个初始化部分）读取输入流中的第一个字符。我们没有用到Turbo 4.0的任何的特殊的技术。每个接下来的GetChar方法的调用，都将读取输入流中的下一个字符。

[source,pascal]
----
program Cradle;

{ 声明常量 }

const TAB = ^I;

{ 声明变量 }

var Look: char;              { 向前看字符 }
                              
{ 从输入流中读取新的字符 }

procedure GetChar;
begin
   Read(Look);
end;

{ 打印错误信息 }

procedure Error(s: string);
begin
   WriteLn;
   WriteLn(^G, 'Error: ', s, '.');
end;

{ 打印错误信息然后将程序挂起 }

procedure Abort(s: string);
begin
   Error(s);
   Halt;
end;

{ 打印预期看到的信息 }

procedure Expected(s: string);
begin
   Abort(s + ' Expected');
end;

{ 匹配一个特定的输入字符 }

procedure Match(x: char);
begin
   if Look = x then GetChar
   else Expected('''' + x + '''');
end;

{ 识别一个字母 }

function IsAlpha(c: char): boolean;
begin
   IsAlpha := upcase(c) in ['A'..'Z'];
end;

{ 识别一个十进制数字 }

function IsDigit(c: char): boolean;
begin
   IsDigit := c in ['0'..'9'];
end;

{ 获取一个标识符 }

function GetName: char;
begin
   if not IsAlpha(Look) then Expected('Name');
   GetName := UpCase(Look);
   GetChar;
end;

{ 获取一个数值 }

function GetNum: char;
begin
   if not IsDigit(Look) then Expected('Integer');
   GetNum := Look;
   GetChar;
end;

{ 输出一个带有制表符TAB的字符串 }

procedure Emit(s: string);
begin
   Write(TAB, s);
end;

{ 输出带有制表符TAB和CRLF字符的字符串 }

procedure EmitLn(s: string);
begin
   Emit(s);
   WriteLn;
end;

{ 初始化 }

procedure Init;
begin
   GetChar;
end;

{ 主程序 }

begin
   Init;
end.
----

简介结束了。将上面的代码拷贝到TP中，然后编译它们。要保证编译能够通过然后正确的运行起来。接下来我们将要开始第一课，也就是表达式的语法分析。

NOTE: 如果在Ubuntu下想要进行Pascal编程，可以 `sudo apt-get install fpc` 。

=== C & X86 版本代码

.cradle.h
[source,c]
----
#ifndef _CRADLE_H
#define _CRADLE_H

#define UPCASE(C) (~(1<<5) & (C))
#define MAX_BUF 100

static char tmp[MAX_BUF];

char Look;

void GetChar();

void Error(char *s);
void Abort(char *s);
void Expected(char *s);
void Match(char x);

int IsAlpha(char c);
int IsDigit(char c);

char GetName();
char GetNum();

void Emit(char *s);
void EmitLn(char *s);

void Init();

#endif
----

.cradle.c
[source,c]
----
#include "cradle.h"
#include <stdio.h>
#include <stdlib.h>


void GetChar() 
{
    Look = getchar();
}


void Error(char *s)
{
    printf("\nError: %s.", s);
}

void Abort(char *s)
{
    Error(s);
    exit(1);
}


void Expected(char *s)
{
    sprintf(tmp, "%s Expected", s);
    Abort(tmp);
}


void Match(char x)
{
    if(Look == x) {
        GetChar();
    } else {
        sprintf(tmp, "' %c ' ",  x);
        Expected(tmp);
    }
}


int IsAlpha(char c)
{
    return (UPCASE(c) >= 'A') && (UPCASE(c) <= 'Z');
} 

int IsDigit(char c)
{
    return (c >= '0') && (c <= '9');
}


char GetName()
{
    char c = Look;

    if( !IsAlpha(Look)) {
        sprintf(tmp, "Name");
        Expected(tmp);
    }

    GetChar();

    return UPCASE(c);
}


char GetNum()
{
    char c = Look;

    if( !IsDigit(Look)) {
        sprintf(tmp, "Integer");
        Expected(tmp);
    }

    GetChar();

    return c;
}

void Emit(char *s)
{
    printf("\t%s", s);
}

void EmitLn(char *s)
{
    Emit(s);
    printf("\n");
}

void Init()
{
    GetChar();
}
----

== 对表达式进行语法分析

让我们开始吧！

如果你已经阅读了简介这一章，你就知道我们要干什么了。你也应该已经将摇篮代码都拷贝到你的Turbo Pascal软件中了，并且还编译过了。现在我们可以开始了。

我们这篇文章将要学习如何来对数学表达式进行语法分析，以及如何将数学表达式翻译成68000汇编代码。我们预期的输出是一系列的汇编语句，而汇编语句的执行结果是正确的计算结果。一个表达式就是等式的右边，如下：

[source,text]
----
               x = 2*y + 3/(4*z)
----

在早期阶段，我的步子会迈的非常非常小。这样初学者不会迷失。有一些很好的课程需要我们在很早的时候就学会，这样我们后面会很容易学习其他的知识。对于有经验的读者，需要忍受一下我讲的一些非常基础的知识。我们很快就会进入到核心区域的知识。

单字符的数字

为了保持教程一贯的风格（KISS，还记得吗？），让我们先从绝对最简单的情况开始思考。对于我来说，就是一个表达式只包含一个单个字符的数字的这种情况。

在开始写代码之前，要保证你将上一章的摇篮代码已经拷贝到你的Turbo Pascal中了。我们在别的代码中将会再次使用它们。接下来将下面的代码添加到程序中：

[source,pascal]
----
{---------------------------------------------------------------}
{ Parse and Translate a Math Expression }

procedure Expression;
begin
   EmitLn('MOVE #' + GetNum + ',D0')
end;
{---------------------------------------------------------------}
----

然后将 `Expression;` 这一行添加到主程序当中去，现在主程序如下：
                              
[source,pascal]
----
{---------------------------------------------------------------}
begin
   Init;
   Expression;
end.
{---------------------------------------------------------------}
----

现在运行程序。尝试一下将任意单个数字作为输入。你将会得到一行汇编代码的输出。然后再尝试一下输入任意其他的单个字符，你将会发现我们的语法分析器将会打印一个错误信息。

恭喜你！我们现在已经有一个可以工作的翻译器了！

好吧，我承认上面的代码的功能实在是太弱了。但是你别小看它啊。这个小小的编译器所做的事情，其实就是大型编译器所做的事情：它正确的识别合法的程序语句，然后输出正确的可以执行的汇编代码。而且同样重要的是，我们写的这个小小的编译器能够识别不合法的程序语句，然后给出一个有意义的错误信息。你还想要啥自行车？随着我们不断的扩展我们的语法分析器，我们最好能够确保以上两点永远没问题。

上面写的小程序有一些其他的特点值得聊一下。首先，你会看到我们并没有将语法分析和代码生成分开成不同的模块。一旦语法分析器知道我们想要的工作已经完成，就会立即生成目标汇编代码。在一个真实的编译器中，GetChar会从磁盘上读取文件，然后输出到另一个磁盘文件。但我们所用的方法很容易进行测试和实验。

同时也要注意，一个表达式一定会产生一个求值结果，并将求值结果存放到某个地方。我选择的地方是68000芯片的D0寄存器。我可能应该选其他的地方来存放求值结果，但D0也很好。

二元表达式

现在我们已经上路了，让我们继续往前开车。必须要承认的是，一个表达式只包含一个数字，够呛能满足我们的需求。所以让我们看一下如何来扩展我们的代码。假设我们想处理下面这种形式的表达式：

[source,text]
----
                         1+2
     或者                4-3
     或者, 更一般的形式, <term> +/- <term>
----

NOTE: 其实上面的最后一行就是巴科斯-诺尔范式，或者简称BNF。
                              
我们需要写一个程序来识别上面所写的 `term` 然后将计算结果存放在某个地方，然后还得写一个程序来识别 `+` 和 `-` ，然后输出我们想要的汇编代码。但是如果表达式将计算结果保存在 `D0` 寄存器，那我们将 `Term` 的计算结果保存在哪里？答案就是：同样的地方 `D0` 。在我们得到 `Term` 的下一个计算结果之前，我们将会把 `Term` 的第一个计算结果存放在某个地方。

好吧，我们想做的事情基本就是写一个 `Term` 程序，它要做的事情就是我们之前写的 `Expression` 程序要做的事情。所以将 `Expression` 程序 **重命名** 成 `Term` 就行了。然后编写新版本的 `Expression` 程序如下：

[source,pascal]
----
{---------------------------------------------------------------}
{ Parse and Translate an Expression }

procedure Expression;
begin
   Term;
   EmitLn('MOVE D0,D1');
   case Look of
    '+': Add;
    '-': Subtract;
   else Expected('Addop');
   end;
end;
{--------------------------------------------------------------}
----

紧接着，在 `Expression` 程序上面写如下两个程序：

[source,pascal]
----
{--------------------------------------------------------------}
{ Recognize and Translate an Add }

procedure Add;
begin
   Match('+');
   Term;
   EmitLn('ADD D1,D0');
end;


{-------------------------------------------------------------}
{ Recognize and Translate a Subtract }

procedure Subtract;
begin
   Match('-');
   Term;
   EmitLn('SUB D1,D0');
end;
{-------------------------------------------------------------}
----                              

When you're finished with that,  the order of the routines should
be:

当你完成了以上工作，现在各个程序的顺序应该如下：

* Term (老版本的Expression)
* Add
* Subtract
* Expression

现在运行程序。尝试一下你能够想到的所有的两个单字符数字所组成的排列组合，用 `+` 和 `-` 进行分割。你每次运行应该能够得到4行汇编代码。现在尝试一下能够出现错误的一些表达式。我们的语法分析器捕获到这些错误了吗？

看一下我们程序产生的汇编代码。有两个地方需要注意。第一，生成的代码并不是我们自己会写的那种汇编代码。下面的代码：

[source,text]
----
        MOVE #n,D0
        MOVE D0,D1
----

很低效。如果我们手写汇编代码，我们肯定会直接将数据 `#n` 加载到 `D1` 寄存器中啊。

这里还反映出一种信息：那就是我们的语法分析器产生的汇编代码比我们手写的汇编代码效率要低。习惯它吧。在本系列教程中，一直都是这样的。其实，在某种程度上，所有的编译器都是这样的。一些计算机科学家终其一生都在研究代码优化，他们所做的工作确实改进了生成的代码的质量。一些编译器做的很好，但这样做会付出很大的代价，编译器代码的复杂度会很高。而且这也是一场注定会失败的战争，可能永远不会出现一种情况，那就是一个好的汇编程序员无法打败编译器生成的汇编代码。在这个系列教程结束之前，我会提几句可以对编译器做的一点优化。仅仅是为了告诉你做一些简单的优化也不太难。但是要记住，我们要学习的不是代码的优化。现在，通过阅读这一系列的教程，我们会忽略掉优化方面的东西，重点学习如果生成能运行的汇编代码。

还要说的一点是：我们的代码有问题，是错的！当然产生的汇编代码可以运行，减法程序会从 `D0` 寄存器（存放的是第二个参数）的值减去 `D1` 寄存器（存放的是第一个参数）的值。这种方式是错误的，因为我们产生的结果的正负是有问题的。所以让我们来修复一下 `Subtract` 程序的bug，我们用改变结果的正负性的方式就可以解决这个问题，代码如下：

[source,pascal]
----
{-------------------------------------------------------------}
{ Recognize and Translate a Subtract }

procedure Subtract;
begin
   Match('-');
   Term;
   EmitLn('SUB D1,D0');
   EmitLn('NEG D0');
end;
{-------------------------------------------------------------}
----

现在我们的代码更加低效了，但最起码能够输出正确的结果了！不幸的是，程序中表示表达式中的 `term` 的顺序看起来很别扭。这就是我们生活的真相啊。当我们实现除法时，又会碰到同样的问题。

好吧，现在我们已经拥有了一个语法解析器能够识别两个数字的和或者差。之前，我们的程序只能识别一个单个的数字。但是真正的表达式可以拥有两种形式中的一种（单个数字或者加减法表达式）。现在你可以运行程序然后输入一个单个的字符 `'1'` ，看看能处理之前的表达式形式吗？

是不是无法工作了？为什么无法工作了？我们完成的语法解析器目前只能识别这样的表达式：那就是有两个 `term` 的加减表达式。我们必须重写 `Expression` 方法，让它能做更多的事情。而这才是一个真正的语法分析器开始的地方。

一般表达式

在一个真实世界里，一个表达式可以包含一个或者多个 `term` ，用加减运算符进行分割。在BNF中，写做下面的形式：

[source,text]
----
          <expression> ::= <term> [<addop> <term>]*
----

我们可以在 `Expression` 方法中添加一个简单的循环，来适配上面的定义：

[source,pascal]
----
{---------------------------------------------------------------}
{ Parse and Translate an Expression }

procedure Expression;
begin
   Term;
   while Look in ['+', '-'] do begin
      EmitLn('MOVE D0,D1');
      case Look of
       '+': Add;
       '-': Subtract;
      else Expected('Addop');
      end;
   end;
end;
{--------------------------------------------------------------}
----

现在我们又前进了一步。这个版本的程序可以处理任意数量的 `term` ，而只耗费了我们两行额外的代码。当我们继续前进时，我们会发现这就是自顶向下语法分析器的特点...只需要添加几行代码就可以适配编程语言的扩展。注意， `Expression` 方法和BNF定义是多么的匹配啊！这同样是自顶向下语法分析器的一个特点。当你熟练掌握了这种方法，你会发现将BNF定义转换成语法分析器的代码是非常容易的！

好吧，现在可以尝试一下我们最新版本的语法分析器了。验证一下会发现我们的代码可以处理各种合法的表达式，还会对非法的表达式输出一个有意义的错误信息。很整洁吧？你可能会发现在我们测试的时候，任何错误信息都会嵌在我们产生的汇编代码里。但是记住，这是因为我们使用 `CRT` 作为了我们的输出文件。在一个可用的产品里，这两种输出是分开的...一个输出到屏幕，一个输出到文件中。

使用栈

现在我将会打破我不引入任何复杂性的原则。因为这里引入复杂性是绝对必要的。我们需要指出代码中的一个问题。现在代码的逻辑是，语法分析器将会使用 `D0` 寄存器来作为 `主要` 寄存器， `D1` 寄存器作为存储部分和的地方。现在程序工作起来还比较好，因为我们只需要处理的运算符是加号和减号。任何新的 `term` 一旦被发现都会被累加。但在一般情况下，就不好使了。例如下面的表达式：

[source,text]
----
               1+(2-(3+(4-5)))
----

如果我们将 `'1'` 放入 `D1` 寄存器中，那我们把 `'2'` 放在哪里？因为一个一般的表达式可能有任意复杂度。所以我们将会很快用完所有寄存器！

幸运的是，有一个简单的解决方法。就像所有现代的微处理器一样，68000处理器也有一个栈。栈是一个用来存储一堆东西的完美的地方。所以无需将 `term` 从 `D0` 移动到 `D1` 这么麻烦，我们直接将 `term` 压入栈就可以了。对于不熟悉68000处理器的读者，我们说一下如何压栈，如下汇编就可以：

[source,text]
----
压栈操作，     -(SP)

弹栈操作，     (SP)+ .
----

所以让我们更改一下 `Expression` 方法中的 `EmitLn` 代码：

[source,pascal]
----
               EmitLn('MOVE D0,-(SP)');
----

然后更改两个数的加减操作的代码 `Add` 和 `Subtract`：

[source,pascal]
----
               EmitLn('ADD (SP)+,D0')
----

以及

[source,pascal]
----
               EmitLn('SUB (SP)+,D0'),
----

现在重新编译尝试一下语法分析器，会发现并没有搞崩代码。

我们的代码比之前的更加低效了，但这是一个必要的步骤，你会看到的！

乘法和除法

现在让我们来做一些真正的复杂的工作。很明显你知道，除了加减运算符还有其他的数学运算符，表达式需要有乘除法。你已经知道了有一个隐含的运算符叫做 `优先级` ，或者叫做等级。在表达式中优先级很重要，就像下面的表达式：

[source,text]
----
                    2 + 3 * 4,
----

我们都知道应该先做乘法运算，然后再做加法运算。（知道我们为什么需要栈了吗？）

在编译器技术的早期，人们会使用一些超级复杂的技术来保证运算符的优先级被遵守。后来发现，这些超级复杂的技术是完全没有必要的。运算符优先级的规则可以很好的被我们的自顶向下语法分析技术所适配。而直到现在，我们考虑的 `term` 还只是一个单字符的数字。

更加一般的方式是将 `term` 定义为多个 `FACTOR` 的 `乘积`，例如：

[source,text]
----
          <term> ::= <factor>  [ <mulop> <factor> ]*
----

什么是 `factor` ？现在，它就是一个单字符数字的 `term` 。

注意到对称性了吗？一个 `term` 和一个表达式的形式是一样的。实际上，我们可以对代码做一些重命名和拷贝的工作。但为了避免混淆，下面的代码是语法分析器的所有代码。（注意我们处理除法运算符的方式）

[source,pascal]
----
{---------------------------------------------------------------}
{ Parse and Translate a Math Factor }

procedure Factor;
begin
   EmitLn('MOVE #' + GetNum + ',D0')
end;


{--------------------------------------------------------------}
{ Recognize and Translate a Multiply }

procedure Multiply;
begin
   Match('*');
   Factor;
   EmitLn('MULS (SP)+,D0');
end;


{-------------------------------------------------------------}
{ Recognize and Translate a Divide }

procedure Divide;
begin
   Match('/');
   Factor;
   EmitLn('MOVE (SP)+,D1');
   EmitLn('DIVS D1,D0');
end;


{---------------------------------------------------------------}
{ Parse and Translate a Math Term }

procedure Term;
begin
   Factor;
   while Look in ['*', '/'] do begin
      EmitLn('MOVE D0,-(SP)');
      case Look of
       '*': Multiply;
       '/': Divide;
      else Expected('Mulop');
      end;
   end;
end;




{--------------------------------------------------------------}
{ Recognize and Translate an Add }

procedure Add;
begin
   Match('+');
   Term;
   EmitLn('ADD (SP)+,D0');
end;


{-------------------------------------------------------------}
{ Recognize and Translate a Subtract }

procedure Subtract;
begin
   Match('-');
   Term;
   EmitLn('SUB (SP)+,D0');
   EmitLn('NEG D0');
end;


{---------------------------------------------------------------}
{ Parse and Translate an Expression }

procedure Expression;
begin
   Term;
   while Look in ['+', '-'] do begin
      EmitLn('MOVE D0,-(SP)');
      case Look of
       '+': Add;
       '-': Subtract;
      else Expected('Addop');
      end;
   end;
end;
{--------------------------------------------------------------}
----

来抽一根！一个非常整洁的语法分析器或者说翻译器已经完成了，只用了55行Pascal代码！输出已经开始看起来有那么一点儿用了。当然你得忽略掉生成的汇编代码很低效。记住，我们从来不打算生成紧凑高效的代码！

括号

我们可以将这部分的语法解析器改装成可以处理带括号的表达式的解析器。你知道的，括号主要用来强制规定运算符的优先级。比如下面的表达式：

[source,text]
----
               2*(3+4) ,
----

括号强制使加法运算发生在乘法运算之前。更为重要的是，括号让我们可以定义任意复杂度的表达式，例如下面：

[source,text]
----
               (1+2)/((3+4)+(5-6))
----

将括号处理机制引入我们的语法分析器的关键在于：要意识到无论被括号括住的表达式多么的复杂，对于这个世界来说，它看起来就像是一个简单的 `factor` 。也就是说， `factor` 的一种形式如下：

[source,text]
----
          <factor> ::= (<expression>)
----

递归来了！一个表达式可以包含一个 `factor` ，而这个 `factor` 可以包含其他的表达式，而这个表达式又可能包含了一个 `factor` ，可以无限搞下去。

无论复杂与否，我们都得处理这种情况。当然只需要在 `Factor` 方法中添加几行代码就可以了：                             

[source,pascal]
----
{---------------------------------------------------------------}
{ Parse and Translate a Math Factor }

procedure Expression; Forward;

procedure Factor;
begin
   if Look = '(' then begin
      Match('(');
      Expression;
      Match(')');
      end
   else
      EmitLn('MOVE #' + GetNum + ',D0');
end;
{--------------------------------------------------------------}
----

再次注意一下，我们扩展语法分析器是多么的容易啊。我们的Pascal代码和BNF语法也特别的适配。

像之前那样，编译一下最新写的程序，然后保证它能够正确的解析合法的输入，以及能够对非法输入正确的报错。

一元运算符负号的处理

现在，我们的语法分析器已经能够处理任意的表达式了，是吗？好吧，试一下下面的输入：

[source,text]
----
                         -1
----

又废了！不能工作了，是吧？ `Expression` 方法期望的输入是以整数开始的输入，而我们的输入是以负号开始的。所以你会发现 `+3` 同样不会工作，下面的表达式也不会工作：

[source,text]
----
                    -(3-2) .
----

其实有很多方法可以搞定这个问题。最简单的方法（当然不一定是最好的方法）是将一个 `0` 添加到这种类型的表达式的最前面。所以 `-3` 变成了 `0-3` 。我们可以轻松的将这个补丁打到现在的 `Expression` 方法的代码里面：

[source,pascal]
----
{---------------------------------------------------------------}
{ Parse and Translate an Expression }

procedure Expression;
begin
   if IsAddop(Look) then
      EmitLn('CLR D0')
   else
      Term;
   while IsAddop(Look) do begin
      EmitLn('MOVE D0,-(SP)');
      case Look of
       '+': Add;
       '-': Subtract;
      else Expected('Addop');
      end;
   end;
end;
{--------------------------------------------------------------}
---- 

我和你说过修改代码很简单吧！只需要我们添加3行新的Pascal代码就可以了。注意一下对新的方法 `IsAddop` 的调用。因为对加减法运算符的检测出现过两次，所以我决定将它抽出来成为一个单独的函数。 `IsAddop` 方法的形式很明显来自于 `IsAlpha` 。下面是代码：

[source,pascal]
----
{--------------------------------------------------------------}
{ Recognize an Addop }

function IsAddop(c: char): boolean;
begin
   IsAddop := c in ['+', '-'];
end;
{--------------------------------------------------------------}
----

好的，把以上修改完成然后重新编译代码。你可以将 `IsAddop` 方法添加到你的摇篮代码的最底下。因为后面我们还会需要它。现在再尝试输入一下 `-1` ，可以工作了！当然代码的效率还是很差的，哈哈。我们用了6行代码才将一个常量加载成功。但最起码它是正确的。记住，我们并没有想要取代Turbo Pascal。

现在我们已经完成了表达式的语法分析器的主要结构。这个版本的程序应该可以正确的解析和编译任意你想输入的表达式了。当然我们的程序还是局限在只能处理单个字符的数字这种 `term` 。但我希望现在你能够为语法分析器添加微小的改动，就可以适配对表达式语法的扩展了。当你听到一个变量或者甚至一个函数调用也只不过是一个 `factor` 时，请不要太惊讶。
                             
在下一篇文章中，我将会向你展示扩展我们的语法分析器来适配以上的扩展是相当简单的。我还会想你展示如何去处理多字符的数值以及变量名。所以看到了吧，我们离一个真正有用的语法分析器已经不远了。

有关优化的一点东西

之前的教程，我向你保证过我会给你一些提示，也就是如何去改进生成的汇编代码的质量的方法。像我所说的那样，生成高质量的汇编代码并不是本系列教程的主要目标。但你起码需要知道我们不想在执行汇编代码的时候因为低质量代码的原因浪费时间。实际上，我们可以修改语法分析器来产生更高质量的代码，且并不需要抛弃我们之前写的所有代码。通常情况下，一些优化并不是那么的难做。也就是只需要在语法分析器中添加一些额外的代码就可以了。

有两种主要的方法可以使用：

* 在汇编代码产生之后再去优化生成的汇编代码：这个通常叫做 **窥孔优化** 。通常来讲，我们会知道生成的汇编指令的组合顺序，我们也知道哪些汇编代码很糟糕（例如针对 `-1` 产生的汇编代码）。所以我们需要做的就是扫描生成的汇编代码，然后看一下这些组合序列，然后将它们替换成更好的代码就可以了。这有点像宏展开这种技术。只是和宏展开的方向是反的，只需要进行模式匹配就好了。唯一的复杂性在于有大量的汇编代码组合需要去搜索。这种技术叫做窥孔优化的原因就是因为我们一次只能搜索一小组汇编指令的组合。窥孔优化对于代码质量会有惊人的提升。而且窥孔优化无需更改大量的代码。所以这种代价值得付出。生成的汇编代码的运行速度，代码的行数，以及编译器实现的复杂度都值得我们做这种优化。将所有的汇编指令组合都找出来需要很多的IF测试，因为每一个优化都可能是错误的来源。而且，这种测试比较费时间。在经典的窥孔优化器的实现中，窥孔优化会作为编译器的第二个阶段。编译器生成的汇编代码会存放在磁盘上。然后窥孔优化器读取汇编代码文件，然后做优化，优化后的汇编代码继续存放在磁盘上。实际上，你可以将窥孔优化器看成是一个不同于编译器的独立的程序。因为优化器只会从一个小的“窗口”中去窥探生成的汇编代码。一个更好的实现方式是，缓存一些要输出的汇编代码，然后在每一次 `EmitLn` 之后去扫描缓存。
* 尝试在第一次生成汇编代码的时候就生成更好的代码：这种方法要求我们在 `Emit` 汇编代码之前就找到一些特定的情况来进行优化。举个小例子，我们应该可以识别出表达式中常量0和别的数进行相加，所以我们只需要 `Emit` 一个 `CLR` ，或者干脆什么都不做。又比如，如果我们在 `Factor` 中（注意，不是在 `Expression` 中）识别出一个一元运算符负号，我们可以将 `-1` 这样的常量直接作为普通的常量，而不是通过正数来生成这样的常量。这些事情都不难。他们只需要在代码中额外添加一些代码就可以了。所以我不想把这些优化代码添加到我的代码中。我的观点是，一旦我们将写的编译器跑起来，能够产生能用的汇编代码，我们再回头去折腾一些优化方面的东西，会比较好。这也是为什么世界上会存在发布2.0版本这种事情的原因。

还有一种类型的优化值得说一下，这种方法似乎会产生非常紧凑的代码，也不会引起很大的争论。这算是我的发明吧，因为我没在其他出版物中看到过。当然，我觉得这应该不是我的原创。

我的这种方法避免了大量使用栈，而是会更好的去使用CPU的寄存器。我们之前只做了加减法，所以我们使用的寄存器是 `D0` 和 `D1` ，而不是栈，还记得吗？它可以工作，因为只有两个数需要运算，所以这个隐形的栈从来也没有操作过超过两个数。

而68000处理器有八个数据寄存器。为什么不将它们用做一个私有管理的栈？关键点在于在任何时候，语法分析器都知道在栈上的元素数量是多少。所以我们需要妥善的管理这些元素。我们可以定义一个私有的“栈指针”，这个“栈指针”会跟踪我们现在在栈的哪一层，然后访问对应的寄存器。例如 `Factor` 程序，并不会将数据加载到 `D0` 寄存器中，而是会加载到当前的“栈顶”寄存器中。

我们要做的事情实际上是将CPU的内存上的栈替换成自己管理的栈，而这个自己管理的栈是由寄存器模拟出来的。对于大部分表达式而言，栈的层次数量并不会超过8，所以我们可以生成质量较高的汇编代码。当然，我们需要处理栈的深度超过8的情形，但这也不是什么大问题。我们只需要将我们自己用寄存器模拟出来的栈存不下的数据溢出到CPU的栈中去，就可以了。对于栈深度超过8的情况，代码不会比我们现在生成的代码更加糟糕，对于栈深度小于8的情况，产生的代码更好。

上面的这个优化，我已经自己实现过了，只是为了确保这种优化能工作，这样不会对你产生讲解错误。它确实可以工作。在实践中，你不能真把栈的8层都用完。你至少需要一个寄存器用来翻转除法的两个操作数的顺序（真希望68000有一个XTHL，就像8080那样）。对于包含函数调用的表达式，我们也需要一个寄存器来留给它们使用。当然，对于大部分的表达式而言，这种优化将会缩小产生的汇编代码的规模。

所以你可以看到，优化出更好的汇编代码并没有那么困难，但优化确实会增加我们的翻译器的复杂度。我们现在的水平还处理不了这种复杂度。因为这个原因，我强烈建议我们继续忽略掉生成的代码的效率的问题。这样可以保证我们不会为了优化代码而把之前写的代码都扔掉。

下一篇文章，我们将会处理变量这种 `factor` 以及函数调用。我也会向你展示处理多字符 `token` 和输入中的空格是多么的简单。

=== C & X86 版本代码

.cradle.h
[source,c]
----
#ifndef _CRADLE_H
#define _CRADLE_H
#define UPCASE(C) ((1<<6)| (C))

#define MAX_BUF 100
char tmp[MAX_BUF];

char Look;

void GetChar();

void Error(char *s);
void Abort(char *s);
void Expected(char *s);
void Match(char x);

int IsAlpha(char c);
int IsDigit(char c);
int IsAddop(char c);

char GetName();
char GetNum();

void Emit(char *s);
void EmitLn(char *s);

void Init();

#endif
----

.cradle.c
[source,c]
----
#include "cradle.h"
#include <stdio.h>
#include <stdlib.h>


void GetChar() 
{
    Look = getchar();
}


void Error(char *s)
{
    printf("\nError: %s.", s);
}

void Abort(char *s)
{
    Error(s);
    exit(1);
}


void Expected(char *s)
{
    sprintf(tmp, "%s Expected", s);
    Abort(tmp);
}


void Match(char x)
{
    if(Look == x) {
        GetChar();
    } else {
        sprintf(tmp, "' %c ' ",  x);
        Expected(tmp);
    }
}


int IsAlpha(char c)
{
    return (UPCASE(c) >= 'A') && (UPCASE(c) <= 'Z');
} 

int IsDigit(char c)
{
    return (c >= '0') && (c <= '9');
}

int IsAddop(char c)
{
    return (c == '+') || (c == '-');
}

char GetName()
{
    char c = Look;

    if( !IsAlpha(Look)) {
        sprintf(tmp, "Name");
        Expected(tmp);
    }

    GetChar();

    return UPCASE(c);
}


char GetNum()
{
    char c = Look;

    if( !IsDigit(Look)) {
        sprintf(tmp, "Integer");
        Expected(tmp);
    }

    GetChar();

    return c;
}

void Emit(char *s)
{
    printf("\t%s", s);
}

void EmitLn(char *s)
{
    Emit(s);
    printf("\n");
}

void Init()
{
    GetChar();
}
----

.main.c
[source,c]
----
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "cradle.h"

void Term();
void Expression();
void Add();
void Substract();
void Factor();

void Multiply() {
    Match('*');
    Factor();
    // 将栈顶元素和rax中的数相乘,然后结果存入rax中
    EmitLn("imul (%rsp), %rax");
    // 将栈顶元素弹出
    EmitLn("add $8, %rsp");
}

void Divide() {
    Match('/');
    Factor();

    // 此时栈顶元素是上面的Factor读取的数，将这个数存入rdx寄存器中
    EmitLn("mov (%rsp), %rdx");
    // 将栈顶元素弹出
    EmitLn("add $8, %rsp");

    // 将rax寄存器中的值压栈
    EmitLn("push %rax");

    EmitLn("mov %rdx, %rax");

    EmitLn("sar $31, %rdx");
    EmitLn("idivq (%rsp)");
    EmitLn("add $8, %rsp");
}

void Factor() {
    if (Look == '(') {
        Match('(');
        Expression();
        Match(')');
    } else if (IsAddop(Look)) {
        Match('-');
        sprintf(tmp, "mov $%c, %%rax", GetNum());
        EmitLn(tmp);
        EmitLn("neg %rax");
    } else {
        sprintf(tmp, "mov $%c, %%rax", GetNum());
        EmitLn(tmp);
    }
}

void Term() {
    Factor();
    while (strchr("*/", Look)) {
        EmitLn("push %rax");

        switch(Look) {
            case '*':
                Multiply();
                break;
            case '/':
                Divide();
                break;
            default:
                Expected("Mulop");
        }
    }
}

void Expression() {
    if (IsAddop(Look))
        // rax清零
        EmitLn("xor %rax, %rax");
    else
        Term();

    while (strchr("+-", Look)) {
        EmitLn("push %rax");

        switch(Look) {
            case '+':
                Add();
                break;
            case '-':
                Substract();
                break;
            default:
                Expected("Addop");
        }
    }
}

void Add() {
    Match('+');
    Term();
    EmitLn("add (%rsp), %rax");
    EmitLn("add $8, %rsp");
}

void Substract() {
    Match('-');
    Term();
    EmitLn("sub (%rsp), %rax");
    EmitLn("neg %rax");
    EmitLn("add $8, %rsp");
}

int main() {
    Init();
    EmitLn(".globl main");
    EmitLn("main:");
    Expression();

    // 将rax值返回
    EmitLn("ret");
    return 0;
}
----

.Makefile
[source,makefile]
----
IN=main.c cradle.c
OUT=main
FLAGS=-Wall -Werror

all:
	gcc -o $(OUT) $(IN) $(FLAGS)

run:
	./$(OUT)

.PHONY: clean
clean:
	rm $(OUT)
----

运行

[source,bash]
----
$ make
$ ./main > tmp.s
(1+3)/1
$ gcc -o tmp tmp.s
$ ./tmp
$ echo $?
----

就可以看到输出结果了。