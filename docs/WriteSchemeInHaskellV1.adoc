= 使用Haskell编写Scheme解释器
:icons: font
:source-highlighter: pygments
:toc: left
:toclevels: 4
:sectnums:

== 概论

大部分网路上的Haskell教程会使用一种与语言参考手册类似的方式来进行教学。他们会告诉你语法和一些语言结构，然后让你在交互式命令行里写一些简单的函数。而如何用函数式的方式来写一个有用的程序的问题却被留在了最后面或是直接被忽略了。

而我们会用一种完全不同的方式。你会从使用和解析命令行参数开始，然后写一个能够实现R5RS Scheme标准的像模像样的子集的Scheme解释器。你将会学习到Haskell的I/O，可变状态，动态类型，错误处理以及其他相关的解析功能。而当你完成这个教程的时候，你就会对Haskell和Scheme相当熟悉了。

这个教程主要面向两大读者群：

* 已经掌握Lisp或Scheme并且想要学习Haskell的人
* 虽然不懂任何编程语言，但是有大量背景知识并且对计算机非常熟悉的人

第二种读者会发现这个任务有些困难，因为在这里省略了很多Scheme以及其他通用的编程概念从而把教程的重点放在Haskell上面。SICP或者The Little Schemer之类的书会对你很有帮助。

而那些使用像C，Java或者Python这样的基于过程或面向对象语言的用户需要注意了：你需要忘掉大部分你已经熟悉的编程知识。Haskell与上述的语言完全不同，并且要求你用一种完全不一样的方式来进行思考。最好以白板的状态来开始这个教程并且不要尝试将Haskell与命令式语言进行比较，因为很多你以为你熟悉的概念（classes，functions，return）在Haskell里有完全不同的含义。

由于每一课都建立在之前代码的基础上，所以你最好按顺序来学习课程。

这个教程假定你用ghc作为你的Haskell编译器。代码在Hugs或者其他编译器里或许也能运行但并没有被完全测试过，也许你还需要下载一些额外的库来支持他们。

== 第一步：编译然后运行程序

首先，你需要安装一个ghc。在Linux上，它常常被预先安装好了或者能够通过apt-get或者yum命令来轻松搞定。你也可以从官网直接下载它。不过除非你确信你想从源码去编译它，否则下载一个二进制包就可以了。像安装其他的软件包一样下载和安装它既可。这个教程是在Linux下完成的，但是只要你会使用相关的命令行操作，它在Windows或是Mac环境下也一样能工作。

对UNIX或者Windows Emacs用户来说，这里有一个很棒的Emacs mode，包括了语法高亮和自动缩进的功能。Windows用户则能够直接使用记事本或者其他文本编辑器：Haskell的语法对记事本相当友好，尽管你仍要小心处理缩进。Eclipse用户建议使用eclipsefp插件。

现在，是时候写你的第一个Haskell程序了。这个程序将通过命令行读入一个名字然后输出一个问候语句。建立一个以 ".hs” 结尾的文件并输入下列代码。当心缩进，否则你的程序可能没法通过编译。

[source,haskell]
----
module Main where  
import System.Environment  

main :: IO ()  
main = do args <- getArgs  
          putStrLn ("Hello, " ++ args !! 0)
----

我们来看下这段代码。前两行表示我们讲创建一个名叫Main的模块，并且导入了System这个模块。所有的Haskell程序都会从Main模块里的一个叫做main函数的地方开始运行。你可以在这个模块中导入其他的模块，但是如果没有了它，编译器就无法生成可执行文件供用户运行。此外Haskell是大小写的敏感的：模块名称需要是大写开头的，而函数声明则必须是非大写开头的。

main :: IO ()这行是函数的类型声明：它表示main函数的类型是IO()，是一个返回Unit类型()的IO操作。一个Unit类型仅会包含一个值，而()，它表示什么也没有。类型声明在Haskell里是可选的：编译器能够自动的识别它们，当你的声明和编译器自动识别发生冲突的时候它则会报错。在这个教程中，为了更清晰的说明，所有的类型都是显式声明的。而你在家里跟着做的时候，你可能更愿意选择忽略，因为在编写这个程序的时候其实并不太需要去在意它们。

IO类型是Monad类型类的一个实例，Monad是一种抽象的概念，如果满足以下这两个条件，那我们就会说这样的值是Monad：

. 这个值包含了一些特定类型的附加信息；
. 大多数函数不需要去关心这些附加的信息。

在这个例子里，

. 这个附加的信息就是将被执行的IO操作；
. 而这个附加信息的值是不存在的，表示成 `()` 。

`IO[String]` 和 `IO()` 都同样属于 `IO Monad` 类型，但它们有着不同的基本类型。它们作用于 `(` 或是传递 `)` 不同类型的值， `[String]` 和 `()` 。

那些包含了附加信息的值则被称作“Monadic”。

Monadic值常被称作“操作”，因为最容易的思考IO Monad用途的方法就是把它当做一系列可能会影响外界世界的动作。这一系列动作会传递一些基础的数值，然后在这个过程中每个动作都会对这些值进行影响。

Haskell是一个函数式的语言：与给出计算机一系列指令从而让它执行不同，你需要给Haskell一系列定义来告诉它每一个函数来如何处理。这些定义会将各种动作和函数组合在一起。而编译器会识别出将它们组织在一起的执行方式。

要写出这样一个定义，你首先需要建立一个等式。等式的左边是一个名称，可能还会带有若干个与变量绑定的模式(后面会解释)。右边的话，会给出一些由其他定义组合而成的式子，从而告诉计算机如何遇到该定义时如何进行计算。这些等式就和一般的代数表达式一样：你总是可以在程序中用等式右边的部分来替代左边的名字，并且得到与之前相同的结果。这种行为被称作“引用透明”，而这种性质使得Haskell代码比其它的语言更加易于理解。

那我们应该怎么定义我们的main函数呢？我们知道它必须是一个能够从命令行读入参数，然后从打印出一些输出，最终返回()（空值）的IO()操作。

这里有两种方法创建一个IO操作：

. 使用return函数提升一个普通值进入IO Monad。
. 连接两个已经存在的IO操作。

因为我们接下来要做两件事情，所以我们选择第二种方法。我们通过内建函数getArgs读入命令行参数并把它们存入一个字符串列表。而内建函数putStrLn则能够读入一个字符串然后将它输出到终端。

我们使用一个do代码块来连接这两个操作。一个do代码块包括很多行，所有的行按照第一个非空白字符在do后面排列，并且每行都可能是如下两种形式之一：

. name <- action1
. action2

第一种形式将action1的结果和name绑定，从而你可以在下一个操作中使用它。例如，如果有action1的类型是IO[String](一个会返回一个字符串列表的IO操作，就和getArgs一样)，那name就会在接下来的一系列操作里和这个返回的字符串列表通过绑定操作符>>=绑定在一起。第二种情况仅仅执行这个action2，并通过>>操作符同下一行连结在一起。绑定操作符在处理不同Monad的情况下有不同的语义：在IO Monad中，它会连续执行所有的操作，然后对外部世界产生这些操作带来的副作用。由于这个绑定符号的语义依赖你具体使用的Monad类型，所以你并不能在同一个do代码块里把不同类型的Monad类型的操作糅杂在一起---在这里只有IO Monad是可用的（在同一个管道中）。

当然，这些操作可能自己会调用其他函数或是复杂的表达式，然后继续传递它们的计算结果（通过调用return或是其他最终调用了return的函数）。

在这个例子里，我们首先取出参数列表中的第一个元素(args !! 0)，然后把它拼接到字符串"Hello,"的后面（"Hello," ++），最后把结果传给putStrLn。

就这样，一个包含了之前所说的读取和打印操作的新的操作就这样创建完毕并存到了main这个返回值为IO()的标识符中。这样Haskell系统就能够识别并运行它了。

Haskell中，字符串即是字符的列表形式，所以你可以对它使用任何的列表函数或是操作符。以下是一个完整的标准操作符列表和它们对应的优先级：

image::./haskell-cheatsheet.png[]

接下来编译和运行这个程序：

[source,bash]
----
$ ghc -o hello_you --make listing2.hs
$ ./hello_you Jonathan
Hello, Jonathan
----

**习题**

. 修改程序，让它能够从命令行读取两个参数然后打印出一条包含它们的信息。
. 修改程序，让它能够使用输入的参数进行简单的四则运算，建议使用read来讲字符串转化成数字类型，并用show来进行相反的操作。对各种不同的动作都操练一番。
. getLine是一个从命令行读取一行输入信息然后返回字符串的IO操作。修改程序，让它能够提示需要一个名字并读取这个名字而不是像之前那样直接从命令行传入参数，最后打印它。

== 解析

=== 一个简单的解析器

现在，让我们试着写一个非常简单的解析器。我们会用到Parsec库。（如果你还没有安装的话，可以通过Haskell平台下载或者直接使用它的源代码。根据你的编译器的版本，选择对应的代码包并编译它。在Ubuntu系统上的话，直接运行命令sudo apt-get install cabal-install;cabal update;cabal install parsec来安装）

添加一行到导入模块的部分：

[source,haskell]
----
import Text.ParserCombinators.Parsec hiding (spaces)
import  System.Environment
----

这样我们就可以使用Parsec库中的函数了，除了一个等下会和我们自己定义的函数名冲突的spaces函数。

现在让我们定义一个能够识别出Scheme中允许的符号的解析器：

[source,haskell]
----
symbol :: Parser Char
symbol = oneOf "!#$%&|*+-/:<=>?@^_~"
----

这又是一个Monad的例子：在这里，被隐藏的“额外信息”包括在输入流中的位置，回溯记录以及First和Follow集等。Parsec会替我们解决这个问题。而我们只需要去调用Parsec库中的函数oneOf，它就会替我们将传递给它的字符串中的任意一个识别出来。Parsec库提供了一些内置的解析器：例如letter和digit函数。正如你将看到的，你可以将基本的函数组合成更加复杂的解析器。

让我们定义一个调用解析器并且处理可能的错误的函数：

[source,haskell]
----
readExpr :: String -> String
readExpr input = case parse symbol "lisp" input of 
    Left err -> "No match: " ++ show err 
    Right val -> "Found value"
----

正如你从类型签名看到的一样，readExpr是一个将String转化成String的函数（->）。我们把传入的参数命名为input，然后把它和我们之前定义的名叫symbol的解析器一起传递给parse函数。传递的第二个参数是我们给输入定义的名称，这会在显示错误信息的时候用到。parse会返回一个被解析的返回值或者一个错误，因此我们是需要处理错误情况的。根据标准的Haskell编程规约，Parsec返回一个Either类型，用他得Left构造器表示错误并且用Right构造器来表示普通的值。

我们使用一个case...of的语句来对parse的各种可能的返回值进行匹配。如果我们得到一个Left值（错误），那我们就把这个error绑定给变量err然后在开头加上字符串“No match ”然后返回。如果我们得到一个Right值，我们把它绑定给val，然后无视它并返回一个“Found value”字符串。

我们可以看到使用case...of来进行模式匹配的例子，之后我们会继续看到很多类似的做法的。

最后，我们需要修改我们的main函数来调用readExpr并且打印出结果：

[source,haskell]
----
main :: IO ()
main = do 
    (expr:_) <- getArgs 
    putStrLn (readExpr expr)
----

为了编译并运行程序，需要在命令行指定--make参数，否则就会爆出链接错误。举个栗子：

[source,bash]
----
$ ghc --make -o simple_parser listing3.1.hs
$ ./simple_parser $
Found value
$ ./simple_parser a
No match: "lisp" (line 1, column 1):
unexpected "a"
----

=== 空格

接下来，我们会对我们的解析器添加一系列改动来使它能够渐渐识别出我们给出的更加复杂的表达式。现在的解析器在遇到空白的时候就会卡住了：

[source,bash]
----
$ ./simple_parser "   %"
No match: "lisp" (line 1, column 1):
unexpected " "
----

让我们来修正这个问题，并且忽略掉输入中的空格符。

首先，我们定义一个能够辨认出任意数量空格的解析器。顺便，这也是我们之前在导入Parsec模块的时候添加了hiding (spaces)的原因：模块中已经有一个spaces
函数了，但却不大符合我们的要求。（不过有一个叫做lexeme的解析器完全符合我们的要求，不过出于教学目的，我们暂时先无视它。）

[source,haskell]
----
spaces :: Parser ()
spaces = skipMany1 space
----

就像函数一样，操作也能传递给其他操作。在这里我们把Parser操作space 传递给Parser操作skipMany1，来获取到一个能够解析一个或者多个空格的解析器。

现在，我们来编辑一下我们的解析函数：

[source,haskell]
----
readExpr input = case parse (spaces >> symbol) "lisp" input of
    Left err -> "No match: " ++ show err
    Right val -> "Found value"
----

我们在第二课里简单看过一点关于>>("bind")操作符的内容，并且提到我们是把它放在do代码块中的每行的行尾来起到连接作用的。这里，我们显式的使用它来将我们的空格解析器和之前的符合解析器组合起来。然而，相比IO Monad绑定在Parser中有着完全不同的语义。
对于Parser Monad来说，绑定意味着“尝试匹配第一个解析器，然后用剩下的输入尝试匹配第二个，如果任意一次匹配失败的话，就返回失败”。总的来说，绑定在具体的Monad中会起到不同的效果；它被用作一种通用的组织计算的方式，所以能够适应各种不同的情况。你可以阅读对应的文档来判断出它到底会干什么。

编译并且运行代码。请注意我们这里的spaces函数是基于skipMany1定义的，他不会再像之前那样能够识别出单个的字符。因此你必须放一些空格在输入字符的前面。看下现在代码是如何运作的：

[source,bash]
----
$ ghc -package parsec -o simple_parser [../code/listing3.2.hs listing3.2.hs]
$ ./simple_parser "   %"
Found value
$ ./simple_parser %
No match: "lisp" (line 1, column 1):
unexpected "%"
expecting space
$ ./simple_parser "   abc"
No match: "lisp" (line 1, column 4):
unexpected "a"
expecting space 
----

=== 返回值

现在，我们的解析器还并不能做些什么---它仅仅是告诉我们一个给定的字符串是否能够被识别。现在，我们想让它能够做更多的事情：我们希望它能够将输入的字符串转换成一个特定的数据结构并让我们可以容易的遍历它。在这一节，我们将学习如何定义一个数据类型，并且修改我们的解析器让它能够返回该数据类型。

首先，我们来定义一个包含所有各种Lisp值的数据类型：

[source,haskell]
----
data LispVal = Atom String
             | List [LispVal]
             | DottedList [LispVal] LispVal
             | Number Integer
             | String String
             | Bool Bool
----

这是一个代数数据类型的例子：它定义了一组LispVal类型的变量可能存储的值。每一个可能性（通过“|”符号分割的构造器）包含了一个代表构造器的标识符和这个构造器能够接受的一系列数据类型。在这里，一个LispVal可能是：

. Atom。存储了一个用来命名它的字符串
. List。其中存储了一组其他LispVal（Haskell列表用方括号表示），也被称为Proper List。
. DottedList。对应Scheme中的(a b . c)形式。也被称作Improper List。存储了除最后一个元素以外的所有元素，然后再把最后一个元素额外存储起来。
. Number。包含一个Haskell数字。
. String。包含一个Haskell字符串。
. Bool。包含一个Haskell布尔值。

构造器和类型使用的是不同的命名空间，所以你同时将一个类型名和构造器都定义成String，并没有问题。唯一要注意的是，它们都需要以大写字母开头。

接下来，我们来添加一些解析函数来返回对应的不同类型。一个字符串总是一个以双引号开头，然后接着一串不包含双引号的字符，最终以另一个双引号结束：

[source,haskell]
----
parseString :: Parser LispVal
parseString = do
                char '"'
                x <- many (noneOf "\\"")
                char '"'
                return $ String x
----

我们再次使用do表达式而不是>>操作符来组织代码。只是因为我们需要获取解析得到的值（many (noneOf "\\"")的返回值）并且同时使用一些其他的解析操作。总的来说，对于不返回值得操作，使用>>符号，对于你需要立刻将返回的值传递到下一个操作的情况，使用>>=，其余的情况则用do代码块比较好。

当我们完成解析并从many函数中获取Haskell字符串时，我们调用了String构造器（LispVal数据类型）来把它转化成一个LispVal类型的值。每一个在代数数据类型中的构造器都能够像函数一样将传递给它的参数转化成它对应的类型。构造器还能够在模式匹配中作为左手边的匹配表达式进行使用；我们会在第三课里尝试将解析器返回的结果分别用Either类型的两种构造器进行匹配。

接着我们使用内置的return函数将我们的LispVal值lift成一个Parser Monad。注意，do代码块中的每行都必须有同样的类型，然而由于我们的String构造器的返回结果是LispVal类型，因此我们要利用return帮助将它风中成一个Parser操作并且在不消费任何输入的情况下直接将内部的值进行返回。这样我们的整个parserString操作就能够得到Parser LispVal类型的返回值了。

$符号是一个中缀函数呼叫符：它和我们直接使用return (String x)的作用一样，但是$是右结合的，并且运行的优先级较低，这样让我们能够省略掉一些原来需要写得括号。由于$是一个操作符，你可以像使用函数那样使用它做任何事情：传递它，部分调用等。在这个方面，它和Lisp中的apply函数功能一致。

现在继续来看Scheme的变量。一个atom是一个字母或者符号，跟着若干个字母，数字或者符号：

[source,haskell]
----
parseAtom :: Parser LispVal
parseAtom = do 
              first <- letter <|> symbol
              rest <- many (letter <|> digit <|> symbol)
              let atom = first:rest
              return $ case atom of 
                         "#t" -> Bool True
                         "#f" -> Bool False
                         _    -> Atom atom
----

这里我们来看下另一个Parsec的组合符，选择符<|>。它会让我们首先尝试第一个解析器，如果它失败了，然后尝试第二个。如果任意一个成功了，那就会返回成功解析出得值。第一个解析器必须在它消费掉任何输入前失败返回：我们待会儿来看看如何用它来实现回溯。

一旦我们读到第一个字符和并成功读完剩下的部分，我们需要把它们放在一起组成一个atom。let声明定义了一个新的变量atom。我们使用列表连接符:来连接它们。和:相对应的，我们使用连接符++像这样来连接列表[first]++rest；first只是一个字符，我们可以用方括号包围它来将它转换成一个单元素的列表。

然后我们使用一个case表达式来尝试将字符串匹配成true和false，从而判断到底是应该创建和返回哪种LispVal类型。下划线符号\是一个可读性的技巧：目标会不断尝试匹配case块中的值直到遇到\（或者在此之前就因为某些异常失败了从而导致整个匹配失败）并作为一个通配符返回。因此如果代码运行到_条件下，它总是会匹配并且返回一个atom值。

最后，我们再为数字创建一个解析器。这里会展示更多的方法来处理monadic值：

[source,haskell]
----
parseNumber :: Parser LispVal
parseNumber = liftM (Number . read) $ many1 digit
----

从右往左看会让你很容易理解这个表达式，因为函数呼叫符($)和函数组合符(.)函数都是右结合的。结合器many1会匹配目标的一个或者多个传递给它的参数，这里我们会匹配到一个或者多个数字。我们会用返回的字符串来构建出一个数字的LispVal类型，不过这里我们貌似有一些类型上的匹配问题。因此首先，我们用内建的read函数来将字符串转化为数字。然后我们再把数字传递给Number构造器得到一个LispVal类型的值。我们用函数组合符创建出一个将右边参数的调用结果传递给左边参数的函数，因此我们就这样将两个函数调用结合起来了。

不幸的是，many1 digit的返回值是一个Parser String，所以我们的经过结合的Number . Read函数仍然不能直接对它进行操作。我们需要一种告诉它只操作Monad里的值的方法，然后再把处理后的结果返回给Parser LispVal。而标准库中的liftM函数刚好能帮助我呢，所以我们对我们的函数Number . Read使用liftM，然后把结果对Parser进行调用。

我们需要在程序顶部导入Monad模块来使用liftM函数：

[source,haskell]
----
import Control.Monad
----

这种不断进行函数组合，函数调用和函数传递的编程风格在Haskell代码中是非常常见的。这会让你能够在一行中表达出非常复杂的逻辑，并把中间的阶段分解成其它可以用各种方式结合起来的函数。不幸的是，这表明你需要常常从右向左阅读Haskell代码并且注意跟踪它们的类型。在后面的教程中我们会看到更多的例子，所以你应该会马上能适应这种方式。

创建一个能够接受字符串，数字或是Atom的解析器：

[source,haskell]
----
parseExpr :: Parser LispVal
parseExpr = parseAtom
         <|> parseString
         <|> parseNumber
----

编辑readExpr函数让它调用我们的新解析器：

[source,haskell]
----
readExpr :: String -> String
readExpr input = case parse parseExpr "lisp" input of
    Left err -> "No match: " ++ show err
    Right _ -> "Found value"
----

编译并运行代码，你就能发现它接受任意的数字，字符串或者符号并且能够拒绝其他的情况了：

[source,bash]
----
$ ghc -package parsec -o simple_parser [.../code/listing3.3.hs listing3.3.hs]
$ ./simple_parser "\\"this is a string\\""
Found value
$ ./simple_parser 25
Found value
$ ./simple_parser symbol
Found value
$ ./simple_parser (symbol)
bash: syntax error near unexpected token `symbol'
$ ./simple_parser "(symbol)"
No match: "lisp" (line 1, column 1):
unexpected "("
expecting letter, "\\"" or digit
----

=== 习题

. 重写parseNumber函数，不允许使用liftM，尝试
.. 使用do代码块
.. 显式的运用>>=操作符来进行连接
. 我们的字符串并不太符合R5RS规范，因为它们不支持在字符串里使用转义之后的引号。修改parseString函数让\”表示一个引号字符而不是整个字符串的结束。你可能需要用一个新的解析器操作来替换noneOf “\””从而让它能接受非引号字符或者一个转义符号之后的引号字符。
. 修改程序，让它支持\\n \\r \\t \\\\\\\\以及其它你希望转义的字符。
. 修改parseNumber让它提供Scheme标准中对不同进制的支持。readOct和readHex函数或许会对你很有用。
. 给LispVal增加一个字符构造器，然后为R5RS标准中定义的字符创造一个解析器。
. 给LispVal增加一个浮点数构造器来支持R5RS中的小数相关的语法。参考Haskell中的readFloat函数。
. 增加数据类型和解析器从而支持Scheme中的full numeric tower。Haskell已经有内建类型来表示其中的部分内容，你可以通过Prelude模块确认。至于其它，你可以通过定义复合类型的方法来表示它们。例如，一个分数可以用分子和分母表示而一个复数可以用实部和虚部来表示（每一部分都是一个实数）。

=== 递归解析：列表和引号

接下来，给我们的解释器添加更多的解析器。从Lisp的知名括号列表开始：

[source,haskell]
----
parseList :: Parser LispVal
parseList = liftM List $ sepBy parseExpr spaces
----

和parserNumber类似的，首先解析一系列由空格分隔开的表达式（sepBy parseExpr spaces），然后在Parser Monad内部调用构造符将它们组成一个List。注意我们能够把parseExpr直接传递给sepBy，尽管它是一个我们自己写的操作。

dotted-list的解析器稍微会复杂一点，不过仍然只是需要使用我们已经熟悉的概念：

[source,haskell]
----
parseDottedList :: Parser LispVal
parseDottedList = do
    head <- endBy parseExpr spaces
    tail <- char '.' >> spaces >> parseExpr
    return $ DottedList head tail
----

注意我们是怎么使用>>把一系列的Parser操作连接起来并且do代码块中运用它的。表达式char '.' >> spaces返回一个Parser()，然后通过与parseExpr结合产生一个Parser LispVal类型，完全和我们在do代码块中需要的类型一致。

[source,haskell]
----
parseQuoted :: Parser LispVal
parseQuoted = do
    char '\\''
    x <- parseExpr
    return $ List [Atom "quote", x]
----

大部分都是我们已经熟悉了的内容了：这段程序读取一个单个的引号字符，读取一个表达式然后把它绑定给x，然后返回(quote x)，来表达一个Scheme符号。Atom构造器就像一个普通函数一样：你传递一个需要封装的字符串给它，然后它返回给你一个LispVal类型的值。你可以对这个LispVal做任何你一般情况下能做的事情，比如把它放入一个列表里。

最后，编辑parseExpr函数来把我们的新解析器添加进去：

[source,haskell]
----
parseExpr :: Parser LispVal
parseExpr = parseAtom
         <|> parseString
         <|> parseNumber
         <|> parseQuoted
         <|> do char '('
                x <- try parseList <|> parseDottedList
                char ')'
                return x
----

这里演示了最后一个Parsec的功能：回溯。parseList和parseDottedLis直到某个特定的位置都能够识别出相同的字符串；这打破了一个选择不能在出错前消费任何输入的前提。而try连接器试图运行某个的解析器，但是如果解析失败了，它会回滚到上一个状态。这让你在不影响其它分支的前提下对目标进行各种操作。

编译然后运行：

[source,bash]
----
$ ghc -package parsec -o simple_parser [../code/listing3.4.hs listing3.4.hs]
$ ./simple_parser "(a test)"
Found value
$ ./simple_parser "(a (nested) test)"
Found value
$ ./simple_parser "(a (dotted . list) test)"
Found value
$ ./simple_parser "(a '(quoted (dotted . list)) test)"
Found value
$ ./simple_parser "(a '(imbalanced parens)"
No match: "lisp" (line 1, column 24):
unexpected end of input
expecting space or ")"
----

注意我们可以在parseExpr里任意深入的嵌套我们的解析器。这样，我们通过一些简单的定义就能够完全的让程序阅读Lisp代码了。这就是递归的威力。

=== 习题

. 添加backquote语法糖的支持：Scheme标准详述了它应该怎样展开成（quasiquote/unquote）。
. 添加vectors的支持。你可以使用Haskell的内置实现Array，但是它使用起来可能会有些问题。严格说，一个vector应该有常数时间的索引和更新操作，但是事实上直接的更新操作在一个纯函数式语言里是很难实现的。你可能在看过该系列教程的后面的章节后会对如何实现它有更好的想法。
. 如果不用try组合符的话，你需要将目标从左边开始分解并在接下来调用parseExpr解析器自身。最后需要用一个解析器对字符串进行匹配，它要么是空要么是一个点符号加上一个单元素的表达式。这里把这个有趣的练习留给你：把它们的返回值组合成一个要么是List要么是DottedList的Either类型：你也许需要把判断逻辑分解到另外一个辅助函数里。