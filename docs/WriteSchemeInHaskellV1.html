<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.13">
<title>使用Haskell编写Scheme解释器</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/* Asciidoctor default stylesheet | MIT License | https://asciidoctor.org */
/* Uncomment @import statement to use as custom stylesheet */
/*@import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700";*/
article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section{display:block}
audio,video{display:inline-block}
audio:not([controls]){display:none;height:0}
html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}
a{background:none}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
abbr[title]{border-bottom:1px dotted}
b,strong{font-weight:bold}
dfn{font-style:italic}
hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type="button"],input[type="reset"],input[type="submit"]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,*::before,*::after{-moz-box-sizing:border-box;-webkit-box-sizing:border-box;box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;font-weight:400;font-style:normal;line-height:1;position:relative;cursor:auto;tab-size:4;word-wrap:anywhere;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:0}
p{font-family:inherit;font-weight:400;font-size:1em;line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #dddddf;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em;height:0}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{font-size:1em;line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0;font-size:1em}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
abbr,acronym{text-transform:uppercase;font-size:90%;color:rgba(0,0,0,.8);border-bottom:1px dotted #ddd;cursor:help}
abbr{text-transform:none}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:solid 1px #dedede;word-wrap:normal}
table thead,table tfoot{background:#f7f8f7}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt{background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.center{margin-left:auto;margin-right:auto}
.stretch{width:100%}
.clearfix::before,.clearfix::after,.float-group::before,.float-group::after{content:" ";display:table}
.clearfix::after,.float-group::after{clear:both}
:not(pre).nobreak{word-wrap:normal}
:not(pre).nowrap{white-space:nowrap}
:not(pre).pre-wrap{white-space:pre-wrap}
:not(pre):not([class^=L])>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background:#f7f7f8;-webkit-border-radius:4px;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed}
pre{color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;line-height:1.45;text-rendering:optimizeSpeed}
pre code,pre pre{color:inherit;font-size:inherit;line-height:inherit}
pre>code{display:block}
pre.nowrap,pre.nowrap pre{white-space:pre;word-wrap:normal}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background:#f7f7f7;border:1px solid #ccc;-webkit-border-radius:3px;border-radius:3px;-webkit-box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em white inset;box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em #fff inset;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button::before,b.button::after{position:relative;top:-1px;font-weight:400}
b.button::before{content:"[";padding:0 3px 0 2px}
b.button::after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin-left:auto;margin-right:auto;margin-top:0;margin-bottom:0;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header::before,#header::after,#content::before,#content::after,#footnotes::before,#footnotes::after,#footer::before,#footer::after{content:" ";display:table}
#header::after,#content::after,#footnotes::after,#footer::after{clear:both}
#content{margin-top:1.25em}
#content::before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #dddddf}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #dddddf;padding-bottom:8px}
#header .details{border-bottom:1px solid #dddddf;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:-ms-flexbox;display:-webkit-flex;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span::before{content:"\00a0\2013\00a0"}
#header .details br+span.author::before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark::before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber::after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #dddddf;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #e7e7e9;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #e7e7e9;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #e7e7e9;left:auto;right:0}}
@media screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:none;background:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:rgba(255,255,255,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #e7e7e9}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor::before,h2>a.anchor::before,h3>a.anchor::before,#toctitle>a.anchor::before,.sidebarblock>.content>.title>a.anchor::before,h4>a.anchor::before,h5>a.anchor::before,h6>a.anchor::before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
details,.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
details>summary:first-of-type{cursor:pointer;display:list-item;outline:none;margin-bottom:.75em}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock.fit-content>caption.title{white-space:nowrap;width:0}
.paragraph.lead>p,#preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:1.21875em;line-height:1.6;color:rgba(0,0,0,.85)}
table.tableblock #preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:inherit}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #dddddf;color:rgba(0,0,0,.6);word-wrap:anywhere}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border-style:solid;border-width:1px;border-color:#e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;-webkit-border-radius:4px;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border-style:solid;border-width:1px;border-color:#dbdbd6;margin-bottom:1.25em;padding:1.25em;background:#f3f3f2;-webkit-border-radius:4px;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock>.content>pre{-webkit-border-radius:4px;border-radius:4px;overflow-x:auto;padding:1em;font-size:.8125em}
@media screen and (min-width:768px){.literalblock pre,.listingblock>.content>pre{font-size:.90625em}}
@media screen and (min-width:1280px){.literalblock pre,.listingblock>.content>pre{font-size:1em}}
.literalblock pre,.listingblock>.content>pre:not(.highlight),.listingblock>.content>pre[class="highlight"],.listingblock>.content>pre[class^="highlight "]{background:#f7f7f8}
.literalblock.output pre{color:#f7f7f8;background:rgba(0,0,0,.9)}
.listingblock>.content{position:relative}
.listingblock code[data-lang]::before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:inherit;opacity:.5}
.listingblock:hover code[data-lang]::before{display:block}
.listingblock.terminal pre .command::before{content:attr(data-prompt);padding-right:.5em;color:inherit;opacity:.5}
.listingblock.terminal pre .command:not([data-prompt])::before{content:"$"}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;-webkit-border-radius:4px;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.prettyprint{background:#f7f7f8}
pre.prettyprint .linenums{line-height:1.45;margin-left:2em}
pre.prettyprint li{background:none;list-style-type:inherit;padding-left:0}
pre.prettyprint li code[data-lang]::before{opacity:1}
pre.prettyprint li:not(:first-child) code[data-lang]::before{display:none}
table.linenotable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.linenotable td[class]{color:inherit;vertical-align:top;padding:0;line-height:inherit;white-space:normal}
table.linenotable td.code{padding-left:.75em}
table.linenotable td.linenos{border-right:1px solid currentColor;opacity:.35;padding-right:.5em}
pre.pygments .lineno{border-right:1px solid currentColor;opacity:.35;display:inline-block;margin-right:.75em}
pre.pygments .lineno::before{content:"";margin-right:-.125em}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock:not(.excerpt)>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote::before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.75em;margin-right:.5ex;text-align:right}
.verseblock{margin:0 1em 1.25em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract blockquote::before,.quoteblock.excerpt blockquote::before,.quoteblock .quoteblock blockquote::before{display:none}
.quoteblock.abstract blockquote,.quoteblock.abstract p,.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{line-height:1.6;word-spacing:0}
.quoteblock.abstract{margin:0 1em 1.25em;display:block}
.quoteblock.abstract>.title{margin:0 0 .375em;font-size:1.15em;text-align:center}
.quoteblock.excerpt>blockquote,.quoteblock .quoteblock{padding:0 0 .25em 1em;border-left:.25em solid #dddddf}
.quoteblock.excerpt,.quoteblock .quoteblock{margin-left:0}
.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{color:inherit;font-size:1.0625rem}
.quoteblock.excerpt .attribution,.quoteblock .quoteblock .attribution{color:inherit;font-size:.85rem;text-align:left;margin-right:0}
p.tableblock:last-child{margin-bottom:0}
td.tableblock>.content{margin-bottom:1.25em;word-wrap:anywhere}
td.tableblock>.content>:last-child{margin-bottom:-1.25em}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>*>tr>*{border-width:1px}
table.grid-cols>*>tr>*{border-width:0 1px}
table.grid-rows>*>tr>*{border-width:1px 0}
table.frame-all{border-width:1px}
table.frame-ends{border-width:1px 0}
table.frame-sides{border-width:0 1px}
table.frame-none>colgroup+*>:first-child>*,table.frame-sides>colgroup+*>:first-child>*{border-top-width:0}
table.frame-none>:last-child>:last-child>*,table.frame-sides>:last-child>:last-child>*{border-bottom-width:0}
table.frame-none>*>tr>:first-child,table.frame-ends>*>tr>:first-child{border-left-width:0}
table.frame-none>*>tr>:last-child,table.frame-ends>*>tr>:last-child{border-right-width:0}
table.stripes-all tr,table.stripes-odd tr:nth-of-type(odd),table.stripes-even tr:nth-of-type(even),table.stripes-hover tr:hover{background:#f8f8f7}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
ol>li p,ul>li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
ul.checklist{margin-left:.625em}
ul.checklist li>p:first-child>.fa-square-o:first-child,ul.checklist li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist li>p:first-child>input[type="checkbox"]:first-child{margin-right:.25em}
ul.inline{display:-ms-flexbox;display:-webkit-box;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
td.hdlist2{word-wrap:anywhere}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:solid 4px #fff;-webkit-box-shadow:0 0 0 1px #ddd;box-shadow:0 0 0 1px #ddd}
.imageblock.left{margin:.25em .625em 1.25em 0}
.imageblock.right{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em;border-width:1px 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
.gist .file-data>table{border:0;background:#fff;width:100%;margin-bottom:0}
.gist .file-data>table td.line-data{width:99%}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background:#00fafa}
.black{color:#000}
.black-background{background:#000}
.blue{color:#0000bf}
.blue-background{background:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background:#fa00fa}
.gray{color:#606060}
.gray-background{background:#7d7d7d}
.green{color:#006000}
.green-background{background:#007d00}
.lime{color:#00bf00}
.lime-background{background:#00fa00}
.maroon{color:#600000}
.maroon-background{background:#7d0000}
.navy{color:#000060}
.navy-background{background:#00007d}
.olive{color:#606000}
.olive-background{background:#7d7d00}
.purple{color:#600060}
.purple-background{background:#7d007d}
.red{color:#bf0000}
.red-background{background:#fa0000}
.silver{color:#909090}
.silver-background{background:#bcbcbc}
.teal{color:#006060}
.teal-background{background:#007d7d}
.white{color:#bfbfbf}
.white-background{background:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background:rgba(0,0,0,.8);-webkit-border-radius:50%;border-radius:50%;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]::after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,span.alt{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background:#fffef7;border-color:#e0e0dc;-webkit-box-shadow:0 1px 4px #e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@page{margin:1.25cm .75cm}
@media print{*{-webkit-box-shadow:none!important;box-shadow:none!important;text-shadow:none!important}
html{font-size:80%}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare)::after,a[href^="https:"]:not(.bare)::after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]::after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#header,#content,#footnotes,#footer{max-width:none}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #dddddf!important;padding-bottom:0!important}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span::before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]::before{display:block}
#footer{padding:0 .9375em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
@media print,amzn-kf8{#header>h1:first-child{margin-top:1.25rem}
.sect1{padding:0!important}
.sect1+.sect1{border:0}
#footer{background:none}
#footer-text{color:rgba(0,0,0,.6);font-size:.9em}}
@media amzn-kf8{#header,#content,#footnotes,#footer{padding:0}}
</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<style>
pre { line-height: 125%; }
td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
span.linenos { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
td.linenos .special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
span.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
pre.pygments .hll { background-color: #ffffcc }
pre.pygments { background: #f8f8f8; }
pre.pygments .tok-c { color: #408080; font-style: italic } /* Comment */
pre.pygments .tok-err { border: 1px solid #FF0000 } /* Error */
pre.pygments .tok-k { color: #008000; font-weight: bold } /* Keyword */
pre.pygments .tok-o { color: #666666 } /* Operator */
pre.pygments .tok-ch { color: #408080; font-style: italic } /* Comment.Hashbang */
pre.pygments .tok-cm { color: #408080; font-style: italic } /* Comment.Multiline */
pre.pygments .tok-cp { color: #BC7A00 } /* Comment.Preproc */
pre.pygments .tok-cpf { color: #408080; font-style: italic } /* Comment.PreprocFile */
pre.pygments .tok-c1 { color: #408080; font-style: italic } /* Comment.Single */
pre.pygments .tok-cs { color: #408080; font-style: italic } /* Comment.Special */
pre.pygments .tok-gd { color: #A00000 } /* Generic.Deleted */
pre.pygments .tok-ge { font-style: italic } /* Generic.Emph */
pre.pygments .tok-gr { color: #FF0000 } /* Generic.Error */
pre.pygments .tok-gh { color: #000080; font-weight: bold } /* Generic.Heading */
pre.pygments .tok-gi { color: #00A000 } /* Generic.Inserted */
pre.pygments .tok-go { color: #888888 } /* Generic.Output */
pre.pygments .tok-gp { color: #000080; font-weight: bold } /* Generic.Prompt */
pre.pygments .tok-gs { font-weight: bold } /* Generic.Strong */
pre.pygments .tok-gu { color: #800080; font-weight: bold } /* Generic.Subheading */
pre.pygments .tok-gt { color: #0044DD } /* Generic.Traceback */
pre.pygments .tok-kc { color: #008000; font-weight: bold } /* Keyword.Constant */
pre.pygments .tok-kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
pre.pygments .tok-kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
pre.pygments .tok-kp { color: #008000 } /* Keyword.Pseudo */
pre.pygments .tok-kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
pre.pygments .tok-kt { color: #B00040 } /* Keyword.Type */
pre.pygments .tok-m { color: #666666 } /* Literal.Number */
pre.pygments .tok-s { color: #BA2121 } /* Literal.String */
pre.pygments .tok-na { color: #7D9029 } /* Name.Attribute */
pre.pygments .tok-nb { color: #008000 } /* Name.Builtin */
pre.pygments .tok-nc { color: #0000FF; font-weight: bold } /* Name.Class */
pre.pygments .tok-no { color: #880000 } /* Name.Constant */
pre.pygments .tok-nd { color: #AA22FF } /* Name.Decorator */
pre.pygments .tok-ni { color: #999999; font-weight: bold } /* Name.Entity */
pre.pygments .tok-ne { color: #D2413A; font-weight: bold } /* Name.Exception */
pre.pygments .tok-nf { color: #0000FF } /* Name.Function */
pre.pygments .tok-nl { color: #A0A000 } /* Name.Label */
pre.pygments .tok-nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
pre.pygments .tok-nt { color: #008000; font-weight: bold } /* Name.Tag */
pre.pygments .tok-nv { color: #19177C } /* Name.Variable */
pre.pygments .tok-ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
pre.pygments .tok-w { color: #bbbbbb } /* Text.Whitespace */
pre.pygments .tok-mb { color: #666666 } /* Literal.Number.Bin */
pre.pygments .tok-mf { color: #666666 } /* Literal.Number.Float */
pre.pygments .tok-mh { color: #666666 } /* Literal.Number.Hex */
pre.pygments .tok-mi { color: #666666 } /* Literal.Number.Integer */
pre.pygments .tok-mo { color: #666666 } /* Literal.Number.Oct */
pre.pygments .tok-sa { color: #BA2121 } /* Literal.String.Affix */
pre.pygments .tok-sb { color: #BA2121 } /* Literal.String.Backtick */
pre.pygments .tok-sc { color: #BA2121 } /* Literal.String.Char */
pre.pygments .tok-dl { color: #BA2121 } /* Literal.String.Delimiter */
pre.pygments .tok-sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
pre.pygments .tok-s2 { color: #BA2121 } /* Literal.String.Double */
pre.pygments .tok-se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
pre.pygments .tok-sh { color: #BA2121 } /* Literal.String.Heredoc */
pre.pygments .tok-si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
pre.pygments .tok-sx { color: #008000 } /* Literal.String.Other */
pre.pygments .tok-sr { color: #BB6688 } /* Literal.String.Regex */
pre.pygments .tok-s1 { color: #BA2121 } /* Literal.String.Single */
pre.pygments .tok-ss { color: #19177C } /* Literal.String.Symbol */
pre.pygments .tok-bp { color: #008000 } /* Name.Builtin.Pseudo */
pre.pygments .tok-fm { color: #0000FF } /* Name.Function.Magic */
pre.pygments .tok-vc { color: #19177C } /* Name.Variable.Class */
pre.pygments .tok-vg { color: #19177C } /* Name.Variable.Global */
pre.pygments .tok-vi { color: #19177C } /* Name.Variable.Instance */
pre.pygments .tok-vm { color: #19177C } /* Name.Variable.Magic */
pre.pygments .tok-il { color: #666666 } /* Literal.Number.Integer.Long */
</style>
</head>
<body class="article toc2 toc-left">
<div id="header">
<h1>使用Haskell编写Scheme解释器</h1>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_概论">1. 概论</a></li>
<li><a href="#_第一步编译然后运行程序">2. 第一步：编译然后运行程序</a></li>
<li><a href="#_解析">3. 解析</a>
<ul class="sectlevel2">
<li><a href="#_一个简单的解析器">3.1. 一个简单的解析器</a></li>
<li><a href="#_空格">3.2. 空格</a></li>
<li><a href="#_返回值">3.3. 返回值</a></li>
<li><a href="#_习题">3.4. 习题</a></li>
<li><a href="#_递归解析列表和引号">3.5. 递归解析：列表和引号</a></li>
<li><a href="#_习题_2">3.6. 习题</a></li>
</ul>
</li>
<li><a href="#_求值第一部分">4. 求值：第一部分</a>
<ul class="sectlevel2">
<li><a href="#_开始求值">4.1. 开始求值</a></li>
<li><a href="#_开始求值初版">4.2. 开始求值：初版</a></li>
<li><a href="#_添加基本操作">4.3. 添加基本操作</a></li>
<li><a href="#_习题_3">4.4. 习题</a></li>
</ul>
</li>
<li><a href="#_错误检查和异常处理">5. 错误检查和异常处理</a></li>
<li><a href="#_求值第二部分">6. 求值：第二部分</a>
<ul class="sectlevel2">
<li><a href="#_更多操作部分应用">6.1. 更多操作：部分应用</a></li>
<li><a href="#_条件模式匹配">6.2. 条件：模式匹配</a></li>
<li><a href="#_列表操作carcdr和cons">6.3. 列表操作：car、cdr和cons</a></li>
<li><a href="#_equal和弱类型异构列表">6.4. equal?和弱类型：异构列表</a></li>
<li><a href="#_习题_4">6.5. 习题</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="_概论">1. 概论</h2>
<div class="sectionbody">
<div class="paragraph">
<p>大部分网路上的Haskell教程会使用一种与语言参考手册类似的方式来进行教学。他们会告诉你语法和一些语言结构，然后让你在交互式命令行里写一些简单的函数。而如何用函数式的方式来写一个有用的程序的问题却被留在了最后面或是直接被忽略了。</p>
</div>
<div class="paragraph">
<p>而我们会用一种完全不同的方式。你会从使用和解析命令行参数开始，然后写一个能够实现R5RS Scheme标准的像模像样的子集的Scheme解释器。你将会学习到Haskell的I/O，可变状态，动态类型，错误处理以及其他相关的解析功能。而当你完成这个教程的时候，你就会对Haskell和Scheme相当熟悉了。</p>
</div>
<div class="paragraph">
<p>这个教程主要面向两大读者群：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>已经掌握Lisp或Scheme并且想要学习Haskell的人</p>
</li>
<li>
<p>虽然不懂任何编程语言，但是有大量背景知识并且对计算机非常熟悉的人</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>第二种读者会发现这个任务有些困难，因为在这里省略了很多Scheme以及其他通用的编程概念从而把教程的重点放在Haskell上面。SICP或者The Little Schemer之类的书会对你很有帮助。</p>
</div>
<div class="paragraph">
<p>而那些使用像C，Java或者Python这样的基于过程或面向对象语言的用户需要注意了：你需要忘掉大部分你已经熟悉的编程知识。Haskell与上述的语言完全不同，并且要求你用一种完全不一样的方式来进行思考。最好以白板的状态来开始这个教程并且不要尝试将Haskell与命令式语言进行比较，因为很多你以为你熟悉的概念（classes，functions，return）在Haskell里有完全不同的含义。</p>
</div>
<div class="paragraph">
<p>由于每一课都建立在之前代码的基础上，所以你最好按顺序来学习课程。</p>
</div>
<div class="paragraph">
<p>这个教程假定你用ghc作为你的Haskell编译器。代码在Hugs或者其他编译器里或许也能运行但并没有被完全测试过，也许你还需要下载一些额外的库来支持他们。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第一步编译然后运行程序">2. 第一步：编译然后运行程序</h2>
<div class="sectionbody">
<div class="paragraph">
<p>首先，你需要安装一个ghc。在Linux上，它常常被预先安装好了或者能够通过apt-get或者yum命令来轻松搞定。你也可以从官网直接下载它。不过除非你确信你想从源码去编译它，否则下载一个二进制包就可以了。像安装其他的软件包一样下载和安装它既可。这个教程是在Linux下完成的，但是只要你会使用相关的命令行操作，它在Windows或是Mac环境下也一样能工作。</p>
</div>
<div class="paragraph">
<p>对UNIX或者Windows Emacs用户来说，这里有一个很棒的Emacs mode，包括了语法高亮和自动缩进的功能。Windows用户则能够直接使用记事本或者其他文本编辑器：Haskell的语法对记事本相当友好，尽管你仍要小心处理缩进。Eclipse用户建议使用eclipsefp插件。</p>
</div>
<div class="paragraph">
<p>现在，是时候写你的第一个Haskell程序了。这个程序将通过命令行读入一个名字然后输出一个问候语句。建立一个以 ".hs” 结尾的文件并输入下列代码。当心缩进，否则你的程序可能没法通过编译。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="haskell"><span></span><span class="tok-kr">module</span> <span class="tok-nn">Main</span> <span class="tok-kr">where</span>
<span class="tok-kr">import</span> <span class="tok-nn">System.Environment</span>

<span class="tok-nf">main</span> <span class="tok-ow">::</span> <span class="tok-kt">IO</span> <span class="tok-nb">()</span>
<span class="tok-nf">main</span> <span class="tok-ow">=</span> <span class="tok-kr">do</span> <span class="tok-n">args</span> <span class="tok-ow">&lt;-</span> <span class="tok-n">getArgs</span>
          <span class="tok-n">putStrLn</span> <span class="tok-p">(</span><span class="tok-s">&quot;Hello, &quot;</span> <span class="tok-o">++</span> <span class="tok-n">args</span> <span class="tok-o">!!</span> <span class="tok-mi">0</span><span class="tok-p">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>我们来看下这段代码。前两行表示我们讲创建一个名叫Main的模块，并且导入了System这个模块。所有的Haskell程序都会从Main模块里的一个叫做main函数的地方开始运行。你可以在这个模块中导入其他的模块，但是如果没有了它，编译器就无法生成可执行文件供用户运行。此外Haskell是大小写的敏感的：模块名称需要是大写开头的，而函数声明则必须是非大写开头的。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">main </dt>
<dd>
<p>IO ()这行是函数的类型声明：它表示main函数的类型是IO()，是一个返回Unit类型()的IO操作。一个Unit类型仅会包含一个值，而()，它表示什么也没有。类型声明在Haskell里是可选的：编译器能够自动的识别它们，当你的声明和编译器自动识别发生冲突的时候它则会报错。在这个教程中，为了更清晰的说明，所有的类型都是显式声明的。而你在家里跟着做的时候，你可能更愿意选择忽略，因为在编写这个程序的时候其实并不太需要去在意它们。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>IO类型是Monad类型类的一个实例，Monad是一种抽象的概念，如果满足以下这两个条件，那我们就会说这样的值是Monad：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>这个值包含了一些特定类型的附加信息；</p>
</li>
<li>
<p>大多数函数不需要去关心这些附加的信息。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>在这个例子里，</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>这个附加的信息就是将被执行的IO操作；</p>
</li>
<li>
<p>而这个附加信息的值是不存在的，表示成 <code>()</code> 。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p><code>IO[String]</code> 和 <code>IO()</code> 都同样属于 <code>IO Monad</code> 类型，但它们有着不同的基本类型。它们作用于 <code>(</code> 或是传递 <code>)</code> 不同类型的值， <code>[String]</code> 和 <code>()</code> 。</p>
</div>
<div class="paragraph">
<p>那些包含了附加信息的值则被称作“Monadic”。</p>
</div>
<div class="paragraph">
<p>Monadic值常被称作“操作”，因为最容易的思考IO Monad用途的方法就是把它当做一系列可能会影响外界世界的动作。这一系列动作会传递一些基础的数值，然后在这个过程中每个动作都会对这些值进行影响。</p>
</div>
<div class="paragraph">
<p>Haskell是一个函数式的语言：与给出计算机一系列指令从而让它执行不同，你需要给Haskell一系列定义来告诉它每一个函数来如何处理。这些定义会将各种动作和函数组合在一起。而编译器会识别出将它们组织在一起的执行方式。</p>
</div>
<div class="paragraph">
<p>要写出这样一个定义，你首先需要建立一个等式。等式的左边是一个名称，可能还会带有若干个与变量绑定的模式(后面会解释)。右边的话，会给出一些由其他定义组合而成的式子，从而告诉计算机如何遇到该定义时如何进行计算。这些等式就和一般的代数表达式一样：你总是可以在程序中用等式右边的部分来替代左边的名字，并且得到与之前相同的结果。这种行为被称作“引用透明”，而这种性质使得Haskell代码比其它的语言更加易于理解。</p>
</div>
<div class="paragraph">
<p>那我们应该怎么定义我们的main函数呢？我们知道它必须是一个能够从命令行读入参数，然后从打印出一些输出，最终返回()（空值）的IO()操作。</p>
</div>
<div class="paragraph">
<p>这里有两种方法创建一个IO操作：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>使用return函数提升一个普通值进入IO Monad。</p>
</li>
<li>
<p>连接两个已经存在的IO操作。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>因为我们接下来要做两件事情，所以我们选择第二种方法。我们通过内建函数getArgs读入命令行参数并把它们存入一个字符串列表。而内建函数putStrLn则能够读入一个字符串然后将它输出到终端。</p>
</div>
<div class="paragraph">
<p>我们使用一个do代码块来连接这两个操作。一个do代码块包括很多行，所有的行按照第一个非空白字符在do后面排列，并且每行都可能是如下两种形式之一：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>name &#8592; action1</p>
</li>
<li>
<p>action2</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>第一种形式将action1的结果和name绑定，从而你可以在下一个操作中使用它。例如，如果有action1的类型是IO[String](一个会返回一个字符串列表的IO操作，就和getArgs一样)，那name就会在接下来的一系列操作里和这个返回的字符串列表通过绑定操作符&gt;&gt;=绑定在一起。第二种情况仅仅执行这个action2，并通过&gt;&gt;操作符同下一行连结在一起。绑定操作符在处理不同Monad的情况下有不同的语义：在IO Monad中，它会连续执行所有的操作，然后对外部世界产生这些操作带来的副作用。由于这个绑定符号的语义依赖你具体使用的Monad类型，所以你并不能在同一个do代码块里把不同类型的Monad类型的操作糅杂在一起---在这里只有IO Monad是可用的（在同一个管道中）。</p>
</div>
<div class="paragraph">
<p>当然，这些操作可能自己会调用其他函数或是复杂的表达式，然后继续传递它们的计算结果（通过调用return或是其他最终调用了return的函数）。</p>
</div>
<div class="paragraph">
<p>在这个例子里，我们首先取出参数列表中的第一个元素(args !! 0)，然后把它拼接到字符串"Hello,"的后面（"Hello," ++），最后把结果传给putStrLn。</p>
</div>
<div class="paragraph">
<p>就这样，一个包含了之前所说的读取和打印操作的新的操作就这样创建完毕并存到了main这个返回值为IO()的标识符中。这样Haskell系统就能够识别并运行它了。</p>
</div>
<div class="paragraph">
<p>Haskell中，字符串即是字符的列表形式，所以你可以对它使用任何的列表函数或是操作符。以下是一个完整的标准操作符列表和它们对应的优先级：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./haskell-cheatsheet.png" alt="haskell cheatsheet">
</div>
</div>
<div class="paragraph">
<p>接下来编译和运行这个程序：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="bash"><span></span>$ ghc -o hello_you --make listing2.hs
$ ./hello_you Jonathan
Hello, Jonathan</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>习题</strong></p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>修改程序，让它能够从命令行读取两个参数然后打印出一条包含它们的信息。</p>
</li>
<li>
<p>修改程序，让它能够使用输入的参数进行简单的四则运算，建议使用read来讲字符串转化成数字类型，并用show来进行相反的操作。对各种不同的动作都操练一番。</p>
</li>
<li>
<p>getLine是一个从命令行读取一行输入信息然后返回字符串的IO操作。修改程序，让它能够提示需要一个名字并读取这个名字而不是像之前那样直接从命令行传入参数，最后打印它。</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_解析">3. 解析</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_一个简单的解析器">3.1. 一个简单的解析器</h3>
<div class="paragraph">
<p>现在，让我们试着写一个非常简单的解析器。我们会用到Parsec库。（如果你还没有安装的话，可以通过Haskell平台下载或者直接使用它的源代码。根据你的编译器的版本，选择对应的代码包并编译它。在Ubuntu系统上的话，直接运行命令sudo apt-get install cabal-install;cabal update;cabal install parsec来安装）</p>
</div>
<div class="paragraph">
<p>添加一行到导入模块的部分：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="haskell"><span></span><span class="tok-kr">import</span> <span class="tok-nn">Text.ParserCombinators.Parsec</span> <span class="tok-k">hiding</span> <span class="tok-p">(</span><span class="tok-nf">spaces</span><span class="tok-p">)</span>
<span class="tok-kr">import</span>  <span class="tok-nn">System.Environment</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>这样我们就可以使用Parsec库中的函数了，除了一个等下会和我们自己定义的函数名冲突的spaces函数。</p>
</div>
<div class="paragraph">
<p>现在让我们定义一个能够识别出Scheme中允许的符号的解析器：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="haskell"><span></span><span class="tok-nf">symbol</span> <span class="tok-ow">::</span> <span class="tok-kt">Parser</span> <span class="tok-kt">Char</span>
<span class="tok-nf">symbol</span> <span class="tok-ow">=</span> <span class="tok-n">oneOf</span> <span class="tok-s">&quot;!#$%&amp;|*+-/:&lt;=&gt;?@^_~&quot;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>这又是一个Monad的例子：在这里，被隐藏的“额外信息”包括在输入流中的位置，回溯记录以及First和Follow集等。Parsec会替我们解决这个问题。而我们只需要去调用Parsec库中的函数oneOf，它就会替我们将传递给它的字符串中的任意一个识别出来。Parsec库提供了一些内置的解析器：例如letter和digit函数。正如你将看到的，你可以将基本的函数组合成更加复杂的解析器。</p>
</div>
<div class="paragraph">
<p>让我们定义一个调用解析器并且处理可能的错误的函数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="haskell"><span></span><span class="tok-nf">readExpr</span> <span class="tok-ow">::</span> <span class="tok-kt">String</span> <span class="tok-ow">-&gt;</span> <span class="tok-kt">String</span>
<span class="tok-nf">readExpr</span> <span class="tok-n">input</span> <span class="tok-ow">=</span> <span class="tok-kr">case</span> <span class="tok-n">parse</span> <span class="tok-n">symbol</span> <span class="tok-s">&quot;lisp&quot;</span> <span class="tok-n">input</span> <span class="tok-kr">of</span>
    <span class="tok-kt">Left</span> <span class="tok-n">err</span> <span class="tok-ow">-&gt;</span> <span class="tok-s">&quot;No match: &quot;</span> <span class="tok-o">++</span> <span class="tok-n">show</span> <span class="tok-n">err</span>
    <span class="tok-kt">Right</span> <span class="tok-n">val</span> <span class="tok-ow">-&gt;</span> <span class="tok-s">&quot;Found value&quot;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>正如你从类型签名看到的一样，readExpr是一个将String转化成String的函数（&#8594;）。我们把传入的参数命名为input，然后把它和我们之前定义的名叫symbol的解析器一起传递给parse函数。传递的第二个参数是我们给输入定义的名称，这会在显示错误信息的时候用到。parse会返回一个被解析的返回值或者一个错误，因此我们是需要处理错误情况的。根据标准的Haskell编程规约，Parsec返回一个Either类型，用他得Left构造器表示错误并且用Right构造器来表示普通的值。</p>
</div>
<div class="paragraph">
<p>我们使用一个case&#8230;&#8203;of的语句来对parse的各种可能的返回值进行匹配。如果我们得到一个Left值（错误），那我们就把这个error绑定给变量err然后在开头加上字符串“No match ”然后返回。如果我们得到一个Right值，我们把它绑定给val，然后无视它并返回一个“Found value”字符串。</p>
</div>
<div class="paragraph">
<p>我们可以看到使用case&#8230;&#8203;of来进行模式匹配的例子，之后我们会继续看到很多类似的做法的。</p>
</div>
<div class="paragraph">
<p>最后，我们需要修改我们的main函数来调用readExpr并且打印出结果：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="haskell"><span></span><span class="tok-nf">main</span> <span class="tok-ow">::</span> <span class="tok-kt">IO</span> <span class="tok-nb">()</span>
<span class="tok-nf">main</span> <span class="tok-ow">=</span> <span class="tok-kr">do</span>
    <span class="tok-p">(</span><span class="tok-n">expr</span><span class="tok-kt">:</span><span class="tok-kr">_</span><span class="tok-p">)</span> <span class="tok-ow">&lt;-</span> <span class="tok-n">getArgs</span>
    <span class="tok-n">putStrLn</span> <span class="tok-p">(</span><span class="tok-n">readExpr</span> <span class="tok-n">expr</span><span class="tok-p">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>为了编译并运行程序，需要在命令行指定&#8212;&#8203;make参数，否则就会爆出链接错误。举个栗子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="bash"><span></span>$ ghc --make -o simple_parser listing3.1.hs
$ ./simple_parser $
Found value
$ ./simple_parser a
No match: <span class="tok-s2">&quot;lisp&quot;</span> <span class="tok-o">(</span>line <span class="tok-m">1</span>, column <span class="tok-m">1</span><span class="tok-o">)</span>:
unexpected <span class="tok-s2">&quot;a&quot;</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_空格">3.2. 空格</h3>
<div class="paragraph">
<p>接下来，我们会对我们的解析器添加一系列改动来使它能够渐渐识别出我们给出的更加复杂的表达式。现在的解析器在遇到空白的时候就会卡住了：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="bash"><span></span>$ ./simple_parser <span class="tok-s2">&quot;   %&quot;</span>
No match: <span class="tok-s2">&quot;lisp&quot;</span> <span class="tok-o">(</span>line <span class="tok-m">1</span>, column <span class="tok-m">1</span><span class="tok-o">)</span>:
unexpected <span class="tok-s2">&quot; &quot;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>让我们来修正这个问题，并且忽略掉输入中的空格符。</p>
</div>
<div class="paragraph">
<p>首先，我们定义一个能够辨认出任意数量空格的解析器。顺便，这也是我们之前在导入Parsec模块的时候添加了hiding (spaces)的原因：模块中已经有一个spaces
函数了，但却不大符合我们的要求。（不过有一个叫做lexeme的解析器完全符合我们的要求，不过出于教学目的，我们暂时先无视它。）</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="haskell"><span></span><span class="tok-nf">spaces</span> <span class="tok-ow">::</span> <span class="tok-kt">Parser</span> <span class="tok-nb">()</span>
<span class="tok-nf">spaces</span> <span class="tok-ow">=</span> <span class="tok-n">skipMany1</span> <span class="tok-n">space</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>就像函数一样，操作也能传递给其他操作。在这里我们把Parser操作space 传递给Parser操作skipMany1，来获取到一个能够解析一个或者多个空格的解析器。</p>
</div>
<div class="paragraph">
<p>现在，我们来编辑一下我们的解析函数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="haskell"><span></span><span class="tok-nf">readExpr</span> <span class="tok-n">input</span> <span class="tok-ow">=</span> <span class="tok-kr">case</span> <span class="tok-n">parse</span> <span class="tok-p">(</span><span class="tok-n">spaces</span> <span class="tok-o">&gt;&gt;</span> <span class="tok-n">symbol</span><span class="tok-p">)</span> <span class="tok-s">&quot;lisp&quot;</span> <span class="tok-n">input</span> <span class="tok-kr">of</span>
    <span class="tok-kt">Left</span> <span class="tok-n">err</span> <span class="tok-ow">-&gt;</span> <span class="tok-s">&quot;No match: &quot;</span> <span class="tok-o">++</span> <span class="tok-n">show</span> <span class="tok-n">err</span>
    <span class="tok-kt">Right</span> <span class="tok-n">val</span> <span class="tok-ow">-&gt;</span> <span class="tok-s">&quot;Found value&quot;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>我们在第二课里简单看过一点关于&gt;&gt;("bind")操作符的内容，并且提到我们是把它放在do代码块中的每行的行尾来起到连接作用的。这里，我们显式的使用它来将我们的空格解析器和之前的符合解析器组合起来。然而，相比IO Monad绑定在Parser中有着完全不同的语义。
对于Parser Monad来说，绑定意味着“尝试匹配第一个解析器，然后用剩下的输入尝试匹配第二个，如果任意一次匹配失败的话，就返回失败”。总的来说，绑定在具体的Monad中会起到不同的效果；它被用作一种通用的组织计算的方式，所以能够适应各种不同的情况。你可以阅读对应的文档来判断出它到底会干什么。</p>
</div>
<div class="paragraph">
<p>编译并且运行代码。请注意我们这里的spaces函数是基于skipMany1定义的，他不会再像之前那样能够识别出单个的字符。因此你必须放一些空格在输入字符的前面。看下现在代码是如何运作的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="bash"><span></span>$ ghc -package parsec -o simple_parser <span class="tok-o">[</span>../code/listing3.2.hs listing3.2.hs<span class="tok-o">]</span>
$ ./simple_parser <span class="tok-s2">&quot;   %&quot;</span>
Found value
$ ./simple_parser %
No match: <span class="tok-s2">&quot;lisp&quot;</span> <span class="tok-o">(</span>line <span class="tok-m">1</span>, column <span class="tok-m">1</span><span class="tok-o">)</span>:
unexpected <span class="tok-s2">&quot;%&quot;</span>
expecting space
$ ./simple_parser <span class="tok-s2">&quot;   abc&quot;</span>
No match: <span class="tok-s2">&quot;lisp&quot;</span> <span class="tok-o">(</span>line <span class="tok-m">1</span>, column <span class="tok-m">4</span><span class="tok-o">)</span>:
unexpected <span class="tok-s2">&quot;a&quot;</span>
expecting space</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_返回值">3.3. 返回值</h3>
<div class="paragraph">
<p>现在，我们的解析器还并不能做些什么---它仅仅是告诉我们一个给定的字符串是否能够被识别。现在，我们想让它能够做更多的事情：我们希望它能够将输入的字符串转换成一个特定的数据结构并让我们可以容易的遍历它。在这一节，我们将学习如何定义一个数据类型，并且修改我们的解析器让它能够返回该数据类型。</p>
</div>
<div class="paragraph">
<p>首先，我们来定义一个包含所有各种Lisp值的数据类型：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="haskell"><span></span><span class="tok-kr">data</span> <span class="tok-kt">LispVal</span> <span class="tok-ow">=</span> <span class="tok-kt">Atom</span> <span class="tok-kt">String</span>
             <span class="tok-o">|</span> <span class="tok-kt">List</span> <span class="tok-p">[</span><span class="tok-kt">LispVal</span><span class="tok-p">]</span>
             <span class="tok-o">|</span> <span class="tok-kt">DottedList</span> <span class="tok-p">[</span><span class="tok-kt">LispVal</span><span class="tok-p">]</span> <span class="tok-kt">LispVal</span>
             <span class="tok-o">|</span> <span class="tok-kt">Number</span> <span class="tok-kt">Integer</span>
             <span class="tok-o">|</span> <span class="tok-kt">String</span> <span class="tok-kt">String</span>
             <span class="tok-o">|</span> <span class="tok-kt">Bool</span> <span class="tok-kt">Bool</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>这是一个代数数据类型的例子：它定义了一组LispVal类型的变量可能存储的值。每一个可能性（通过“|”符号分割的构造器）包含了一个代表构造器的标识符和这个构造器能够接受的一系列数据类型。在这里，一个LispVal可能是：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Atom。存储了一个用来命名它的字符串</p>
</li>
<li>
<p>List。其中存储了一组其他LispVal（Haskell列表用方括号表示），也被称为Proper List。</p>
</li>
<li>
<p>DottedList。对应Scheme中的(a b . c)形式。也被称作Improper List。存储了除最后一个元素以外的所有元素，然后再把最后一个元素额外存储起来。</p>
</li>
<li>
<p>Number。包含一个Haskell数字。</p>
</li>
<li>
<p>String。包含一个Haskell字符串。</p>
</li>
<li>
<p>Bool。包含一个Haskell布尔值。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>构造器和类型使用的是不同的命名空间，所以你同时将一个类型名和构造器都定义成String，并没有问题。唯一要注意的是，它们都需要以大写字母开头。</p>
</div>
<div class="paragraph">
<p>接下来，我们来添加一些解析函数来返回对应的不同类型。一个字符串总是一个以双引号开头，然后接着一串不包含双引号的字符，最终以另一个双引号结束：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="haskell"><span></span><span class="tok-nf">parseString</span> <span class="tok-ow">::</span> <span class="tok-kt">Parser</span> <span class="tok-kt">LispVal</span>
<span class="tok-nf">parseString</span> <span class="tok-ow">=</span> <span class="tok-kr">do</span>
                <span class="tok-n">char</span> <span class="tok-sc">&#39;&quot;&#39;</span>
                <span class="tok-n">x</span> <span class="tok-ow">&lt;-</span> <span class="tok-n">many</span> <span class="tok-p">(</span><span class="tok-n">noneOf</span> <span class="tok-s">&quot;</span><span class="tok-se">\\</span><span class="tok-s">&quot;&quot;)</span>
<span class="tok-s">                char &#39;&quot;</span><span class="tok-sc">&#39;</span>
                <span class="tok-n">return</span> <span class="tok-o">$</span> <span class="tok-kt">String</span> <span class="tok-n">x</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>我们再次使用do表达式而不是&gt;&gt;操作符来组织代码。只是因为我们需要获取解析得到的值（many (noneOf "\\"")的返回值）并且同时使用一些其他的解析操作。总的来说，对于不返回值得操作，使用&gt;&gt;符号，对于你需要立刻将返回的值传递到下一个操作的情况，使用&gt;&gt;=，其余的情况则用do代码块比较好。</p>
</div>
<div class="paragraph">
<p>当我们完成解析并从many函数中获取Haskell字符串时，我们调用了String构造器（LispVal数据类型）来把它转化成一个LispVal类型的值。每一个在代数数据类型中的构造器都能够像函数一样将传递给它的参数转化成它对应的类型。构造器还能够在模式匹配中作为左手边的匹配表达式进行使用；我们会在第三课里尝试将解析器返回的结果分别用Either类型的两种构造器进行匹配。</p>
</div>
<div class="paragraph">
<p>接着我们使用内置的return函数将我们的LispVal值lift成一个Parser Monad。注意，do代码块中的每行都必须有同样的类型，然而由于我们的String构造器的返回结果是LispVal类型，因此我们要利用return帮助将它风中成一个Parser操作并且在不消费任何输入的情况下直接将内部的值进行返回。这样我们的整个parserString操作就能够得到Parser LispVal类型的返回值了。</p>
</div>
<div class="paragraph">
<p>$符号是一个中缀函数呼叫符：它和我们直接使用return (String x)的作用一样，但是$是右结合的，并且运行的优先级较低，这样让我们能够省略掉一些原来需要写得括号。由于$是一个操作符，你可以像使用函数那样使用它做任何事情：传递它，部分调用等。在这个方面，它和Lisp中的apply函数功能一致。</p>
</div>
<div class="paragraph">
<p>现在继续来看Scheme的变量。一个atom是一个字母或者符号，跟着若干个字母，数字或者符号：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="haskell"><span></span><span class="tok-nf">parseAtom</span> <span class="tok-ow">::</span> <span class="tok-kt">Parser</span> <span class="tok-kt">LispVal</span>
<span class="tok-nf">parseAtom</span> <span class="tok-ow">=</span> <span class="tok-kr">do</span>
              <span class="tok-n">first</span> <span class="tok-ow">&lt;-</span> <span class="tok-n">letter</span> <span class="tok-o">&lt;|&gt;</span> <span class="tok-n">symbol</span>
              <span class="tok-n">rest</span> <span class="tok-ow">&lt;-</span> <span class="tok-n">many</span> <span class="tok-p">(</span><span class="tok-n">letter</span> <span class="tok-o">&lt;|&gt;</span> <span class="tok-n">digit</span> <span class="tok-o">&lt;|&gt;</span> <span class="tok-n">symbol</span><span class="tok-p">)</span>
              <span class="tok-kr">let</span> <span class="tok-n">atom</span> <span class="tok-ow">=</span> <span class="tok-n">first</span><span class="tok-kt">:</span><span class="tok-n">rest</span>
              <span class="tok-n">return</span> <span class="tok-o">$</span> <span class="tok-kr">case</span> <span class="tok-n">atom</span> <span class="tok-kr">of</span>
                         <span class="tok-s">&quot;#t&quot;</span> <span class="tok-ow">-&gt;</span> <span class="tok-kt">Bool</span> <span class="tok-kt">True</span>
                         <span class="tok-s">&quot;#f&quot;</span> <span class="tok-ow">-&gt;</span> <span class="tok-kt">Bool</span> <span class="tok-kt">False</span>
                         <span class="tok-kr">_</span>    <span class="tok-ow">-&gt;</span> <span class="tok-kt">Atom</span> <span class="tok-n">atom</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>这里我们来看下另一个Parsec的组合符，选择符&lt;|&gt;。它会让我们首先尝试第一个解析器，如果它失败了，然后尝试第二个。如果任意一个成功了，那就会返回成功解析出得值。第一个解析器必须在它消费掉任何输入前失败返回：我们待会儿来看看如何用它来实现回溯。</p>
</div>
<div class="paragraph">
<p>一旦我们读到第一个字符和并成功读完剩下的部分，我们需要把它们放在一起组成一个atom。let声明定义了一个新的变量atom。我们使用列表连接符:来连接它们。和:相对应的，我们使用连接符像这样来连接列表[first]rest；first只是一个字符，我们可以用方括号包围它来将它转换成一个单元素的列表。</p>
</div>
<div class="paragraph">
<p>然后我们使用一个case表达式来尝试将字符串匹配成true和false，从而判断到底是应该创建和返回哪种LispVal类型。下划线符号\是一个可读性的技巧：目标会不断尝试匹配case块中的值直到遇到\（或者在此之前就因为某些异常失败了从而导致整个匹配失败）并作为一个通配符返回。因此如果代码运行到_条件下，它总是会匹配并且返回一个atom值。</p>
</div>
<div class="paragraph">
<p>最后，我们再为数字创建一个解析器。这里会展示更多的方法来处理monadic值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="haskell"><span></span><span class="tok-nf">parseNumber</span> <span class="tok-ow">::</span> <span class="tok-kt">Parser</span> <span class="tok-kt">LispVal</span>
<span class="tok-nf">parseNumber</span> <span class="tok-ow">=</span> <span class="tok-n">liftM</span> <span class="tok-p">(</span><span class="tok-kt">Number</span> <span class="tok-o">.</span> <span class="tok-n">read</span><span class="tok-p">)</span> <span class="tok-o">$</span> <span class="tok-n">many1</span> <span class="tok-n">digit</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>从右往左看会让你很容易理解这个表达式，因为函数呼叫符($)和函数组合符(.)函数都是右结合的。结合器many1会匹配目标的一个或者多个传递给它的参数，这里我们会匹配到一个或者多个数字。我们会用返回的字符串来构建出一个数字的LispVal类型，不过这里我们貌似有一些类型上的匹配问题。因此首先，我们用内建的read函数来将字符串转化为数字。然后我们再把数字传递给Number构造器得到一个LispVal类型的值。我们用函数组合符创建出一个将右边参数的调用结果传递给左边参数的函数，因此我们就这样将两个函数调用结合起来了。</p>
</div>
<div class="paragraph">
<p>不幸的是，many1 digit的返回值是一个Parser String，所以我们的经过结合的Number . Read函数仍然不能直接对它进行操作。我们需要一种告诉它只操作Monad里的值的方法，然后再把处理后的结果返回给Parser LispVal。而标准库中的liftM函数刚好能帮助我呢，所以我们对我们的函数Number . Read使用liftM，然后把结果对Parser进行调用。</p>
</div>
<div class="paragraph">
<p>我们需要在程序顶部导入Monad模块来使用liftM函数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="haskell"><span></span><span class="tok-kr">import</span> <span class="tok-nn">Control.Monad</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>这种不断进行函数组合，函数调用和函数传递的编程风格在Haskell代码中是非常常见的。这会让你能够在一行中表达出非常复杂的逻辑，并把中间的阶段分解成其它可以用各种方式结合起来的函数。不幸的是，这表明你需要常常从右向左阅读Haskell代码并且注意跟踪它们的类型。在后面的教程中我们会看到更多的例子，所以你应该会马上能适应这种方式。</p>
</div>
<div class="paragraph">
<p>创建一个能够接受字符串，数字或是Atom的解析器：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="haskell"><span></span><span class="tok-nf">parseExpr</span> <span class="tok-ow">::</span> <span class="tok-kt">Parser</span> <span class="tok-kt">LispVal</span>
<span class="tok-nf">parseExpr</span> <span class="tok-ow">=</span> <span class="tok-n">parseAtom</span>
         <span class="tok-o">&lt;|&gt;</span> <span class="tok-n">parseString</span>
         <span class="tok-o">&lt;|&gt;</span> <span class="tok-n">parseNumber</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>编辑readExpr函数让它调用我们的新解析器：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="haskell"><span></span><span class="tok-nf">readExpr</span> <span class="tok-ow">::</span> <span class="tok-kt">String</span> <span class="tok-ow">-&gt;</span> <span class="tok-kt">String</span>
<span class="tok-nf">readExpr</span> <span class="tok-n">input</span> <span class="tok-ow">=</span> <span class="tok-kr">case</span> <span class="tok-n">parse</span> <span class="tok-n">parseExpr</span> <span class="tok-s">&quot;lisp&quot;</span> <span class="tok-n">input</span> <span class="tok-kr">of</span>
    <span class="tok-kt">Left</span> <span class="tok-n">err</span> <span class="tok-ow">-&gt;</span> <span class="tok-s">&quot;No match: &quot;</span> <span class="tok-o">++</span> <span class="tok-n">show</span> <span class="tok-n">err</span>
    <span class="tok-kt">Right</span> <span class="tok-kr">_</span> <span class="tok-ow">-&gt;</span> <span class="tok-s">&quot;Found value&quot;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>编译并运行代码，你就能发现它接受任意的数字，字符串或者符号并且能够拒绝其他的情况了：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="bash"><span></span>$ ghc -package parsec -o simple_parser <span class="tok-o">[</span>.../code/listing3.3.hs listing3.3.hs<span class="tok-o">]</span>
$ ./simple_parser <span class="tok-s2">&quot;\\&quot;</span>this is a string<span class="tok-se">\\</span><span class="tok-s2">&quot;&quot;</span>
Found value
$ ./simple_parser <span class="tok-m">25</span>
Found value
$ ./simple_parser symbol
Found value
$ ./simple_parser <span class="tok-o">(</span>symbol<span class="tok-o">)</span>
bash: syntax error near unexpected token <span class="tok-sb">`</span>symbol<span class="tok-err">&#39;</span>
$ ./simple_parser <span class="tok-s2">&quot;(symbol)&quot;</span>
No match: <span class="tok-s2">&quot;lisp&quot;</span> <span class="tok-o">(</span>line <span class="tok-m">1</span>, column <span class="tok-m">1</span><span class="tok-o">)</span>:
unexpected <span class="tok-s2">&quot;(&quot;</span>
expecting letter, <span class="tok-s2">&quot;\\&quot;&quot; or digit</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_习题">3.4. 习题</h3>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>重写parseNumber函数，不允许使用liftM，尝试</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>使用do代码块</p>
</li>
<li>
<p>显式的运用&gt;&gt;=操作符来进行连接</p>
</li>
</ol>
</div>
</li>
<li>
<p>我们的字符串并不太符合R5RS规范，因为它们不支持在字符串里使用转义之后的引号。修改parseString函数让\”表示一个引号字符而不是整个字符串的结束。你可能需要用一个新的解析器操作来替换noneOf “\””从而让它能接受非引号字符或者一个转义符号之后的引号字符。</p>
</li>
<li>
<p>修改程序，让它支持\\n \\r \\t \\\\\\\\以及其它你希望转义的字符。</p>
</li>
<li>
<p>修改parseNumber让它提供Scheme标准中对不同进制的支持。readOct和readHex函数或许会对你很有用。</p>
</li>
<li>
<p>给LispVal增加一个字符构造器，然后为R5RS标准中定义的字符创造一个解析器。</p>
</li>
<li>
<p>给LispVal增加一个浮点数构造器来支持R5RS中的小数相关的语法。参考Haskell中的readFloat函数。</p>
</li>
<li>
<p>增加数据类型和解析器从而支持Scheme中的full numeric tower。Haskell已经有内建类型来表示其中的部分内容，你可以通过Prelude模块确认。至于其它，你可以通过定义复合类型的方法来表示它们。例如，一个分数可以用分子和分母表示而一个复数可以用实部和虚部来表示（每一部分都是一个实数）。</p>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_递归解析列表和引号">3.5. 递归解析：列表和引号</h3>
<div class="paragraph">
<p>接下来，给我们的解释器添加更多的解析器。从Lisp的知名括号列表开始：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="haskell"><span></span><span class="tok-nf">parseList</span> <span class="tok-ow">::</span> <span class="tok-kt">Parser</span> <span class="tok-kt">LispVal</span>
<span class="tok-nf">parseList</span> <span class="tok-ow">=</span> <span class="tok-n">liftM</span> <span class="tok-kt">List</span> <span class="tok-o">$</span> <span class="tok-n">sepBy</span> <span class="tok-n">parseExpr</span> <span class="tok-n">spaces</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>和parserNumber类似的，首先解析一系列由空格分隔开的表达式（sepBy parseExpr spaces），然后在Parser Monad内部调用构造符将它们组成一个List。注意我们能够把parseExpr直接传递给sepBy，尽管它是一个我们自己写的操作。</p>
</div>
<div class="paragraph">
<p>dotted-list的解析器稍微会复杂一点，不过仍然只是需要使用我们已经熟悉的概念：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="haskell"><span></span><span class="tok-nf">parseDottedList</span> <span class="tok-ow">::</span> <span class="tok-kt">Parser</span> <span class="tok-kt">LispVal</span>
<span class="tok-nf">parseDottedList</span> <span class="tok-ow">=</span> <span class="tok-kr">do</span>
    <span class="tok-n">head</span> <span class="tok-ow">&lt;-</span> <span class="tok-n">endBy</span> <span class="tok-n">parseExpr</span> <span class="tok-n">spaces</span>
    <span class="tok-n">tail</span> <span class="tok-ow">&lt;-</span> <span class="tok-n">char</span> <span class="tok-sc">&#39;.&#39;</span> <span class="tok-o">&gt;&gt;</span> <span class="tok-n">spaces</span> <span class="tok-o">&gt;&gt;</span> <span class="tok-n">parseExpr</span>
    <span class="tok-n">return</span> <span class="tok-o">$</span> <span class="tok-kt">DottedList</span> <span class="tok-n">head</span> <span class="tok-n">tail</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>注意我们是怎么使用&gt;&gt;把一系列的Parser操作连接起来并且do代码块中运用它的。表达式char '.' &gt;&gt; spaces返回一个Parser()，然后通过与parseExpr结合产生一个Parser LispVal类型，完全和我们在do代码块中需要的类型一致。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="haskell"><span></span><span class="tok-nf">parseQuoted</span> <span class="tok-ow">::</span> <span class="tok-kt">Parser</span> <span class="tok-kt">LispVal</span>
<span class="tok-nf">parseQuoted</span> <span class="tok-ow">=</span> <span class="tok-kr">do</span>
    <span class="tok-n">char</span> <span class="tok-kt">&#39;\\</span><span class="tok-sc">&#39;&#39;</span>
    <span class="tok-n">x</span> <span class="tok-ow">&lt;-</span> <span class="tok-n">parseExpr</span>
    <span class="tok-n">return</span> <span class="tok-o">$</span> <span class="tok-kt">List</span> <span class="tok-p">[</span><span class="tok-kt">Atom</span> <span class="tok-s">&quot;quote&quot;</span><span class="tok-p">,</span> <span class="tok-n">x</span><span class="tok-p">]</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>大部分都是我们已经熟悉了的内容了：这段程序读取一个单个的引号字符，读取一个表达式然后把它绑定给x，然后返回(quote x)，来表达一个Scheme符号。Atom构造器就像一个普通函数一样：你传递一个需要封装的字符串给它，然后它返回给你一个LispVal类型的值。你可以对这个LispVal做任何你一般情况下能做的事情，比如把它放入一个列表里。</p>
</div>
<div class="paragraph">
<p>最后，编辑parseExpr函数来把我们的新解析器添加进去：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="haskell"><span></span><span class="tok-nf">parseExpr</span> <span class="tok-ow">::</span> <span class="tok-kt">Parser</span> <span class="tok-kt">LispVal</span>
<span class="tok-nf">parseExpr</span> <span class="tok-ow">=</span> <span class="tok-n">parseAtom</span>
         <span class="tok-o">&lt;|&gt;</span> <span class="tok-n">parseString</span>
         <span class="tok-o">&lt;|&gt;</span> <span class="tok-n">parseNumber</span>
         <span class="tok-o">&lt;|&gt;</span> <span class="tok-n">parseQuoted</span>
         <span class="tok-o">&lt;|&gt;</span> <span class="tok-kr">do</span> <span class="tok-n">char</span> <span class="tok-sc">&#39;(&#39;</span>
                <span class="tok-n">x</span> <span class="tok-ow">&lt;-</span> <span class="tok-n">try</span> <span class="tok-n">parseList</span> <span class="tok-o">&lt;|&gt;</span> <span class="tok-n">parseDottedList</span>
                <span class="tok-n">char</span> <span class="tok-sc">&#39;)&#39;</span>
                <span class="tok-n">return</span> <span class="tok-n">x</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>这里演示了最后一个Parsec的功能：回溯。parseList和parseDottedLis直到某个特定的位置都能够识别出相同的字符串；这打破了一个选择不能在出错前消费任何输入的前提。而try连接器试图运行某个的解析器，但是如果解析失败了，它会回滚到上一个状态。这让你在不影响其它分支的前提下对目标进行各种操作。</p>
</div>
<div class="paragraph">
<p>编译然后运行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="bash"><span></span>$ ghc -package parsec -o simple_parser <span class="tok-o">[</span>../code/listing3.4.hs listing3.4.hs<span class="tok-o">]</span>
$ ./simple_parser <span class="tok-s2">&quot;(a test)&quot;</span>
Found value
$ ./simple_parser <span class="tok-s2">&quot;(a (nested) test)&quot;</span>
Found value
$ ./simple_parser <span class="tok-s2">&quot;(a (dotted . list) test)&quot;</span>
Found value
$ ./simple_parser <span class="tok-s2">&quot;(a &#39;(quoted (dotted . list)) test)&quot;</span>
Found value
$ ./simple_parser <span class="tok-s2">&quot;(a &#39;(imbalanced parens)&quot;</span>
No match: <span class="tok-s2">&quot;lisp&quot;</span> <span class="tok-o">(</span>line <span class="tok-m">1</span>, column <span class="tok-m">24</span><span class="tok-o">)</span>:
unexpected end of input
expecting space or <span class="tok-s2">&quot;)&quot;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>注意我们可以在parseExpr里任意深入的嵌套我们的解析器。这样，我们通过一些简单的定义就能够完全的让程序阅读Lisp代码了。这就是递归的威力。</p>
</div>
</div>
<div class="sect2">
<h3 id="_习题_2">3.6. 习题</h3>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>添加backquote语法糖的支持：Scheme标准详述了它应该怎样展开成（quasiquote/unquote）。</p>
</li>
<li>
<p>添加vectors的支持。你可以使用Haskell的内置实现Array，但是它使用起来可能会有些问题。严格说，一个vector应该有常数时间的索引和更新操作，但是事实上直接的更新操作在一个纯函数式语言里是很难实现的。你可能在看过该系列教程的后面的章节后会对如何实现它有更好的想法。</p>
</li>
<li>
<p>如果不用try组合符的话，你需要将目标从左边开始分解并在接下来调用parseExpr解析器自身。最后需要用一个解析器对字符串进行匹配，它要么是空要么是一个点符号加上一个单元素的表达式。这里把这个有趣的练习留给你：把它们的返回值组合成一个要么是List要么是DottedList的Either类型：你也许需要把判断逻辑分解到另外一个辅助函数里。</p>
</li>
</ol>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_求值第一部分">4. 求值：第一部分</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_开始求值">4.1. 开始求值</h3>
<div class="paragraph">
<p>现在，我们仅仅能打印出来我们是否能够将给定的代码片段分辨出来而已。我们现在将向一个能够正常工作的Scheme解释器迈出第一步：计算代码片段的值。我们会先从一些简单的例子开始，但是很快你就能够开始进行各种计算了。</p>
</div>
<div class="paragraph">
<p>让我们从告诉Haskell如何将表示各种LispVal值的字符串打印出来开始：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="haskell"><span></span><span class="tok-nf">showVal</span> <span class="tok-ow">::</span> <span class="tok-kt">LispVal</span> <span class="tok-ow">-&gt;</span> <span class="tok-kt">String</span>
<span class="tok-nf">showVal</span> <span class="tok-p">(</span><span class="tok-kt">String</span> <span class="tok-n">contents</span><span class="tok-p">)</span> <span class="tok-ow">=</span> <span class="tok-s">&quot;</span><span class="tok-se">\&quot;</span><span class="tok-s">&quot;</span> <span class="tok-o">++</span> <span class="tok-n">contents</span> <span class="tok-o">++</span> <span class="tok-s">&quot;</span><span class="tok-se">\&quot;</span><span class="tok-s">&quot;</span>
<span class="tok-nf">showVal</span> <span class="tok-p">(</span><span class="tok-kt">Atom</span> <span class="tok-n">name</span><span class="tok-p">)</span> <span class="tok-ow">=</span> <span class="tok-n">name</span>
<span class="tok-nf">showVal</span> <span class="tok-p">(</span><span class="tok-kt">Number</span> <span class="tok-n">contents</span><span class="tok-p">)</span> <span class="tok-ow">=</span> <span class="tok-n">show</span> <span class="tok-n">contents</span>
<span class="tok-nf">showVal</span> <span class="tok-p">(</span><span class="tok-kt">Bool</span> <span class="tok-kt">True</span><span class="tok-p">)</span> <span class="tok-ow">=</span> <span class="tok-s">&quot;#t&quot;</span>
<span class="tok-nf">showVal</span> <span class="tok-p">(</span><span class="tok-kt">Bool</span> <span class="tok-kt">False</span><span class="tok-p">)</span> <span class="tok-ow">=</span> <span class="tok-s">&quot;#f&quot;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>这是我们第一次真正对模式匹配进行介绍。模式匹配是一种能将代数类型进行解构的方法，依次和基于构造器的子句进行匹配并且把解构得到的部分和变量绑定起来以供之后使用。任何构造器都可以出现在模式中；如果标签和值的标签一致而且所有的子模式都和相应的组件匹配，那么这个模式就匹配了一个值。模式可以任意深的嵌套，而它用一种从里到外、从左到右的顺序匹配。一个函数定义的所有子句按照文本顺序依次尝试，直到一个模式匹配。如果这让你糊涂，你可以参考在我们深入求值器时的一些深嵌套的例子。</p>
</div>
<div class="paragraph">
<p>目前，你只需要知道每一个上面定义的子句都与一个LispVal构造器匹配，而右手边部分会告诉程序对那个构造器中包含的值做什么。</p>
</div>
<div class="paragraph">
<p>List和DottedList类似，但是我们需要定义一个辅助函数unwordsList来将列表转换成一个字符串：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="haskell"><span></span><span class="tok-nf">showVal</span> <span class="tok-p">(</span><span class="tok-kt">List</span> <span class="tok-n">contents</span><span class="tok-p">)</span> <span class="tok-ow">=</span> <span class="tok-s">&quot;(&quot;</span> <span class="tok-o">++</span> <span class="tok-n">unwordsList</span> <span class="tok-n">contents</span> <span class="tok-o">++</span> <span class="tok-s">&quot;)&quot;</span>
<span class="tok-nf">showVal</span> <span class="tok-p">(</span><span class="tok-kt">DottedList</span> <span class="tok-n">head</span> <span class="tok-n">tail</span><span class="tok-p">)</span> <span class="tok-ow">=</span> <span class="tok-s">&quot;(&quot;</span> <span class="tok-o">++</span> <span class="tok-n">unwordsList</span> <span class="tok-n">head</span> <span class="tok-o">++</span> <span class="tok-s">&quot; . &quot;</span> <span class="tok-o">++</span> <span class="tok-n">showVal</span> <span class="tok-n">tail</span> <span class="tok-o">++</span> <span class="tok-s">&quot;)&quot;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>unwordsList函数与Prelude库中的unwords函数类似，它把列表中的的单词用空格粘在一起。因为我们要处理的是LispVal而不是单词组成的列表，我们需要定义一个函数将LispVal转换成为对应的字符串形式然后再对它们使用unwords函数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="haskell"><span></span><span class="tok-nf">unwordsList</span> <span class="tok-ow">::</span> <span class="tok-p">[</span><span class="tok-kt">LispVal</span><span class="tok-p">]</span> <span class="tok-ow">-&gt;</span> <span class="tok-kt">String</span>
<span class="tok-nf">unwordsList</span> <span class="tok-ow">=</span> <span class="tok-n">unwords</span> <span class="tok-o">.</span> <span class="tok-n">map</span> <span class="tok-n">showVal</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>我们的unwordsList定义并没有包含任何的参数。这就是一个point-free编程的例子：完全通过函数组合和局部调用的方式来进行定义，而单独的看待值或者说参数。相反的，这里我们使用了一组内建函数的组合来定义这个函数。首先，我们将showVal函数传递给map从而通过局部调用的方式创建了一个接受LispVal列表然后返回他们的字符串形式的列表的函数。Haskell函数是柯里化的：这意味着某个有两个参数的函数，例如map，实际上是一个会返回一个只一个参数的函数的函数。因此，如果你只使用一个参数去调用它，你就会得到一个可以传递，结合或是之后在进行调用的单参数函数。在这个例子里，我们将它和unwords函数结合：map showVal转换一个LispVal列表成为它们的字符串形式的列表，然后unwords将结果用空白字符结合在一起。</p>
</div>
<div class="paragraph">
<p>我们在上面使用了show函数。这个标准Haskell函数让你能够将任意是Show实例的类型转换成为一个字符串。我们希望对LispVal也能够做同样的事情，因此我们将它定义成class Show的一个成员，并将它的show方法直接定义成showVal：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="haskell"><span></span><span class="tok-kr">instance</span> <span class="tok-kt">Show</span> <span class="tok-kt">LispVal</span> <span class="tok-kr">where</span> <span class="tok-n">show</span> <span class="tok-ow">=</span> <span class="tok-n">showVal</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>完整的类型类的介绍不在这次教程的范围之内；你可以在其他教程或是Haskell 98 report里找到更多的相关信息。</p>
</div>
<div class="paragraph">
<p>让我们再试试看改变readExpr函数让它返回值实际解析值对应的字符串表示形式，而不仅仅是告诉我们解析成功：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="haskell"><span></span><span class="tok-nf">readExpr</span> <span class="tok-n">input</span> <span class="tok-ow">=</span> <span class="tok-kr">case</span> <span class="tok-n">parse</span> <span class="tok-n">parseExpr</span> <span class="tok-s">&quot;lisp&quot;</span> <span class="tok-n">input</span> <span class="tok-kr">of</span>
    <span class="tok-kt">Left</span> <span class="tok-n">err</span> <span class="tok-ow">-&gt;</span> <span class="tok-s">&quot;No match: &quot;</span> <span class="tok-o">++</span> <span class="tok-n">show</span> <span class="tok-n">err</span>
    <span class="tok-kt">Right</span> <span class="tok-n">val</span> <span class="tok-ow">-&gt;</span> <span class="tok-s">&quot;Found &quot;</span> <span class="tok-o">++</span> <span class="tok-n">show</span> <span class="tok-n">val</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>编译然后运行程序：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="bash"><span></span>$ ghc -package parsec -o parser listing4.1.hs
$ ./parser <span class="tok-s2">&quot;(1 2 2)&quot;</span>
Found <span class="tok-o">(</span><span class="tok-m">1</span> <span class="tok-m">2</span> <span class="tok-m">2</span><span class="tok-o">)</span>
$ ./parser <span class="tok-s2">&quot;&#39;(1 3 (\&quot;this\&quot; \&quot;one\&quot;))&quot;</span>
Found <span class="tok-o">(</span>quote <span class="tok-o">(</span><span class="tok-m">1</span> <span class="tok-m">3</span> <span class="tok-o">(</span><span class="tok-s2">&quot;this&quot;</span> <span class="tok-s2">&quot;one&quot;</span><span class="tok-o">)))</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_开始求值初版">4.2. 开始求值：初版</h3>
<div class="paragraph">
<p>现在，让我们开始来编写一个求值器。这个求值器的目的是在于将作为代码的数据类型计算获得对应的表示数据的数据类型，即求出对应代码的结果。而对于Lisp来说，代码和数据的数据类型是相同的，因此我们的求值器会返回一个LispVal值。而其他有些语言会有更加复杂的代码结构，以及大量的语法形式。</p>
</div>
<div class="paragraph">
<p>对数字，字符串，布尔值和引用列表则相当简单：只需要返回数据本身就可以了。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="haskell"><span></span><span class="tok-nf">eval</span> <span class="tok-ow">::</span> <span class="tok-kt">LispVal</span> <span class="tok-ow">-&gt;</span> <span class="tok-kt">LispVal</span>
<span class="tok-nf">eval</span> <span class="tok-n">val</span><span class="tok-o">@</span><span class="tok-p">(</span><span class="tok-kt">String</span> <span class="tok-kr">_</span><span class="tok-p">)</span> <span class="tok-ow">=</span> <span class="tok-n">val</span>
<span class="tok-nf">eval</span> <span class="tok-n">val</span><span class="tok-o">@</span><span class="tok-p">(</span><span class="tok-kt">Number</span> <span class="tok-kr">_</span><span class="tok-p">)</span> <span class="tok-ow">=</span> <span class="tok-n">val</span>
<span class="tok-nf">eval</span> <span class="tok-n">val</span><span class="tok-o">@</span><span class="tok-p">(</span><span class="tok-kt">Bool</span> <span class="tok-kr">_</span><span class="tok-p">)</span> <span class="tok-ow">=</span> <span class="tok-n">val</span>
<span class="tok-nf">eval</span> <span class="tok-p">(</span><span class="tok-kt">List</span> <span class="tok-p">[</span><span class="tok-kt">Atom</span> <span class="tok-s">&quot;quote&quot;</span><span class="tok-p">,</span> <span class="tok-n">val</span><span class="tok-p">])</span> <span class="tok-ow">=</span> <span class="tok-n">val</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>这里我们看到了一种新的模式。val@(String _)能够匹配任意的字符串的后将整个LispVal值绑定给了val变量，而不仅仅是String构造器中的值。它是LispVal类型而不是字符串类型的。下划线是一个任意变量，它会匹配一个任意的没有与变量绑定的值。它能出现在任何的模式中，但是在和@-模式一起（你将变量与整个模式绑定）或是当你只对构造器的类型感兴趣的时候它会特别的有用。</p>
</div>
<div class="paragraph">
<p>在最后一个分支里我们会第一次看到一个嵌套的模式。List构造器中的数据类型是[LispVal]，一个LispVal的列表。我们会用一个特殊的二元列表[Atom "quote", val]去尝试匹配它，这是一个第一个元素是quote字符串而第二个元素可以是任意值的列表。匹配之后我们返回列表中的第二个元素。</p>
</div>
<div class="paragraph">
<p>让我们把eval函数集成到我们目前的代码中去。从readExpr函数开始，我们将它改回能够返回表达式而不是表达式的字符串表示形式的样子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="haskell"><span></span><span class="tok-nf">readExpr</span> <span class="tok-ow">::</span> <span class="tok-kt">String</span> <span class="tok-ow">-&gt;</span> <span class="tok-kt">LispVal</span>
<span class="tok-nf">readExpr</span> <span class="tok-n">input</span> <span class="tok-ow">=</span> <span class="tok-kr">case</span> <span class="tok-n">parse</span> <span class="tok-n">parseExpr</span> <span class="tok-s">&quot;lisp&quot;</span> <span class="tok-n">input</span> <span class="tok-kr">of</span>
    <span class="tok-kt">Left</span> <span class="tok-n">err</span> <span class="tok-ow">-&gt;</span> <span class="tok-kt">String</span> <span class="tok-o">$</span> <span class="tok-s">&quot;No match: &quot;</span> <span class="tok-o">++</span> <span class="tok-n">show</span> <span class="tok-n">err</span>
    <span class="tok-kt">Right</span> <span class="tok-n">val</span> <span class="tok-ow">-&gt;</span> <span class="tok-n">val</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>然后修改我们的主函数，读取一个表达式，计算它，将结果转换成字符串，然后打印出来。既然我们现在知道了&gt;&gt;=和函数组合操作符的用法，让我们把整个过程更加简洁的拼接起来：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="haskell"><span></span><span class="tok-nf">main</span> <span class="tok-ow">::</span> <span class="tok-kt">IO</span> <span class="tok-nb">()</span>
<span class="tok-nf">main</span> <span class="tok-ow">=</span> <span class="tok-n">getArgs</span> <span class="tok-o">&gt;&gt;=</span> <span class="tok-n">print</span> <span class="tok-o">.</span> <span class="tok-n">eval</span> <span class="tok-o">.</span> <span class="tok-n">readExpr</span> <span class="tok-o">.</span> <span class="tok-n">head</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>这里，我们获取getArgs操作的结果（一个字符串组成的列表）然后将它传入下面的函数组合中：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>取出第一个元素（head）</p>
</li>
<li>
<p>进行解析（readExpr）</p>
</li>
<li>
<p>求值（eval）</p>
</li>
<li>
<p>转换结果成字符串并打印出来。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>像之前那样编译并运行程序：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="bash"><span></span>$ ghc -package parsec -o <span class="tok-nb">eval</span> listing4.2.hs
$ ./eval <span class="tok-s2">&quot;&#39;atom&quot;</span>
atom
$ ./eval <span class="tok-m">2</span>
<span class="tok-m">2</span>
$ ./eval <span class="tok-s2">&quot;\&quot;a string\&quot;&quot;</span>
<span class="tok-s2">&quot;a string&quot;</span>
$ ./eval <span class="tok-s2">&quot;(+ 2 2)&quot;</span>
Fail: listing6.hs:83: Non-exhaustive patterns <span class="tok-k">in</span> <span class="tok-k">function</span> <span class="tok-nb">eval</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>我们仍然不能够用我们的程序做一些很有用的事情（注意到我们连(+ 2 2)都计算不了），但是一个基本的框架已经有了。接下来，让我们通过扩展基本函数的方式来让我们的解释器变得有用一些。</p>
</div>
</div>
<div class="sect2">
<h3 id="_添加基本操作">4.3. 添加基本操作</h3>
<div class="paragraph">
<p>接下来，我们来对我们的解释器进行一些改进从而可以支持基本的计算。虽然它还不是完整的“编程语言”，但也不远了。</p>
</div>
<div class="paragraph">
<p>我们首先给eval函数添加一个模式，从而让它可以处理函数调用。记住函数定义中的所有子句都必须放在一起，它们会依次进行匹配和求值，因此我们把这个表达式放在其他子句的后面：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="haskell"><span></span><span class="tok-nf">eval</span> <span class="tok-p">(</span><span class="tok-kt">List</span> <span class="tok-p">(</span><span class="tok-kt">Atom</span> <span class="tok-n">func</span> <span class="tok-kt">:</span> <span class="tok-n">args</span><span class="tok-p">))</span> <span class="tok-ow">=</span> <span class="tok-n">apply</span> <span class="tok-n">func</span> <span class="tok-o">$</span> <span class="tok-n">map</span> <span class="tok-n">eval</span> <span class="tok-n">args</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>这里又是一个嵌套模式，但这次我们尝试使用构造操作符:进行匹配而不是像之前那样使用一个列表的形式。事实上在Haskell中，列表也仅仅是一个用来表示cons函数调用串的语法糖而已：[1, 2, 3, 4] = 1:(2:(3:(4:[])))。通过匹配cons本身而不是一个字符串列表，我们就像是在“获取列表的剩下的部分”而不是仅仅“获取列表的第二个元素”。例如，如果我们传递(+ 2 2 )给eval函数，func变量会与+绑定而args变量会与[Number 2, Number 2]进行绑定。</p>
</div>
<div class="paragraph">
<p>剩下部分包括了一些我们之前已经熟悉的函数以及最后一个我们还没有定义的函数。由于我们必须递归的对每一个参数进行求值，因此我们对每一个参数调用eval函数。这允许我们能够进行(+2 (- 3 1) (* 5 4))这样的复合表达式。然后我们再将计算过后的参数传递给先前的函数再进一步进行求值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="haskell"><span></span><span class="tok-nf">apply</span> <span class="tok-ow">::</span> <span class="tok-kt">String</span> <span class="tok-ow">-&gt;</span> <span class="tok-p">[</span><span class="tok-kt">LispVal</span><span class="tok-p">]</span> <span class="tok-ow">-&gt;</span> <span class="tok-kt">LispVal</span>
<span class="tok-nf">apply</span> <span class="tok-n">func</span> <span class="tok-n">args</span> <span class="tok-ow">=</span> <span class="tok-n">maybe</span> <span class="tok-p">(</span><span class="tok-kt">Bool</span> <span class="tok-kt">False</span><span class="tok-p">)</span> <span class="tok-p">(</span><span class="tok-o">$</span> <span class="tok-n">args</span><span class="tok-p">)</span> <span class="tok-o">$</span> <span class="tok-n">lookup</span> <span class="tok-n">func</span> <span class="tok-n">primitives</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>内置函数lookup会在Pair列表搜索关键字（Pair的第一个元素）。然而，如果列表里没有包含对应的关键字，查找就会出错。因此该函数会返回一个Haskell的内建类型Maybe的实例从来避免程序异常。我们使用maybe函数来分别指定当成功或失败的情况下分别进行什么样的处理。当函数没有找到的情况，我们返回一个False值，即是#f（之后会添加更健壮的错误检查机制）。而如果找到了，我们就通过函数呼叫符这样($ args)来将它应用到函数的参数。</p>
</div>
<div class="paragraph">
<p>接下来，我们来定义一些需要支持的基础操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="haskell"><span></span><span class="tok-nf">primitives</span> <span class="tok-ow">::</span> <span class="tok-p">[(</span><span class="tok-kt">String</span><span class="tok-p">,</span> <span class="tok-p">[</span><span class="tok-kt">LispVal</span><span class="tok-p">]</span> <span class="tok-ow">-&gt;</span> <span class="tok-kt">LispVal</span><span class="tok-p">)]</span>
<span class="tok-nf">primitives</span> <span class="tok-ow">=</span> <span class="tok-p">[(</span><span class="tok-s">&quot;+&quot;</span><span class="tok-p">,</span> <span class="tok-n">numericBinop</span> <span class="tok-p">(</span><span class="tok-o">+</span><span class="tok-p">)),</span>
              <span class="tok-p">(</span><span class="tok-s">&quot;-&quot;</span><span class="tok-p">,</span> <span class="tok-n">numericBinop</span> <span class="tok-p">(</span><span class="tok-o">-</span><span class="tok-p">)),</span>
              <span class="tok-p">(</span><span class="tok-s">&quot;*&quot;</span><span class="tok-p">,</span> <span class="tok-n">numericBinop</span> <span class="tok-p">(</span><span class="tok-o">*</span><span class="tok-p">)),</span>
              <span class="tok-p">(</span><span class="tok-s">&quot;/&quot;</span><span class="tok-p">,</span> <span class="tok-n">numericBinop</span> <span class="tok-n">div</span><span class="tok-p">),</span>
              <span class="tok-p">(</span><span class="tok-s">&quot;mod&quot;</span><span class="tok-p">,</span> <span class="tok-n">numericBinop</span> <span class="tok-n">mod</span><span class="tok-p">),</span>
              <span class="tok-p">(</span><span class="tok-s">&quot;quotient&quot;</span><span class="tok-p">,</span> <span class="tok-n">numericBinop</span> <span class="tok-n">quot</span><span class="tok-p">),</span>
              <span class="tok-p">(</span><span class="tok-s">&quot;remainder&quot;</span><span class="tok-p">,</span> <span class="tok-n">numericBinop</span> <span class="tok-n">rem</span><span class="tok-p">)]</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>看下primitivs函数的类型。事实上它是一个Pair类型的列表，恰好是能和lookup匹配，但是返回的函数类型都是从[LispVal]到LispVal的。Haskell中，你可以将函数存储到其他的数据结构中，不过所有的函数必须具有同样的类型签名。</p>
</div>
<div class="paragraph">
<p>同样，我们存储的函数它们本身也只是一个函数的返回结果，例如我们还没有定义的numericBinop函数。它读取一个原生Haskell函数（大部分情况下应该是操作符）再将它用分解参数列表，应用函数的代码封装起来，最后再将计算的结果通过Number构造器进行封装并返回。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="haskell"><span></span><span class="tok-nf">numericBinop</span> <span class="tok-ow">::</span> <span class="tok-p">(</span><span class="tok-kt">Integer</span> <span class="tok-ow">-&gt;</span> <span class="tok-kt">Integer</span> <span class="tok-ow">-&gt;</span> <span class="tok-kt">Integer</span><span class="tok-p">)</span> <span class="tok-ow">-&gt;</span> <span class="tok-p">[</span><span class="tok-kt">LispVal</span><span class="tok-p">]</span> <span class="tok-ow">-&gt;</span> <span class="tok-kt">LispVal</span>
<span class="tok-nf">numericBinop</span> <span class="tok-n">op</span> <span class="tok-n">params</span> <span class="tok-ow">=</span> <span class="tok-kt">Number</span> <span class="tok-o">$</span> <span class="tok-n">foldl1</span> <span class="tok-n">op</span> <span class="tok-o">$</span> <span class="tok-n">map</span> <span class="tok-n">unpackNum</span> <span class="tok-n">params</span>

<span class="tok-nf">unpackNum</span> <span class="tok-ow">::</span> <span class="tok-kt">LispVal</span> <span class="tok-ow">-&gt;</span> <span class="tok-kt">Integer</span>
<span class="tok-nf">unpackNum</span> <span class="tok-p">(</span><span class="tok-kt">Number</span> <span class="tok-n">n</span><span class="tok-p">)</span> <span class="tok-ow">=</span> <span class="tok-n">n</span>
<span class="tok-nf">unpackNum</span> <span class="tok-p">(</span><span class="tok-kt">String</span> <span class="tok-n">n</span><span class="tok-p">)</span> <span class="tok-ow">=</span> <span class="tok-kr">let</span> <span class="tok-n">parsed</span> <span class="tok-ow">=</span> <span class="tok-n">reads</span> <span class="tok-n">n</span> <span class="tok-ow">::</span> <span class="tok-p">[(</span><span class="tok-kt">Integer</span><span class="tok-p">,</span> <span class="tok-kt">String</span><span class="tok-p">)]</span> <span class="tok-kr">in</span>
                           <span class="tok-kr">if</span> <span class="tok-n">null</span> <span class="tok-n">parsed</span>
                              <span class="tok-kr">then</span> <span class="tok-mi">0</span>
                              <span class="tok-kr">else</span> <span class="tok-n">fst</span> <span class="tok-o">$</span> <span class="tok-n">parsed</span> <span class="tok-o">!!</span> <span class="tok-mi">0</span>
<span class="tok-nf">unpackNum</span> <span class="tok-p">(</span><span class="tok-kt">List</span> <span class="tok-p">[</span><span class="tok-n">n</span><span class="tok-p">])</span> <span class="tok-ow">=</span> <span class="tok-n">unpackNum</span> <span class="tok-n">n</span>
<span class="tok-nf">unpackNum</span> <span class="tok-kr">_</span> <span class="tok-ow">=</span> <span class="tok-mi">0</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>和R5RS Scheme中一样，我们不会限制函数的参数只能有两个。我们的数值操作符能在一个任意长度的列表上工作，例如(+ 2 3 4) = 2+3+4和(- 15 5 4 3) = 15-5-3-2。我们是使用内建函数foldl1
来实现这一点的。事实上它即是将列表中每一个连接操作符都替换成了我们提供的二元函数op。</p>
</div>
<div class="paragraph">
<p>与R5RS Scheme不同，我们的解释器使用了一种弱输入的方式。这意味着如果一个值能够被解释成一个数字（例如字符串“2”)，我们就会将它看做一个数字，尽管它也许被标记成一个字符串。我们给unpackNum函数添加了一系列子句从使它能够解析各式各样的字符串。如果我们希望分解一个字符串并尝试用Haskell的内建函数reads去解析它，该函数就会返回一个（分析值，剩余值）对的列表给我们。</p>
</div>
<div class="paragraph">
<p>而对于列表的情况，我们直接尝试将它和一个单元素列表进行匹配并分解。匹配失败的话则会直接掉入第二个情况。</p>
</div>
<div class="paragraph">
<p>如果由于某些原因我们无法对数字进行解析，那么我们就暂时直接返回0作为结果。我们之后会对它进行修复并让它提示一个错误信息。</p>
</div>
<div class="paragraph">
<p>像之前那样编译并运行程序。注意到我们并没有做什么特殊的处理就直接能够对嵌套的表达式进行求值了，这是拜我们之前对函数每个参数进行求值所赐：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="bash"><span></span>$ ghc -package parsec -o <span class="tok-nb">eval</span> listing7.hs
$ ./eval <span class="tok-s2">&quot;(+ 2 2)&quot;</span>
<span class="tok-m">4</span>
$ ./eval <span class="tok-s2">&quot;(+ 2 (-4 1))&quot;</span>
<span class="tok-m">2</span>
$ ./eval <span class="tok-s2">&quot;(+ 2 (- 4 1))&quot;</span>
<span class="tok-m">5</span>
$ ./eval <span class="tok-s2">&quot;(- (+ 4 6 3) 3 5 2)&quot;</span>
<span class="tok-m">3</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_习题_3">4.4. 习题</h3>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>添加对R5RS中的类型测试数的原生支持 :symbol?，string?和number?等。</p>
</li>
<li>
<p>修改unpackNum函数让它当输入值不是一个数字的时候总是返回0，即使它是一个可以被解析成数字的字符串或者列表。</p>
</li>
<li>
<p>添加对R5RS中的symbol-handling functions的支持。symbol是指我们在之前的LispVal类型中被称作Atom的东西。</p>
</li>
</ol>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_错误检查和异常处理">5. 错误检查和异常处理</h2>
<div class="sectionbody">
<div class="paragraph">
<p>现在我们程序里的很多地方，我们要么是忽略了错误，要么是让它默默返回一个像是#f或是0这样表示无意义的默认值。一些像Perl或者是PHP的语言就是用这种方式来处理异常的。然而，这也意味着错误会默默的在整个程序里传递直到最终变成很大的并且让程序员能难定位的问题。我们这里希望一旦有错误发生，它就能立刻被注意到并且让程序停止运行。</p>
</div>
<div class="paragraph">
<p>首先，我们需要导入Control.Monad.Error库来取得Haskell的内置错误处理函数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="haskell"><span></span><span class="tok-kr">import</span> <span class="tok-nn">Control.Monad.Error</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>在Debian系的系统上，这需要额外安装一个libghc6-mtl-dev包。</p>
</div>
<div class="paragraph">
<p>然后，让我们为错误也定义一个数据类型：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="haskell"><span></span><span class="tok-kr">data</span> <span class="tok-kt">LispError</span> <span class="tok-ow">=</span> <span class="tok-kt">NumArgs</span> <span class="tok-kt">Integer</span> <span class="tok-p">[</span><span class="tok-kt">LispVal</span><span class="tok-p">]</span>
               <span class="tok-o">|</span> <span class="tok-kt">TypeMismatch</span> <span class="tok-kt">String</span> <span class="tok-kt">LispVal</span>
               <span class="tok-o">|</span> <span class="tok-kt">Parser</span> <span class="tok-kt">ParseError</span>
               <span class="tok-o">|</span> <span class="tok-kt">BadSpecialForm</span> <span class="tok-kt">String</span> <span class="tok-kt">LispVal</span>
               <span class="tok-o">|</span> <span class="tok-kt">NotFunction</span> <span class="tok-kt">String</span> <span class="tok-kt">String</span>
               <span class="tok-o">|</span> <span class="tok-kt">UnboundVar</span> <span class="tok-kt">String</span> <span class="tok-kt">String</span>
               <span class="tok-o">|</span> <span class="tok-kt">Default</span> <span class="tok-kt">String</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>这里是到目前为止我们可能会需要的一些构造器，之后我们可能还会想到一些其他的东西然后再添加进去。接下来，我们来定义如何打印LispError并且让它成为Show的一个实例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="haskell"><span></span><span class="tok-nf">showError</span> <span class="tok-ow">::</span> <span class="tok-kt">LispError</span> <span class="tok-ow">-&gt;</span> <span class="tok-kt">String</span>
<span class="tok-nf">showError</span> <span class="tok-p">(</span><span class="tok-kt">UnboundVar</span> <span class="tok-n">message</span> <span class="tok-n">varname</span><span class="tok-p">)</span>  <span class="tok-ow">=</span> <span class="tok-n">message</span> <span class="tok-o">++</span> <span class="tok-s">&quot;: &quot;</span> <span class="tok-o">++</span> <span class="tok-n">varname</span>
<span class="tok-nf">showError</span> <span class="tok-p">(</span><span class="tok-kt">BadSpecialForm</span> <span class="tok-n">message</span> <span class="tok-n">form</span><span class="tok-p">)</span> <span class="tok-ow">=</span> <span class="tok-n">message</span> <span class="tok-o">++</span> <span class="tok-s">&quot;: &quot;</span> <span class="tok-o">++</span> <span class="tok-n">show</span> <span class="tok-n">form</span>
<span class="tok-nf">showError</span> <span class="tok-p">(</span><span class="tok-kt">NotFunction</span> <span class="tok-n">message</span> <span class="tok-n">func</span><span class="tok-p">)</span>    <span class="tok-ow">=</span> <span class="tok-n">message</span> <span class="tok-o">++</span> <span class="tok-s">&quot;: &quot;</span> <span class="tok-o">++</span> <span class="tok-n">show</span> <span class="tok-n">func</span>
<span class="tok-nf">showError</span> <span class="tok-p">(</span><span class="tok-kt">NumArgs</span> <span class="tok-n">expected</span> <span class="tok-n">found</span><span class="tok-p">)</span>      <span class="tok-ow">=</span> <span class="tok-s">&quot;Expected &quot;</span> <span class="tok-o">++</span> <span class="tok-n">show</span> <span class="tok-n">expected</span>
                                       <span class="tok-o">++</span> <span class="tok-s">&quot; args; found values &quot;</span> <span class="tok-o">++</span> <span class="tok-n">unwordsList</span> <span class="tok-n">found</span>
<span class="tok-nf">showError</span> <span class="tok-p">(</span><span class="tok-kt">TypeMismatch</span> <span class="tok-n">expected</span> <span class="tok-n">found</span><span class="tok-p">)</span> <span class="tok-ow">=</span> <span class="tok-s">&quot;Invalid type: expected &quot;</span> <span class="tok-o">++</span> <span class="tok-n">expected</span>
                                       <span class="tok-o">++</span> <span class="tok-s">&quot;, found &quot;</span> <span class="tok-o">++</span> <span class="tok-n">show</span> <span class="tok-n">found</span>
<span class="tok-nf">showError</span> <span class="tok-p">(</span><span class="tok-kt">Parser</span> <span class="tok-n">parseErr</span><span class="tok-p">)</span>             <span class="tok-ow">=</span> <span class="tok-s">&quot;Parse error at &quot;</span> <span class="tok-o">++</span> <span class="tok-n">show</span> <span class="tok-n">parseErr</span>

<span class="tok-kr">instance</span> <span class="tok-kt">Show</span> <span class="tok-kt">LispError</span> <span class="tok-kr">where</span> <span class="tok-n">show</span> <span class="tok-ow">=</span> <span class="tok-n">showError</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>接下来是时候让我们自己定义的类型成为一个Error的实例了。这样子我们才能让它同GHC的内置错误处理函数相配合。成为Error的一个实例事实上只需要给它提供一个能通过一条的错误消息或者它自身来进行初始化的函数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="haskell"><span></span><span class="tok-kr">instance</span> <span class="tok-kt">Error</span> <span class="tok-kt">LispError</span> <span class="tok-kr">where</span>
     <span class="tok-n">noMsg</span> <span class="tok-ow">=</span> <span class="tok-kt">Default</span> <span class="tok-s">&quot;An error has occurred&quot;</span>
     <span class="tok-n">strMsg</span> <span class="tok-ow">=</span> <span class="tok-kt">Default</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>接下来我们来定义一个用来表示要么会抛出LispError要么会返回值的函数的类型。还记得我们之前是怎么用Either类型来表示parse中的异常情况的吗？这里也是一样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="haskell"><span></span><span class="tok-kr">type</span> <span class="tok-kt">ThrowsError</span> <span class="tok-ow">=</span> <span class="tok-kt">Either</span> <span class="tok-kt">LispError</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>类型构造器和函数一样也能够柯里化并被部分的调用。一个完整的类型可能是Either LispError Integer或者Either LispError LispVal，但是这里我想写成ThrowsError LispVal这样子。我们仅仅将Either类型部分应用于LispError，于是得到了一个能够可以用在任意类型上的构造器ThrowsError。</p>
</div>
<div class="paragraph">
<p>这里Either又是一个Monad的实例。这个例子中，在Either操作中被传递的附加信息是是否在这之间有错误发生。如果Either操作中包含的是一个普通值，那绑定操作就会发生，否则就会跳过计算步骤直接传递一个错误。其它语言中的异常就是这样子的，但由于Haskell的惰性求值机制，这里不需要一个额外的控制结构。如果绑定时已经能够判断这个值是一个错误，那么这个函数就永远不会被调用。</p>
</div>
<div class="paragraph">
<p>除了标准的Monad函数，Either类型还额外提供了另外其他两个函数：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>throwError，传入一个Error类型的值然后将它lift成Either类型的Left构造器。</p>
</li>
<li>
<p>catchError，同时传入一个Either操作和一个将错误转换成另一个Either操作的函数。如果传入的Either操作是一个错误，就会调用传入的函数，举例来讲就会将你的错误通过return转换成一个正常值或者重新抛出另一个错误。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>在我们的程序中，我们会能够将所有类型的错误转换成它们对应的字符串表示，然后作为正常值进行返回。让我们来创建这样的一个辅助函数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="haskell"><span></span><span class="tok-nf">trapError</span> <span class="tok-n">action</span> <span class="tok-ow">=</span> <span class="tok-n">catchError</span> <span class="tok-n">action</span> <span class="tok-p">(</span><span class="tok-n">return</span> <span class="tok-o">.</span> <span class="tok-n">show</span><span class="tok-p">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>调用trapError函数的返回结果是另一个包含合法（Right）数据的Either操作。我们依然需要将数据从Either中抽取出来，这样我们就能讲它传递给其它函数了：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="haskell"><span></span><span class="tok-nf">extractValue</span> <span class="tok-ow">::</span> <span class="tok-kt">ThrowsError</span> <span class="tok-n">a</span> <span class="tok-ow">-&gt;</span> <span class="tok-n">a</span>
<span class="tok-nf">extractValue</span> <span class="tok-p">(</span><span class="tok-kt">Right</span> <span class="tok-n">val</span><span class="tok-p">)</span> <span class="tok-ow">=</span> <span class="tok-n">val</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>我们这里刻意没有定义extractValue函数中传入Left值对应的分支，因为这实际上代表一个程序错误。我们只希望在catchError之后使用extractValue，所以它最好在将不合适的数据注入到其他代码之前就提前挂掉。</p>
</div>
<div class="paragraph">
<p>现在既然所有的基础架构都齐全了，是时候开始尝试使用我们的处理错误机制了。还记得我们的解析器之前在出错时仅仅会返回一个“No match”提示字符串吗？现在我们来让它能够封装并抛出一个原始的ParseError：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="haskell"><span></span><span class="tok-nf">readExpr</span> <span class="tok-ow">::</span> <span class="tok-kt">String</span> <span class="tok-ow">-&gt;</span> <span class="tok-kt">ThrowsError</span> <span class="tok-kt">LispVal</span>
<span class="tok-nf">readExpr</span> <span class="tok-n">input</span> <span class="tok-ow">=</span> <span class="tok-kr">case</span> <span class="tok-n">parse</span> <span class="tok-n">parseExpr</span> <span class="tok-s">&quot;lisp&quot;</span> <span class="tok-n">input</span> <span class="tok-kr">of</span>
     <span class="tok-kt">Left</span> <span class="tok-n">err</span> <span class="tok-ow">-&gt;</span> <span class="tok-n">throwError</span> <span class="tok-o">$</span> <span class="tok-kt">Parser</span> <span class="tok-n">err</span>
     <span class="tok-kt">Right</span> <span class="tok-n">val</span> <span class="tok-ow">-&gt;</span> <span class="tok-n">return</span> <span class="tok-n">val</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>这里我们通过Parser构造器将最初的ParseError封装成了一个LispError类型，然后使用内置的throwError函数让它能够作为一个ThrowsError类型的Monad返回。由于readExpr函数现在会返回一个Monad值了，我们需要将其他分支也用return封装起来。</p>
</div>
<div class="paragraph">
<p>接下来，我们修改eval函数的类型签名让它也根据情况能返回对应Monad值，并且添加一个专门用来在遇到识别不了的模式时抛出异常的分支：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="haskell"><span></span><span class="tok-nf">eval</span> <span class="tok-ow">::</span> <span class="tok-kt">LispVal</span> <span class="tok-ow">-&gt;</span> <span class="tok-kt">ThrowsError</span> <span class="tok-kt">LispVal</span>
<span class="tok-nf">eval</span> <span class="tok-n">val</span><span class="tok-o">@</span><span class="tok-p">(</span><span class="tok-kt">String</span> <span class="tok-kr">_</span><span class="tok-p">)</span> <span class="tok-ow">=</span> <span class="tok-n">return</span> <span class="tok-n">val</span>
<span class="tok-nf">eval</span> <span class="tok-n">val</span><span class="tok-o">@</span><span class="tok-p">(</span><span class="tok-kt">Number</span> <span class="tok-kr">_</span><span class="tok-p">)</span> <span class="tok-ow">=</span> <span class="tok-n">return</span> <span class="tok-n">val</span>
<span class="tok-nf">eval</span> <span class="tok-n">val</span><span class="tok-o">@</span><span class="tok-p">(</span><span class="tok-kt">Bool</span> <span class="tok-kr">_</span><span class="tok-p">)</span> <span class="tok-ow">=</span> <span class="tok-n">return</span> <span class="tok-n">val</span>
<span class="tok-nf">eval</span> <span class="tok-p">(</span><span class="tok-kt">List</span> <span class="tok-p">[</span><span class="tok-kt">Atom</span> <span class="tok-s">&quot;quote&quot;</span><span class="tok-p">,</span> <span class="tok-n">val</span><span class="tok-p">])</span> <span class="tok-ow">=</span> <span class="tok-n">return</span> <span class="tok-n">val</span>
<span class="tok-nf">eval</span> <span class="tok-p">(</span><span class="tok-kt">List</span> <span class="tok-p">(</span><span class="tok-kt">Atom</span> <span class="tok-n">func</span> <span class="tok-kt">:</span> <span class="tok-n">args</span><span class="tok-p">))</span> <span class="tok-ow">=</span> <span class="tok-n">mapM</span> <span class="tok-n">eval</span> <span class="tok-n">args</span> <span class="tok-o">&gt;&gt;=</span> <span class="tok-n">apply</span> <span class="tok-n">func</span>
<span class="tok-nf">eval</span> <span class="tok-n">badForm</span> <span class="tok-ow">=</span> <span class="tok-n">throwError</span> <span class="tok-o">$</span> <span class="tok-kt">BadSpecialForm</span> <span class="tok-s">&quot;Unrecognized special form&quot;</span> <span class="tok-n">badForm</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>由于在函数应用分支中我们会递归的调用eval函数（现在会返回一个Monad值），我们需要进行一点修改。首先我们要把map函数修改成mapM，后者将一个Monad中的函数映射向一个列表并将每个返回值继续作为操作并按顺序进行绑定，最后返回一系列计算结果的列表。而在Error这个Monad中，这一连串操作都会逐一进行计算，除非其中任意一个失败了，那就会抛出一个异常&#8212;&#8203;成功时你会得到一个Right [result]，而失败则是一个Left error。接下来，我们用Monad的绑定操作符来将结果传入被部分应用的apply func，同样当任何操作失败时都返回一个错误。</p>
</div>
<div class="paragraph">
<p>接下来我们来修改apply函数让它也能够在遇到识别不了的模式时抛出错误：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="haskell"><span></span><span class="tok-nf">apply</span> <span class="tok-ow">::</span> <span class="tok-kt">String</span> <span class="tok-ow">-&gt;</span> <span class="tok-p">[</span><span class="tok-kt">LispVal</span><span class="tok-p">]</span> <span class="tok-ow">-&gt;</span> <span class="tok-kt">ThrowsError</span> <span class="tok-kt">LispVal</span>
<span class="tok-nf">apply</span> <span class="tok-n">func</span> <span class="tok-n">args</span> <span class="tok-ow">=</span> <span class="tok-n">maybe</span> <span class="tok-p">(</span><span class="tok-n">throwError</span> <span class="tok-o">$</span> <span class="tok-kt">NotFunction</span> <span class="tok-s">&quot;Unrecognized primitive function args&quot;</span> <span class="tok-n">func</span><span class="tok-p">)</span>
                        <span class="tok-p">(</span><span class="tok-o">$</span> <span class="tok-n">args</span><span class="tok-p">)</span>
                        <span class="tok-p">(</span><span class="tok-n">lookup</span> <span class="tok-n">func</span> <span class="tok-n">primitives</span><span class="tok-p">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>我们没有给函数调用符($ args)添加一个return。这是因为我们接下来会改变primitives函数，使从lookup中返回的函数也会返回一个ThrowsError操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="haskell"><span></span><span class="tok-nf">primitives</span> <span class="tok-ow">::</span> <span class="tok-p">[(</span><span class="tok-kt">String</span><span class="tok-p">,</span> <span class="tok-p">[</span><span class="tok-kt">LispVal</span><span class="tok-p">]</span> <span class="tok-ow">-&gt;</span> <span class="tok-kt">ThrowsError</span> <span class="tok-kt">LispVal</span><span class="tok-p">)]</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>同样，显然我们还需要修改numericBinop函数，让它在只接受到一个参数的时候抛出错误：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="haskell"><span></span><span class="tok-nf">numericBinop</span> <span class="tok-ow">::</span> <span class="tok-p">(</span><span class="tok-kt">Integer</span> <span class="tok-ow">-&gt;</span> <span class="tok-kt">Integer</span> <span class="tok-ow">-&gt;</span> <span class="tok-kt">Integer</span><span class="tok-p">)</span> <span class="tok-ow">-&gt;</span> <span class="tok-p">[</span><span class="tok-kt">LispVal</span><span class="tok-p">]</span> <span class="tok-ow">-&gt;</span> <span class="tok-kt">ThrowsError</span> <span class="tok-kt">LispVal</span>
<span class="tok-nf">numericBinop</span> <span class="tok-n">op</span>           <span class="tok-kt">[]</span>  <span class="tok-ow">=</span> <span class="tok-n">throwError</span> <span class="tok-o">$</span> <span class="tok-kt">NumArgs</span> <span class="tok-mi">2</span> <span class="tok-kt">[]</span>
<span class="tok-nf">numericBinop</span> <span class="tok-n">op</span> <span class="tok-n">singleVal</span><span class="tok-o">@</span><span class="tok-p">[</span><span class="tok-kr">_</span><span class="tok-p">]</span> <span class="tok-ow">=</span> <span class="tok-n">throwError</span> <span class="tok-o">$</span> <span class="tok-kt">NumArgs</span> <span class="tok-mi">2</span> <span class="tok-n">singleVal</span>
<span class="tok-nf">numericBinop</span> <span class="tok-n">op</span> <span class="tok-n">params</span>        <span class="tok-ow">=</span> <span class="tok-n">mapM</span> <span class="tok-n">unpackNum</span> <span class="tok-n">params</span> <span class="tok-o">&gt;&gt;=</span> <span class="tok-n">return</span> <span class="tok-o">.</span> <span class="tok-kt">Number</span> <span class="tok-o">.</span> <span class="tok-n">foldl1</span> <span class="tok-n">op</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>由于需要获取实际传入函数的值用作错误报告，我们这里使用一个at模式来捕捉单值传入的情况。我们对一个单元素列表进行匹配，而且我们实际上不关心它到底是什么。我们同样也需要使用mapM来按顺序连接unpackNum的结果，因为每一次unpackNum调用都可能会因TypeMismatch而出错：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="haskell"><span></span><span class="tok-nf">unpackNum</span> <span class="tok-ow">::</span> <span class="tok-kt">LispVal</span> <span class="tok-ow">-&gt;</span> <span class="tok-kt">ThrowsError</span> <span class="tok-kt">Integer</span>
<span class="tok-nf">unpackNum</span> <span class="tok-p">(</span><span class="tok-kt">Number</span> <span class="tok-n">n</span><span class="tok-p">)</span> <span class="tok-ow">=</span> <span class="tok-n">return</span> <span class="tok-n">n</span>
<span class="tok-nf">unpackNum</span> <span class="tok-p">(</span><span class="tok-kt">String</span> <span class="tok-n">n</span><span class="tok-p">)</span> <span class="tok-ow">=</span> <span class="tok-kr">let</span> <span class="tok-n">parsed</span> <span class="tok-ow">=</span> <span class="tok-n">reads</span> <span class="tok-n">n</span> <span class="tok-kr">in</span>
                           <span class="tok-kr">if</span> <span class="tok-n">null</span> <span class="tok-n">parsed</span>
                             <span class="tok-kr">then</span> <span class="tok-n">throwError</span> <span class="tok-o">$</span> <span class="tok-kt">TypeMismatch</span> <span class="tok-s">&quot;number&quot;</span> <span class="tok-o">$</span> <span class="tok-kt">String</span> <span class="tok-n">n</span>
                             <span class="tok-kr">else</span> <span class="tok-n">return</span> <span class="tok-o">$</span> <span class="tok-n">fst</span> <span class="tok-o">$</span> <span class="tok-n">parsed</span> <span class="tok-o">!!</span> <span class="tok-mi">0</span>
<span class="tok-nf">unpackNum</span> <span class="tok-p">(</span><span class="tok-kt">List</span> <span class="tok-p">[</span><span class="tok-n">n</span><span class="tok-p">])</span> <span class="tok-ow">=</span> <span class="tok-n">unpackNum</span> <span class="tok-n">n</span>
<span class="tok-nf">unpackNum</span> <span class="tok-n">notNum</span>     <span class="tok-ow">=</span> <span class="tok-n">throwError</span> <span class="tok-o">$</span> <span class="tok-kt">TypeMismatch</span> <span class="tok-s">&quot;number&quot;</span> <span class="tok-n">notNum</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>最后，我们需要改变主函数来最终使用这整套Error Monad体系。这貌似有一点复杂，因为现在我们需要同时处理两种Monad（Error和IO）了。事实上，我们需要重新用do代码块来组织逻辑，因为要通过point-free风格来处理这种一个Monad的结果嵌套在另一个Monad中的情况几乎是不可能的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="haskell"><span></span><span class="tok-nf">main</span> <span class="tok-ow">::</span> <span class="tok-kt">IO</span> <span class="tok-nb">()</span>
<span class="tok-nf">main</span> <span class="tok-ow">=</span> <span class="tok-kr">do</span>
     <span class="tok-n">args</span> <span class="tok-ow">&lt;-</span> <span class="tok-n">getArgs</span>
     <span class="tok-n">evaled</span> <span class="tok-ow">&lt;-</span> <span class="tok-n">return</span> <span class="tok-o">$</span> <span class="tok-n">liftM</span> <span class="tok-n">show</span> <span class="tok-o">$</span> <span class="tok-n">readExpr</span> <span class="tok-p">(</span><span class="tok-n">args</span> <span class="tok-o">!!</span> <span class="tok-mi">0</span><span class="tok-p">)</span> <span class="tok-o">&gt;&gt;=</span> <span class="tok-n">eval</span>
     <span class="tok-n">putStrLn</span> <span class="tok-o">$</span> <span class="tok-n">extractValue</span> <span class="tok-o">$</span> <span class="tok-n">trapError</span> <span class="tok-n">evaled</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>现在我们的新函数是这样子的：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>args是命令行参数的列表</p>
</li>
<li>
<p>evaled以下操作的结果</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>获取第一个参数(args !! 0)</p>
</li>
<li>
<p>解析(readExpr)</p>
</li>
<li>
<p>传递给eval函数（&gt;&gt;= eval 绑定符比$符号优先级高）</p>
</li>
<li>
<p>在Error Monad中调用show函数（注意我们整个操作的类型是IO (Either LispError String)，因此evaled的类型是Either LispError String。必须要这样子因为一方面我们的trapError函数需要将Error类型转化成字符串，而另一方面它也需要和正常情况下的类型匹配）</p>
</li>
</ol>
</div>
</li>
<li>
<p>Caught则是以下操作的结果</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>对evaled调用trapError函数，将错误转化成对应的字符串形式</p>
</li>
<li>
<p>调用extractValue函数将Either LispError String操作中的值取出来</p>
</li>
<li>
<p>通过putStrLn函数打印结果。</p>
</li>
</ol>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>编译并运行程序，并尝试抛出一系列异常：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="bash"><span></span>$ ghc -package parsec -o errorcheck <span class="tok-o">[</span>../code/listing5.hs listing5.hs<span class="tok-o">]</span>
$ ./errorcheck <span class="tok-s2">&quot;(+ 2 \&quot;two\&quot;)&quot;</span>
Invalid type: expected number, found <span class="tok-s2">&quot;two&quot;</span>
$ ./errorcheck <span class="tok-s2">&quot;(+ 2)&quot;</span>
Expected <span class="tok-m">2</span> args<span class="tok-p">;</span> found values <span class="tok-m">2</span>
$ ./errorcheck <span class="tok-s2">&quot;(what? 2)&quot;</span>
Unrecognized primitive <span class="tok-k">function</span> args: <span class="tok-s2">&quot;what?&quot;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>一些读者反应这里和之后的一些例子需要添加&#8212;&#8203;make参数才能成功进行编译。实际上这个参数是让GHC编译出一个完整的可执行程序，并搜索出所有在导入声明中列出的依赖。上述的命令尽管在我的系统里工作正常，但是如果你失败的话，加上&#8212;&#8203;make试试。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_求值第二部分">6. 求值：第二部分</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_更多操作部分应用">6.1. 更多操作：部分应用</h3>
<div class="paragraph">
<p>既然现在我们可以来处理类型和参数之类的错误了，我们来重新整理下primitive列表并让它能够处理一些计算以外的事情。我们会添加一些布尔操作符，条件语句和一些基本的字符串操作。</p>
</div>
<div class="paragraph">
<p>从给primitives列表添加以下内容开始：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="haskell"><span></span><span class="tok-p">(</span><span class="tok-s">&quot;=&quot;</span><span class="tok-p">,</span> <span class="tok-n">numBoolBinop</span> <span class="tok-p">(</span><span class="tok-o">==</span><span class="tok-p">)),</span>
<span class="tok-p">(</span><span class="tok-s">&quot;&lt;&quot;</span><span class="tok-p">,</span> <span class="tok-n">numBoolBinop</span> <span class="tok-p">(</span><span class="tok-o">&lt;</span><span class="tok-p">)),</span>
<span class="tok-p">(</span><span class="tok-s">&quot;&gt;&quot;</span><span class="tok-p">,</span> <span class="tok-n">numBoolBinop</span> <span class="tok-p">(</span><span class="tok-o">&gt;</span><span class="tok-p">)),</span>
<span class="tok-p">(</span><span class="tok-s">&quot;/=&quot;</span><span class="tok-p">,</span> <span class="tok-n">numBoolBinop</span> <span class="tok-p">(</span><span class="tok-o">/=</span><span class="tok-p">)),</span>
<span class="tok-p">(</span><span class="tok-s">&quot;&gt;=&quot;</span><span class="tok-p">,</span> <span class="tok-n">numBoolBinop</span> <span class="tok-p">(</span><span class="tok-o">&gt;=</span><span class="tok-p">)),</span>
<span class="tok-p">(</span><span class="tok-s">&quot;&lt;=&quot;</span><span class="tok-p">,</span> <span class="tok-n">numBoolBinop</span> <span class="tok-p">(</span><span class="tok-o">&lt;=</span><span class="tok-p">)),</span>
<span class="tok-p">(</span><span class="tok-s">&quot;&amp;&amp;&quot;</span><span class="tok-p">,</span> <span class="tok-n">boolBoolBinop</span> <span class="tok-p">(</span><span class="tok-o">&amp;&amp;</span><span class="tok-p">)),</span>
<span class="tok-p">(</span><span class="tok-s">&quot;||&quot;</span><span class="tok-p">,</span> <span class="tok-n">boolBoolBinop</span> <span class="tok-p">(</span><span class="tok-o">||</span><span class="tok-p">)),</span>
<span class="tok-p">(</span><span class="tok-s">&quot;string=?&quot;</span><span class="tok-p">,</span> <span class="tok-n">strBoolBinop</span> <span class="tok-p">(</span><span class="tok-o">==</span><span class="tok-p">)),</span>
<span class="tok-p">(</span><span class="tok-s">&quot;string&lt;?&quot;</span><span class="tok-p">,</span> <span class="tok-n">strBoolBinop</span> <span class="tok-p">(</span><span class="tok-o">&lt;</span><span class="tok-p">)),</span>
<span class="tok-p">(</span><span class="tok-s">&quot;string&gt;?&quot;</span><span class="tok-p">,</span> <span class="tok-n">strBoolBinop</span> <span class="tok-p">(</span><span class="tok-o">&gt;</span><span class="tok-p">)),</span>
<span class="tok-p">(</span><span class="tok-s">&quot;string&lt;=?&quot;</span><span class="tok-p">,</span> <span class="tok-n">strBoolBinop</span> <span class="tok-p">(</span><span class="tok-o">&lt;=</span><span class="tok-p">)),</span>
<span class="tok-p">(</span><span class="tok-s">&quot;string&gt;=?&quot;</span><span class="tok-p">,</span> <span class="tok-n">strBoolBinop</span> <span class="tok-p">(</span><span class="tok-o">&gt;=</span><span class="tok-p">)),</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>这里会用到一些我们还没有开始写的辅助函数：numBoolBinop，boolBoolBinop和strBoolBinop。与之前那些读取一些数字参数并返回一个整型的函数不同，这些函数都会读取两个参数并且返回一个布尔值。并且事实上它们仅仅是期望的参数类型不同而已，因此这里我们将逻辑整理成一个通用的boolBinop函数并传入一个会对参数进行处理的解包函数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="haskell"><span></span><span class="tok-nf">boolBinop</span> <span class="tok-ow">::</span> <span class="tok-p">(</span><span class="tok-kt">LispVal</span> <span class="tok-ow">-&gt;</span> <span class="tok-kt">ThrowsError</span> <span class="tok-n">a</span><span class="tok-p">)</span> <span class="tok-ow">-&gt;</span> <span class="tok-p">(</span><span class="tok-n">a</span> <span class="tok-ow">-&gt;</span> <span class="tok-n">a</span> <span class="tok-ow">-&gt;</span> <span class="tok-kt">Bool</span><span class="tok-p">)</span> <span class="tok-ow">-&gt;</span> <span class="tok-p">[</span><span class="tok-kt">LispVal</span><span class="tok-p">]</span> <span class="tok-ow">-&gt;</span> <span class="tok-kt">ThrowsError</span> <span class="tok-kt">LispVal</span>
<span class="tok-nf">boolBinop</span> <span class="tok-n">unpacker</span> <span class="tok-n">op</span> <span class="tok-n">args</span> <span class="tok-ow">=</span> <span class="tok-kr">if</span> <span class="tok-n">length</span> <span class="tok-n">args</span> <span class="tok-o">/=</span> <span class="tok-mi">2</span>
                             <span class="tok-kr">then</span> <span class="tok-n">throwError</span> <span class="tok-o">$</span> <span class="tok-kt">NumArgs</span> <span class="tok-mi">2</span> <span class="tok-n">args</span>
                             <span class="tok-kr">else</span> <span class="tok-kr">do</span> <span class="tok-n">left</span> <span class="tok-ow">&lt;-</span> <span class="tok-n">unpacker</span> <span class="tok-o">$</span> <span class="tok-n">args</span> <span class="tok-o">!!</span> <span class="tok-mi">0</span>
                                      <span class="tok-n">right</span> <span class="tok-ow">&lt;-</span> <span class="tok-n">unpacker</span> <span class="tok-o">$</span> <span class="tok-n">args</span> <span class="tok-o">!!</span> <span class="tok-mi">1</span>
                                      <span class="tok-n">return</span> <span class="tok-o">$</span> <span class="tok-kt">Bool</span> <span class="tok-o">$</span> <span class="tok-n">left</span> <span class="tok-p">`</span><span class="tok-n">op</span><span class="tok-p">`</span> <span class="tok-n">right</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>由于每个参数都有可能会抛出一个类型不匹配的错误，因此我们必须为了Error Monad而在一个do代码块中将它们依次分解。然后再将操作符运用在两个参数上并且将结果用Bool构造器封装起来。任何一个函数都能够通过一对反引号将它变成一个中缀操作符。</p>
</div>
<div class="paragraph">
<p>同时我们也来看下类型签名。boolBinop函数读取两个函数作为它的前两个参数：第一个用来将参数从LispVal类型解包成原生的Haskell类型，而第二个则是实际进行的操作。通过将部分的行为参数化，代码的重用性变得更好了。</p>
</div>
<div class="paragraph">
<p>现在来根据不同情况下的解包函数来通过boolBinop定义三个函数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="haskell"><span></span><span class="tok-nf">numBoolBinop</span>  <span class="tok-ow">=</span> <span class="tok-n">boolBinop</span> <span class="tok-n">unpackNum</span>
<span class="tok-nf">strBoolBinop</span>  <span class="tok-ow">=</span> <span class="tok-n">boolBinop</span> <span class="tok-n">unpackStr</span>
<span class="tok-nf">boolBoolBinop</span> <span class="tok-ow">=</span> <span class="tok-n">boolBinop</span> <span class="tok-n">unpackBool</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>现在我们还没告诉Haskell如何从LispVal类型的值中解包出字符串。这其实和unpackNum函数类似，我们只需要对目标值进行模式匹配并且在失败时抛出错误就行了。同样，如果传入的是一个可以被解释成字符串的其他基本类型（数字或者布尔值）我们也会同样默默将它转换成对应的字符串表达形式。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="haskell"><span></span><span class="tok-nf">unpackStr</span> <span class="tok-ow">::</span> <span class="tok-kt">LispVal</span> <span class="tok-ow">-&gt;</span> <span class="tok-kt">ThrowsError</span> <span class="tok-kt">String</span>
<span class="tok-nf">unpackStr</span> <span class="tok-p">(</span><span class="tok-kt">String</span> <span class="tok-n">s</span><span class="tok-p">)</span> <span class="tok-ow">=</span> <span class="tok-n">return</span> <span class="tok-n">s</span>
<span class="tok-nf">unpackStr</span> <span class="tok-p">(</span><span class="tok-kt">Number</span> <span class="tok-n">s</span><span class="tok-p">)</span> <span class="tok-ow">=</span> <span class="tok-n">return</span> <span class="tok-o">$</span> <span class="tok-n">show</span> <span class="tok-n">s</span>
<span class="tok-nf">unpackStr</span> <span class="tok-p">(</span><span class="tok-kt">Bool</span> <span class="tok-n">s</span><span class="tok-p">)</span>   <span class="tok-ow">=</span> <span class="tok-n">return</span> <span class="tok-o">$</span> <span class="tok-n">show</span> <span class="tok-n">s</span>
<span class="tok-nf">unpackStr</span> <span class="tok-n">notString</span>  <span class="tok-ow">=</span> <span class="tok-n">throwError</span> <span class="tok-o">$</span> <span class="tok-kt">TypeMismatch</span> <span class="tok-s">&quot;string&quot;</span> <span class="tok-n">notString</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>使用类似的代码来对布尔值解包：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="haskell"><span></span><span class="tok-nf">unpackBool</span> <span class="tok-ow">::</span> <span class="tok-kt">LispVal</span> <span class="tok-ow">-&gt;</span> <span class="tok-kt">ThrowsError</span> <span class="tok-kt">Bool</span>
<span class="tok-nf">unpackBool</span> <span class="tok-p">(</span><span class="tok-kt">Bool</span> <span class="tok-n">b</span><span class="tok-p">)</span> <span class="tok-ow">=</span> <span class="tok-n">return</span> <span class="tok-n">b</span>
<span class="tok-nf">unpackBool</span> <span class="tok-n">notBool</span>  <span class="tok-ow">=</span> <span class="tok-n">throwError</span> <span class="tok-o">$</span> <span class="tok-kt">TypeMismatch</span> <span class="tok-s">&quot;boolean&quot;</span> <span class="tok-n">notBool</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>在进入下一步之前，先编译并运行几个例子来看看它是否正确：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="bash"><span></span>$ ghc -package parsec -o simple_parser <span class="tok-o">[</span>../code/listing6.1.hs listing6.1.hs<span class="tok-o">]</span>
$ ./simple_parser <span class="tok-s2">&quot;(&lt; 2 3)&quot;</span>
<span class="tok-c1">#t</span>
$ ./simple_parser <span class="tok-s2">&quot;(&gt; 2 3)&quot;</span>
<span class="tok-c1">#f</span>
$ ./simple_parser <span class="tok-s2">&quot;(&gt;= 3 3)&quot;</span>
<span class="tok-c1">#t</span>
$ ./simple_parser <span class="tok-s2">&quot;(string=? \&quot;test\&quot;  \&quot;test\&quot;)&quot;</span>
<span class="tok-c1">#t</span>
$ ./simple_parser <span class="tok-s2">&quot;(string&lt;? \&quot;abc\&quot; \&quot;bba\&quot;)&quot;</span>
<span class="tok-c1">#t</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_条件模式匹配">6.2. 条件：模式匹配</h3>
<div class="paragraph">
<p>现在，我们继续将if语句添加到我们的求值器中。根据Scheme标准，我们这里会认为除了#f以外的其他所有值都是True：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="haskell"><span></span><span class="tok-nf">eval</span> <span class="tok-p">(</span><span class="tok-kt">List</span> <span class="tok-p">[</span><span class="tok-kt">Atom</span> <span class="tok-s">&quot;if&quot;</span><span class="tok-p">,</span> <span class="tok-n">pred</span><span class="tok-p">,</span> <span class="tok-n">conseq</span><span class="tok-p">,</span> <span class="tok-n">alt</span><span class="tok-p">])</span> <span class="tok-ow">=</span>
     <span class="tok-kr">do</span> <span class="tok-n">result</span> <span class="tok-ow">&lt;-</span> <span class="tok-n">eval</span> <span class="tok-n">pred</span>
        <span class="tok-kr">case</span> <span class="tok-n">result</span> <span class="tok-kr">of</span>
             <span class="tok-kt">Bool</span> <span class="tok-kt">False</span> <span class="tok-ow">-&gt;</span> <span class="tok-n">eval</span> <span class="tok-n">alt</span>
             <span class="tok-n">otherwise</span>  <span class="tok-ow">-&gt;</span> <span class="tok-n">eval</span> <span class="tok-n">conseq</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>由于函数定义是会被依次进行计算的，这部分记得需要放在 <code>eval (List (Atom func : args)) = mapM eval args &gt;&gt;= apply func</code> 前面不然它会抛出一个Unrecognized primitive function args: "if"错误。</p>
</div>
<div class="paragraph">
<p>这又是一个嵌套模式匹配的例子。这里，我们要匹配一个四元素的列表。其他第一元素元素必须是Atom类型的if，其他则可能是任意的Scheme类型。我们求出pred的值，如果它是False的，则函数返回alt的值，否则的话，我们计算并返回conseq的值。</p>
</div>
<div class="paragraph">
<p>编译并运行程序，你就能尝试使用条件分支了：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="bash"><span></span>$ ghc -package parsec -o simple_parser <span class="tok-o">[</span>../code/listing6.2.hs listing6.2.hs<span class="tok-o">]</span>
$ ./simple_parser <span class="tok-s2">&quot;(if (&gt; 2 3) \&quot;no\&quot; \&quot;yes\&quot;)&quot;</span>
<span class="tok-s2">&quot;yes&quot;</span>
$ ./simple_parser <span class="tok-s2">&quot;(if (= 3 3) (+ 2 3 (- 5 1)) \&quot;unequal\&quot;)&quot;</span>
<span class="tok-m">9</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_列表操作carcdr和cons">6.3. 列表操作：car、cdr和cons</h3>
<div class="paragraph">
<p>接下来我们将一些基本的列表操作添加到primitives中。由于我们已经选择了使用Haskell的代数类型而不是Pair类型来表达列表了，因此这里的定义就反而可能比在大部分Lisp里更加复杂一点。通过打印出来得S表达式也许你能够更加容易的理解它们的效果：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>(car '(a b c)) = a</p>
</li>
<li>
<p>(car '(a)) = a</p>
</li>
<li>
<p>(car '(a b . c)) = a</p>
</li>
<li>
<p>(car 'a) = error – not a list</p>
</li>
<li>
<p>(car 'a 'b) = error – car only takes one argument</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>我们可以直接将它们翻译成对应的模式匹配子句，记得(x:xs)会将一个列表分割成第一个元素以及接下来的其他部分：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="haskell"><span></span><span class="tok-nf">car</span> <span class="tok-ow">::</span> <span class="tok-p">[</span><span class="tok-kt">LispVal</span><span class="tok-p">]</span> <span class="tok-ow">-&gt;</span> <span class="tok-kt">ThrowsError</span> <span class="tok-kt">LispVal</span>
<span class="tok-nf">car</span> <span class="tok-p">[</span><span class="tok-kt">List</span> <span class="tok-p">(</span><span class="tok-n">x</span> <span class="tok-kt">:</span> <span class="tok-n">xs</span><span class="tok-p">)]</span>         <span class="tok-ow">=</span> <span class="tok-n">return</span> <span class="tok-n">x</span>
<span class="tok-nf">car</span> <span class="tok-p">[</span><span class="tok-kt">DottedList</span> <span class="tok-p">(</span><span class="tok-n">x</span> <span class="tok-kt">:</span> <span class="tok-n">xs</span><span class="tok-p">)</span> <span class="tok-kr">_</span><span class="tok-p">]</span> <span class="tok-ow">=</span> <span class="tok-n">return</span> <span class="tok-n">x</span>
<span class="tok-nf">car</span> <span class="tok-p">[</span><span class="tok-n">badArg</span><span class="tok-p">]</span>                <span class="tok-ow">=</span> <span class="tok-n">throwError</span> <span class="tok-o">$</span> <span class="tok-kt">TypeMismatch</span> <span class="tok-s">&quot;pair&quot;</span> <span class="tok-n">badArg</span>
<span class="tok-nf">car</span> <span class="tok-n">badArgList</span>              <span class="tok-ow">=</span> <span class="tok-n">throwError</span> <span class="tok-o">$</span> <span class="tok-kt">NumArgs</span> <span class="tok-mi">1</span> <span class="tok-n">badArgList</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>cdr函数也是同样：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>(cdr '(a b c)) = (b c)</p>
</li>
<li>
<p>(cdr '(a b)) = (b)</p>
</li>
<li>
<p>(cdr '(a)) = NIL</p>
</li>
<li>
<p>(cdr '(a . b)) = b</p>
</li>
<li>
<p>(cdr '(a b . c)) = (b . c)</p>
</li>
<li>
<p>(cdr 'a) = error – not a list</p>
</li>
<li>
<p>(cdr 'a 'b) = error – too many arguments</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>我们可以用一个子句来代表前三种情况。我们的解析器将 <code>'()</code> 认为是一个空列表 <code>[]</code> ，并且当你使用 <code>(x:xs)</code> 来对 <code>[x]</code> 进行匹配时， <code>xs</code> 会绑定到一个空列表 <code>[]</code> 。其他的情况我们都用单独的子句来表示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="haskell"><span></span><span class="tok-nf">cdr</span> <span class="tok-ow">::</span> <span class="tok-p">[</span><span class="tok-kt">LispVal</span><span class="tok-p">]</span> <span class="tok-ow">-&gt;</span> <span class="tok-kt">ThrowsError</span> <span class="tok-kt">LispVal</span>
<span class="tok-nf">cdr</span> <span class="tok-p">[</span><span class="tok-kt">List</span> <span class="tok-p">(</span><span class="tok-n">x</span> <span class="tok-kt">:</span> <span class="tok-n">xs</span><span class="tok-p">)]</span>         <span class="tok-ow">=</span> <span class="tok-n">return</span> <span class="tok-o">$</span> <span class="tok-kt">List</span> <span class="tok-n">xs</span>
<span class="tok-nf">cdr</span> <span class="tok-p">[</span><span class="tok-kt">DottedList</span> <span class="tok-p">[</span><span class="tok-kr">_</span><span class="tok-p">]</span> <span class="tok-n">x</span><span class="tok-p">]</span>      <span class="tok-ow">=</span> <span class="tok-n">return</span> <span class="tok-n">x</span>
<span class="tok-nf">cdr</span> <span class="tok-p">[</span><span class="tok-kt">DottedList</span> <span class="tok-p">(</span><span class="tok-kr">_</span> <span class="tok-kt">:</span> <span class="tok-n">xs</span><span class="tok-p">)</span> <span class="tok-n">x</span><span class="tok-p">]</span> <span class="tok-ow">=</span> <span class="tok-n">return</span> <span class="tok-o">$</span> <span class="tok-kt">DottedList</span> <span class="tok-n">xs</span> <span class="tok-n">x</span>
<span class="tok-nf">cdr</span> <span class="tok-p">[</span><span class="tok-n">badArg</span><span class="tok-p">]</span>                <span class="tok-ow">=</span> <span class="tok-n">throwError</span> <span class="tok-o">$</span> <span class="tok-kt">TypeMismatch</span> <span class="tok-s">&quot;pair&quot;</span> <span class="tok-n">badArg</span>
<span class="tok-nf">cdr</span> <span class="tok-n">badArgList</span>              <span class="tok-ow">=</span> <span class="tok-n">throwError</span> <span class="tok-o">$</span> <span class="tok-kt">NumArgs</span> <span class="tok-mi">1</span> <span class="tok-n">badArgList</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>cons函数会有一点棘手，所以我们还是来一个个看下各种可能发生的情况吧。如果你将任何一个值和空列表（Nil）通过cons结合，那么你就会得到一个单元素的列表，Nil会充当一个终止符：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="haskell"><span></span><span class="tok-nf">cons</span> <span class="tok-ow">::</span> <span class="tok-p">[</span><span class="tok-kt">LispVal</span><span class="tok-p">]</span> <span class="tok-ow">-&gt;</span> <span class="tok-kt">ThrowsError</span> <span class="tok-kt">LispVal</span>
<span class="tok-nf">cons</span> <span class="tok-p">[</span><span class="tok-n">x1</span><span class="tok-p">,</span> <span class="tok-kt">List</span> <span class="tok-kt">[]</span><span class="tok-p">]</span> <span class="tok-ow">=</span> <span class="tok-n">return</span> <span class="tok-o">$</span> <span class="tok-kt">List</span> <span class="tok-p">[</span><span class="tok-n">x1</span><span class="tok-p">]</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你将任意值和一个列表通过cons结合，这就像是就那个值插进列表的最前面：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="haskell"><span></span><span class="tok-nf">cons</span> <span class="tok-p">[</span><span class="tok-n">x</span><span class="tok-p">,</span> <span class="tok-kt">List</span> <span class="tok-n">xs</span><span class="tok-p">]</span> <span class="tok-ow">=</span> <span class="tok-n">return</span> <span class="tok-o">$</span> <span class="tok-kt">List</span> <span class="tok-o">$</span> <span class="tok-n">x</span> <span class="tok-kt">:</span> <span class="tok-n">xs</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>然后，如果你处理的是一个DottedList，那你需要考虑不正确的尾元素的情况并让它保持还是一个合法的DottedList：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="haskell"><span></span><span class="tok-nf">cons</span> <span class="tok-p">[</span><span class="tok-n">x</span><span class="tok-p">,</span> <span class="tok-kt">DottedList</span> <span class="tok-n">xs</span> <span class="tok-n">xlast</span><span class="tok-p">]</span> <span class="tok-ow">=</span> <span class="tok-n">return</span> <span class="tok-o">$</span> <span class="tok-kt">DottedList</span> <span class="tok-p">(</span><span class="tok-n">x</span> <span class="tok-kt">:</span> <span class="tok-n">xs</span><span class="tok-p">)</span> <span class="tok-n">xlast</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你把两个都不是列表的对象通过cons组合，或者把列表作为第一个参数，那就会得到一个DottedList。这是因为这样通过cons组合的部分不像其他普通列表那样由一个Nil来终结的缘故。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="haskell"><span></span><span class="tok-nf">cons</span> <span class="tok-p">[</span><span class="tok-n">x1</span><span class="tok-p">,</span> <span class="tok-n">x2</span><span class="tok-p">]</span> <span class="tok-ow">=</span> <span class="tok-n">return</span> <span class="tok-o">$</span> <span class="tok-kt">DottedList</span> <span class="tok-p">[</span><span class="tok-n">x1</span><span class="tok-p">]</span> <span class="tok-n">x2</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>最后，任意传入大于或小于两个参数的情况都会引起错误：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="haskell"><span></span><span class="tok-nf">cons</span> <span class="tok-n">badArgList</span> <span class="tok-ow">=</span> <span class="tok-n">throwError</span> <span class="tok-o">$</span> <span class="tok-kt">NumArgs</span> <span class="tok-mi">2</span> <span class="tok-n">badArgList</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>我们的最后一步是实现一个 <code>eqv?</code> 函数。Scheme提供了三种不同程度的相等断言： <code>eq?</code> ， <code>eqv?</code> 以及 <code>equal?</code> 。对我们来说， <code>eq?</code> 和 <code>eqv?</code> 基本上是一样的：如果两个值打印出来的结果是一样的，那它们就相等，虽然貌似这样运行起来也许会比较慢。所以我们这里就为它们两个提供一个实现并且将它注册成 <code>eq?</code> 和 <code>eqv?</code> 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="haskell"><span></span><span class="tok-nf">eqv</span> <span class="tok-ow">::</span> <span class="tok-p">[</span><span class="tok-kt">LispVal</span><span class="tok-p">]</span> <span class="tok-ow">-&gt;</span> <span class="tok-kt">ThrowsError</span> <span class="tok-kt">LispVal</span>
<span class="tok-nf">eqv</span> <span class="tok-p">[(</span><span class="tok-kt">Bool</span> <span class="tok-n">arg1</span><span class="tok-p">),</span> <span class="tok-p">(</span><span class="tok-kt">Bool</span> <span class="tok-n">arg2</span><span class="tok-p">)]</span>             <span class="tok-ow">=</span> <span class="tok-n">return</span> <span class="tok-o">$</span> <span class="tok-kt">Bool</span> <span class="tok-o">$</span> <span class="tok-n">arg1</span> <span class="tok-o">==</span> <span class="tok-n">arg2</span>
<span class="tok-nf">eqv</span> <span class="tok-p">[(</span><span class="tok-kt">Number</span> <span class="tok-n">arg1</span><span class="tok-p">),</span> <span class="tok-p">(</span><span class="tok-kt">Number</span> <span class="tok-n">arg2</span><span class="tok-p">)]</span>         <span class="tok-ow">=</span> <span class="tok-n">return</span> <span class="tok-o">$</span> <span class="tok-kt">Bool</span> <span class="tok-o">$</span> <span class="tok-n">arg1</span> <span class="tok-o">==</span> <span class="tok-n">arg2</span>
<span class="tok-nf">eqv</span> <span class="tok-p">[(</span><span class="tok-kt">String</span> <span class="tok-n">arg1</span><span class="tok-p">),</span> <span class="tok-p">(</span><span class="tok-kt">String</span> <span class="tok-n">arg2</span><span class="tok-p">)]</span>         <span class="tok-ow">=</span> <span class="tok-n">return</span> <span class="tok-o">$</span> <span class="tok-kt">Bool</span> <span class="tok-o">$</span> <span class="tok-n">arg1</span> <span class="tok-o">==</span> <span class="tok-n">arg2</span>
<span class="tok-nf">eqv</span> <span class="tok-p">[(</span><span class="tok-kt">Atom</span> <span class="tok-n">arg1</span><span class="tok-p">),</span> <span class="tok-p">(</span><span class="tok-kt">Atom</span> <span class="tok-n">arg2</span><span class="tok-p">)]</span>             <span class="tok-ow">=</span> <span class="tok-n">return</span> <span class="tok-o">$</span> <span class="tok-kt">Bool</span> <span class="tok-o">$</span> <span class="tok-n">arg1</span> <span class="tok-o">==</span> <span class="tok-n">arg2</span>
<span class="tok-nf">eqv</span> <span class="tok-p">[(</span><span class="tok-kt">DottedList</span> <span class="tok-n">xs</span> <span class="tok-n">x</span><span class="tok-p">),</span> <span class="tok-p">(</span><span class="tok-kt">DottedList</span> <span class="tok-n">ys</span> <span class="tok-n">y</span><span class="tok-p">)]</span> <span class="tok-ow">=</span> <span class="tok-n">eqv</span> <span class="tok-p">[</span><span class="tok-kt">List</span> <span class="tok-o">$</span> <span class="tok-n">xs</span> <span class="tok-o">++</span> <span class="tok-p">[</span><span class="tok-n">x</span><span class="tok-p">],</span> <span class="tok-kt">List</span> <span class="tok-o">$</span> <span class="tok-n">ys</span> <span class="tok-o">++</span> <span class="tok-p">[</span><span class="tok-n">y</span><span class="tok-p">]]</span>
<span class="tok-nf">eqv</span> <span class="tok-p">[(</span><span class="tok-kt">List</span> <span class="tok-n">arg1</span><span class="tok-p">),</span> <span class="tok-p">(</span><span class="tok-kt">List</span> <span class="tok-n">arg2</span><span class="tok-p">)]</span>             <span class="tok-ow">=</span> <span class="tok-n">return</span> <span class="tok-o">$</span> <span class="tok-kt">Bool</span> <span class="tok-o">$</span> <span class="tok-p">(</span><span class="tok-n">length</span> <span class="tok-n">arg1</span> <span class="tok-o">==</span> <span class="tok-n">length</span> <span class="tok-n">arg2</span><span class="tok-p">)</span> <span class="tok-o">&amp;&amp;</span>
                                                             <span class="tok-p">(</span><span class="tok-n">all</span> <span class="tok-n">eqvPair</span> <span class="tok-o">$</span> <span class="tok-n">zip</span> <span class="tok-n">arg1</span> <span class="tok-n">arg2</span><span class="tok-p">)</span>
     <span class="tok-kr">where</span> <span class="tok-n">eqvPair</span> <span class="tok-p">(</span><span class="tok-n">x1</span><span class="tok-p">,</span> <span class="tok-n">x2</span><span class="tok-p">)</span> <span class="tok-ow">=</span> <span class="tok-kr">case</span> <span class="tok-n">eqv</span> <span class="tok-p">[</span><span class="tok-n">x1</span><span class="tok-p">,</span> <span class="tok-n">x2</span><span class="tok-p">]</span> <span class="tok-kr">of</span>
                                <span class="tok-kt">Left</span> <span class="tok-n">err</span> <span class="tok-ow">-&gt;</span> <span class="tok-kt">False</span>
                                <span class="tok-kt">Right</span> <span class="tok-p">(</span><span class="tok-kt">Bool</span> <span class="tok-n">val</span><span class="tok-p">)</span> <span class="tok-ow">-&gt;</span> <span class="tok-n">val</span>
<span class="tok-nf">eqv</span> <span class="tok-p">[</span><span class="tok-kr">_</span><span class="tok-p">,</span> <span class="tok-kr">_</span><span class="tok-p">]</span>                                 <span class="tok-ow">=</span> <span class="tok-n">return</span> <span class="tok-o">$</span> <span class="tok-kt">Bool</span> <span class="tok-kt">False</span>
<span class="tok-nf">eqv</span> <span class="tok-n">badArgList</span>                             <span class="tok-ow">=</span> <span class="tok-n">throwError</span> <span class="tok-o">$</span> <span class="tok-kt">NumArgs</span> <span class="tok-mi">2</span> <span class="tok-n">badArgList</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>除了处理两个List值的部分，其他子句大多都是自解释的。这里，在检查确认了两个列表是相等的长度之后，使用zip函数将列表配对并一一进行对比。eqvPair函数式一个局部定义的例子：它用where关键词来定义，除了它的作用域仅仅是eqv函数的一个子句，其他都和普通的函数一样。这里由于我们已经知道eqv函数只会在传递给它的不是两个参数的时候才会抛出一个错误，因此Left err &#8594; False这行其实是永远也不会被执行的。</p>
</div>
</div>
<div class="sect2">
<h3 id="_equal和弱类型异构列表">6.4. equal?和弱类型：异构列表</h3>
<div class="paragraph">
<p>之前我们已经介绍过有关弱类型的概念了，因此这里我们尝试创建一个equal?函数，它会忽视类型并仅仅判断两个值是否能被解释成相同的结果。举个栗子，(eqv? 2 "2") = #f，但我们希望能够得到(equal? 2 "2") = #t。基本上，我们需要尝试所有的解包方法，如果它们中的任何一个会让对应的Haskell值相等，那就返回True。</p>
</div>
<div class="paragraph">
<p>一个显而易见的方法就是把所有解包的函数都放进一个列表里然后通过mapM函数让它们逐个执行。然而很不幸你没法这么干，因为Haskell不允许你将不同类型的值放进同一个列表中。各式各样的解包函数显然会返回不同的类型，因此你没法将它们存在一起。</p>
</div>
<div class="paragraph">
<p>我们这里需要使用一个GHC的扩展包&#8212;&#8203;Existential Types，来使用异构列表，虽然它仍然需要受到类型类的约束。扩展在Haskell的使用当中是相当常见的：基本上你如果需要写一些靠谱的大型程序都会或多或少用刀，它们也往往能互相兼容（Existential Types在Hugs和GHC里都运行良好并且很有希望被纳入Haskell标准）。注意你需要使用一个特别的编译参数来开启这个功能：-fglasgow-exts。也可以添加-XExistentialQuantification或者是在程序的最开始加上这么一段注解{-# LANGUAGE ExistentialQuantification <mark>-}。（总的来说，编译时的参数位-Xfoo都可以被在源代码中的{-</mark> LANGUAGE foo #-}注解来替代。）</p>
</div>
<div class="paragraph">
<p>首先我们需要定义一个能够表示LispVal &#8594; something的函数的类型，只要这个something能够支持判等：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="haskell"><span></span><span class="tok-kr">data</span> <span class="tok-kt">Unpacker</span> <span class="tok-ow">=</span> <span class="tok-n">forall</span> <span class="tok-n">a</span><span class="tok-o">.</span> <span class="tok-kt">Eq</span> <span class="tok-n">a</span> <span class="tok-ow">=&gt;</span> <span class="tok-kt">AnyUnpacker</span> <span class="tok-p">(</span><span class="tok-kt">LispVal</span> <span class="tok-ow">-&gt;</span> <span class="tok-kt">ThrowsError</span> <span class="tok-n">a</span><span class="tok-p">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>这里和其他普通的代数数据类型都是类似的，除了这里有一个类型限制。它表示“对于任意是Eq实例的类型，你可以定义一个读取一个将LispVal转换成那个类型并且有可能抛出错误的函数作为参数的Unpacker类型”。我们将这个函数通过AnyUnpacker构造器进行封装，然后我们就可以创建一个Unpacker列表来实现我们之前想要的效果。</p>
</div>
<div class="paragraph">
<p>在equal?函数的定义之前，我们来首先来看一个读取一个Unpacker类型然后判断两个LispVal值在解包后是否相等的的辅助函数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="haskell"><span></span><span class="tok-nf">unpackEquals</span> <span class="tok-ow">::</span> <span class="tok-kt">LispVal</span> <span class="tok-ow">-&gt;</span> <span class="tok-kt">LispVal</span> <span class="tok-ow">-&gt;</span> <span class="tok-kt">Unpacker</span> <span class="tok-ow">-&gt;</span> <span class="tok-kt">ThrowsError</span> <span class="tok-kt">Bool</span>
<span class="tok-nf">unpackEquals</span> <span class="tok-n">arg1</span> <span class="tok-n">arg2</span> <span class="tok-p">(</span><span class="tok-kt">AnyUnpacker</span> <span class="tok-n">unpacker</span><span class="tok-p">)</span> <span class="tok-ow">=</span>
             <span class="tok-kr">do</span> <span class="tok-n">unpacked1</span> <span class="tok-ow">&lt;-</span> <span class="tok-n">unpacker</span> <span class="tok-n">arg1</span>
                <span class="tok-n">unpacked2</span> <span class="tok-ow">&lt;-</span> <span class="tok-n">unpacker</span> <span class="tok-n">arg2</span>
                <span class="tok-n">return</span> <span class="tok-o">$</span> <span class="tok-n">unpacked1</span> <span class="tok-o">==</span> <span class="tok-n">unpacked2</span>
        <span class="tok-p">`</span><span class="tok-n">catchError</span><span class="tok-p">`</span> <span class="tok-p">(</span><span class="tok-n">const</span> <span class="tok-o">$</span> <span class="tok-n">return</span> <span class="tok-kt">False</span><span class="tok-p">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>在通过模式匹配获取实际的解包函数之后，我们进入了一个ThrowsError Monad的do代码块。这里我们获取两个LispVal值在Haskell中对应的值然后对它们进行比较。如果在解包的过程中发生了任何错误，就也会返回一个False，这里由于catchError函数需要我们传递一个函数用来处理错误值，我们就直接使用const函数就可以了。</p>
</div>
<div class="paragraph">
<p>最后，我们给出equal?函数的定义。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="haskell"><span></span><span class="tok-nf">equal</span> <span class="tok-ow">::</span> <span class="tok-p">[</span><span class="tok-kt">LispVal</span><span class="tok-p">]</span> <span class="tok-ow">-&gt;</span> <span class="tok-kt">ThrowsError</span> <span class="tok-kt">LispVal</span>
<span class="tok-nf">equal</span> <span class="tok-p">[</span><span class="tok-n">arg1</span><span class="tok-p">,</span> <span class="tok-n">arg2</span><span class="tok-p">]</span> <span class="tok-ow">=</span> <span class="tok-kr">do</span>
      <span class="tok-n">primitiveEquals</span> <span class="tok-ow">&lt;-</span> <span class="tok-n">liftM</span> <span class="tok-n">or</span> <span class="tok-o">$</span> <span class="tok-n">mapM</span> <span class="tok-p">(</span><span class="tok-n">unpackEquals</span> <span class="tok-n">arg1</span> <span class="tok-n">arg2</span><span class="tok-p">)</span>
                         <span class="tok-p">[</span><span class="tok-kt">AnyUnpacker</span> <span class="tok-n">unpackNum</span><span class="tok-p">,</span> <span class="tok-kt">AnyUnpacker</span> <span class="tok-n">unpackStr</span><span class="tok-p">,</span> <span class="tok-kt">AnyUnpacker</span> <span class="tok-n">unpackBool</span><span class="tok-p">]</span>
      <span class="tok-n">eqvEquals</span> <span class="tok-ow">&lt;-</span> <span class="tok-n">eqv</span> <span class="tok-p">[</span><span class="tok-n">arg1</span><span class="tok-p">,</span> <span class="tok-n">arg2</span><span class="tok-p">]</span>
      <span class="tok-n">return</span> <span class="tok-o">$</span> <span class="tok-kt">Bool</span> <span class="tok-o">$</span> <span class="tok-p">(</span><span class="tok-n">primitiveEquals</span> <span class="tok-o">||</span> <span class="tok-kr">let</span> <span class="tok-p">(</span><span class="tok-kt">Bool</span> <span class="tok-n">x</span><span class="tok-p">)</span> <span class="tok-ow">=</span> <span class="tok-n">eqvEquals</span> <span class="tok-kr">in</span> <span class="tok-n">x</span><span class="tok-p">)</span>
<span class="tok-nf">equal</span> <span class="tok-n">badArgList</span> <span class="tok-ow">=</span> <span class="tok-n">throwError</span> <span class="tok-o">$</span> <span class="tok-kt">NumArgs</span> <span class="tok-mi">2</span> <span class="tok-n">badArgList</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>这里第一步操作创建了一个异构列表[unpackNum, unpackStr, unpackBool]，然后将一个被部分应用的(unpackEquals arg1 arg2)映射到它上面。得到一个布尔值列表后，我们使用Prelude中的函数or，如果其中任意一个结果是True则为True。</p>
</div>
<div class="paragraph">
<p>第二部操作使用eqv?函数对两个参数进行测试。因为我们希望equal?会比eqv?更加宽松的缘故。因此如果eqv?返回True的话，这里也应该直接返回True。这就让我们能够避免处理一些类似于列表或者DottedList的情况了。（事实上这里引入了一个bug；练习2会提到）</p>
</div>
<div class="paragraph">
<p>最后，将上面的值用or连接起来并且将结果封装在一个Bool构造器里，从而返回一个LispVal。let (Bool x) = eqvEquals in x是一个便捷的从代数类型中分解值得方式：通过模式匹配将eqvEquals中包含的值取出然后返回。这个let表达式的结果即是关键词in之后的部分。</p>
</div>
<div class="paragraph">
<p>将函数插入到primitives列表中好让它们能够被使用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="haskell"><span></span><span class="tok-p">(</span><span class="tok-s">&quot;car&quot;</span><span class="tok-p">,</span> <span class="tok-n">car</span><span class="tok-p">),</span>
<span class="tok-p">(</span><span class="tok-s">&quot;cdr&quot;</span><span class="tok-p">,</span> <span class="tok-n">cdr</span><span class="tok-p">),</span>
<span class="tok-p">(</span><span class="tok-s">&quot;cons&quot;</span><span class="tok-p">,</span> <span class="tok-n">cons</span><span class="tok-p">),</span>
<span class="tok-p">(</span><span class="tok-s">&quot;eq?&quot;</span><span class="tok-p">,</span> <span class="tok-n">eqv</span><span class="tok-p">),</span>
<span class="tok-p">(</span><span class="tok-s">&quot;eqv?&quot;</span><span class="tok-p">,</span> <span class="tok-n">eqv</span><span class="tok-p">),</span>
<span class="tok-p">(</span><span class="tok-s">&quot;equal?&quot;</span><span class="tok-p">,</span> <span class="tok-n">equal</span><span class="tok-p">)]</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>你需要通过-fglasgow-exts参数来开启GHC扩展功能来进行编译这段代码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="bash"><span></span>$ ghc -package parsec -fglasgow-exts -o parser <span class="tok-o">[</span>../code/listing6.4.hs listing6.4.hs<span class="tok-o">]</span>
$ ./parser <span class="tok-s2">&quot;(cdr &#39;(a simple test))&quot;</span>
<span class="tok-o">(</span>simple <span class="tok-nb">test</span><span class="tok-o">)</span>
$ ./parser <span class="tok-s2">&quot;(car (cdr &#39;(a simple test)))&quot;</span>
simple
$ ./parser <span class="tok-s2">&quot;(car &#39;((this is) a test))&quot;</span>
<span class="tok-o">(</span>this is<span class="tok-o">)</span>
$ ./parser <span class="tok-s2">&quot;(cons &#39;(this is) &#39;test)&quot;</span>
<span class="tok-o">((</span>this is<span class="tok-o">)</span> . <span class="tok-nb">test</span><span class="tok-o">)</span>
$ ./parser <span class="tok-s2">&quot;(cons &#39;(this is) &#39;())&quot;</span>
<span class="tok-o">((</span>this is<span class="tok-o">))</span>
$ ./parser <span class="tok-s2">&quot;(eqv? 1 3)&quot;</span>
<span class="tok-c1">#f</span>
$ ./parser <span class="tok-s2">&quot;(eqv? 3 3)&quot;</span>
<span class="tok-c1">#t</span>
$ ./parser <span class="tok-s2">&quot;(eqv? &#39;atom &#39;atom)&quot;</span>
<span class="tok-c1">#t</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_习题_4">6.5. 习题</h3>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>改变if函数的定义让它只接受Bool类型的值并在其他情况下抛出异常而不是把所有不是False的值都当做True。</p>
</li>
<li>
<p>equal?函数有一个bug由于在列表中的值都是通过eqv?而不是equal?来比较的。例如，(equal? '(1 "2") '(1 2))会得到一个False，而你也许会希望获得True。修改equal?函数让它在对列表进行递归计算的时候也会忽略类型。你可以模仿eqv?函数来显示的定义它也可以将处理list的情况另外创建一个辅助函数来处理，并且将它判等时使用的函数进行参数化。</p>
</li>
<li>
<p>实现cond和case表达式</p>
</li>
<li>
<p>添加剩下的字符串函数。你现在可能还没法实现一个自己的string-set!，这在Haskell里有点难实现，不过在接下来的两章之后你可能就能够实现它了。</p>
</li>
</ol>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2021-07-14 20:08:15 +0800
</div>
</div>
</body>
</html>