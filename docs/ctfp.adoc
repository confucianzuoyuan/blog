= 写给程序员的范畴论
:icons: font
:source-highlighter: pygments
:toc: left
:toclevels: 4
:sectnums:

== 序

> 我打算为程序猿们写一本讲范畴论的书已经有一段时间了。注意，受众不是计算机科学家，而是程序猿——是工程师，而不是科学家。这听起来挺疯狂，我也有些诚惶诚恐，但是我无法容忍科学与工程之间存在着巨大的鸿沟，更何况我自身的工作也是经常需要我在这两个世界中穿梭。不过，要解释一些东西，总让我感觉非常窘迫。我非常敬仰 Richard Feynman（理查德·费恩曼），在讲授知识方面他是深入浅出的大师。我不是 Feynman，但我会尽力。我从发布这篇序言开始，激励读者学习范畴论，希望能引发一些讨论并得到一些反馈意见。

下面我要用几段文字让你相信，这本书是写给你的。根本没必要担心它是几乎会耗尽你所有的业余时间的一门最抽象的数学。

我的乐观来自一些观察。首先，范畴论是相当有用的编程思想宝藏。Haskell 程序猿们已经涉足此境很久了，其中的一些思想正慢慢的渗入其他语言，只是这一过程是非常缓慢而已，我们需要使之加速。

其次，有许多种数学，它们面向不同受众。你可能不喜欢代数学，但这并不意味这你无法喜欢范畴论。我会向你展示，范畴论非常适合程序猿的思维。因为范畴论处理的对象不是计算细节，而是结构。它处理的是使程序可复合的结构。

复合是范畴论的精髓，它也是范畴论自身定义的一部分。我会证明编程的本质是『复合』。我们一直都在组合一些东西，这种行为从很久以前一群伟大的工程师提出子程序的时代就开始了。很久以前，结构化编程原理掀起了编程的革命，它立足于代码级别的复合。伴随面向对象编程而来的则是对象的复合。函数式编程不仅仅设计函数的复合与代数数据结构，它还提供了对并发计算的支持，这是其他编程范式难以实现的。

第三，我有秘密武器，一把庖丁之刀，我要用它将数学大卸八块使之成为程序猿的美味佳肴。如果你是数学家，你不得不大胆假设，小心求证，严格的构造你的定理，然后产生令外人难以卒读的论文与专著。我是训练有素的物理学家，在物理学中，我们使用着并不正规的推理来取得令人激动的发现。数学家们嘲笑伟大的物理学家 P. A. M. Dirac 为求解一些微分方程而提出的狄拉克 δ 函数，但是当他们发现了一个叫做广义函数论的新的数学分支时，他们就不笑了，因为广义函数论只是对 Dirac 观点的一种形式化描述。

当然，采用不严肃的论证方式很容易产生谬论。因此在这本书中凡是遇到不正式的论证时我会尽力确定其背后存在着相应的实际数学理论。我床头有一本被我翻的破破烂烂的 Saunders Mac Lane 写的《Category Theory for the Working Mathematician》。

由于这本书是写给程序猿的范畴论，因此我将会用计算机程序代码展现范畴论的主要概念。你可能会担心函数式语言会比传统的命令式语言更接近数学，并认为前者为此已经提供了更多的抽象能力，所以想当然的认为只有学习了 Haskell 方能将范畴论的能量作用于现实，或者认为范畴论在函数式编程范式之外没有什么用处，这些看法并不正确。我会提供大量的 C++ 的例子，只不过你得容忍一些丑陋的语法，需要在繁琐的代码中探寻清晰的模式，并且在更高层抽象的场合不得不做一些复制与粘贴的工作，不过这也正是大部分 C++ 程序员经常干的事。

不过，你也无法脱离 Haskell 的羁绊。虽然没有必要成为一名 Haskell 程序猿，但你需要将 Haskell 作为一种草图性的语言，用于描述那些 C++ 示例的实现思想。这也正是我当初开始学习 Haskell 的所用的方法。Haskell 简洁扼要的语法与强大的类型系统，对于理解与实现 C++ 模板、数据结构与算法非常有帮助。当然，我不可能要求读者事先以已经了解 Haskell，我会逐步介绍 Haskell 的知识，并且会对我所用到的那部分 Haskell 代码给出详细的解释。

如果你是一名有经验的程序员，可能会自问：即使不懂范畴论与函数式方法，我也照样写代码，似乎没什么必要学习它们。的确如此，不过你无法阻止正在侵入命令式语言的那股沉稳的函数式潮流。即使是 Java，面向对象编程的坚固堡垒，也拱手请来了 Lambda。C++ 也正在大踏步前进，现在每隔三五年就发布一个新标准，它正在尝试赶上这个正在变化的世界。这一切都在为一场变革而准备，这种变革，用我们物理学家的术语可称为相变。如果你持续的烧水，它最终会沸腾。我们现在正处于青蛙的位置，必须决定是在升温的水中继续游动，还是开始作出其他抉择。

image:ctfp1.jpeg[]

驱动编程范式产生巨大变革的力量之一是多核革命。主流的编程范式——面向对象编程已经难以胜任并发与并行计算领域，它只会造成危险且充满 bug 的设计。数据隐藏，是面向对象的基本前提，一旦对象被共享且被修改，就会造成数据竞争。将数据与互斥锁组合起来看似是个不错的解决方案，但不幸的是，互斥锁不能组合，并且一旦在数据竞争中出现死锁，程序非常难以调试。

对于非并发计算，软件系统日益递增的复杂度也正在炙烤着命令式编程范式。简而言之，副作用正在失去控制。有副作用的函数很便捷又易于编写。原则上，有副作用的函数所产生的影响可在函数名以及注释中予以标明。一个叫做 SetPassword 或 WriteFile 的函数显然在修改某种状态并产生副作用，对此我们已经非常习惯且不以为然。只有当我们开始将这些有副作用的函数层层组装到一起，事情才开始变得棘手。副作用本身并不坏，但是将它们塞到一个大尺度视图中，我们很难再看清它们，它们便脱离了我们的掌控。完全与副作用打交道的命令式编程范式才是元凶。

硬件的变化与软件复杂度的增长都在迫使我们重新思考编程的根本思想。正如欧洲最宏伟的哥特式大教堂的建造者那样，我们正在面对着原料与结构的限制而磨砺着我们的技艺。法国的博韦有一座未完工的哥特式教堂，它就是人类与限制作斗争的见证。这座教堂的设计企图在高度与采光方面击败所有的教堂，但是建造中却出现了一系列的崩塌。当时不得不用钢梁木柱临时做成支撑架构来阻止崩塌，但于事无补，因为很多东西在设计上就是错的。从现代的视角来看，博韦教堂是个奇迹，其相当多的一部分哥特式结构已经成功的建造了出来，这在那个没有现代材料科学、计算机建模、有限元分析甚至没有普通的数学与物理的时代显得有些不可思议。我期望我们的后代也会敬佩我们在构建复杂的操作系统、网络服务器以及互联网架构中展现出来的技术。毫不客气的说，他们理应如此，因为我们是在脆弱的理论基础上完成的这一切。但是，如果我们想继续前进，那么就必须修正现有的理论基础。

image:ctfp2.jpeg[]

== 范畴：复合的本质

> 上一篇文章，即《写向程序猿的范畴论》的序言，发布之后得到的正面反馈让我有些不知所措。同时，它也激励了我，因为我感受到了大家付诸于我的殷切期望。不过，我担心的是无论我如何努力，依然众口难调。有些读者希望这本书偏于现实，有些人则希望它能抽象一些。有些憎恨 C++ 的人希望所有的示例都是 Haskell 的，而那些憎恨 Haskell 的人又希望示例是 Java 的。我还知道内容的进展对于有些人可能太慢了，而对于有些人可能又太快了。这本书可能不会很完美，它会充满着妥协。不过，我只期望能够与大家分享一下我顿悟时的惊喜。我们现在从最基本的东西开始。

范畴是一个相当相当相当简单的概念。一些对象以及对象之间存在的一些箭头就构成了一个范畴。所以，范畴很容易用图形来表示。对象可以画成圆或点，箭头就画成箭头。为了好玩，有时我会把对象画成小猪，将箭头画成焰火。范畴的本质是复合，如果你愿意，也可以说复合的本质是范畴。箭头可以复合，因此如果你有一个从 A 指向 B 的箭头，又有一个从 B 指向 C 的箭头，那么就必定有一个复合箭头——从 A 指向 C 的箭头。

image:ctfp3.jpeg[]

> 在范畴论中，如果有一个箭头从 A 指向 B，又有一个箭头从 B 指向 C，那么就必定存在一个从 A 指向 C 的箭头，它是前两个箭头的复合。这幅图并非一个完整的范畴，因为它没有自态射（详见后文）。

=== 当箭头作为函数的时候

现在你已经凌乱了么？不要绝望。现在来点实在的，将箭头想象为函数，虽然它的学名叫态射。你有一个函数 f，它接受一个 A 类型的值，返回一个 B 类型的值。你还有一个函数 g，它接受一个 B 类型的值，返回一个 C 类型的值。你可以将 f 的返回值传递给 g，这样就完成了这两个函数的复合，你得到的是一个新的函数，它接受一个 A 类型的值，返回一个 C 类型的值。

在数学中，这样的复合可以用一个小圆点连接两个函数来表示，即 g∘f. 注意，复合是从右向左发生的。有些人可能还是有点不理解。你可能熟悉 Unix 中的管道，例如

[source,bash]
----
$ lsof | grep Chrome
----

也可能熟悉 F# 语言中的 >>，它们都是从左向右传递信息的。但是在数学与 Haskell 中，函数的复合是从右向左传递信息。如果你将 g∘f 读作 g after f 可能会有助于理解。

现在我们来写一些 C 代码。我们有一个函数 f，它接受 A 类型的参数值，返回一个 B 类型的值：

[source,c]
----
B f(A a);
----

还有一个

[source,c]
----
C g(B b);
----

那么这两个函数的复合，就是：

[source,c]
----
C g_after_f(A a)
{
    return g(f(a));
}
----

这次，你可以看到 C 中的从右向左的的复合：g(f(a))。

我希望 C++ 标准库中存在一个模板，它能够接受两个函数然后返回它们的复合，但是可惜并没有这样的模板。所以我们只能试试 Haskell 了。下面是一个从 A 到 B 的函数的声明：

[source,haskell]
----
f :: A -> B
----

类似的还有

[source,haskell]
----
g :: B -> C
----

它们复合为：

[source,haskell]
----
g . f
----

一旦你见识到 Haskell 是这么的简单，就会觉得 C++ 在函数概念的直接表达方面显得有些无能了。Haskell 也支持使用 Unicode 字符来写函数的复合：

[source,haskell]
----
g ∘ f
----

也可以使用 Unicode 字符来写冒号与箭头：

[source,haskell]
----
f ∷ A → B
----

这就是我们的 Haskell 第一课：两个冒号的意思是『类型为……』。一个函数的类型是由两个类型中间插入一个箭头而构成的。要对两个函数进行复合，只需在二者之间插入一个 .（或者 Unicode 小圆圈）。

=== 复合的性质

在任何范畴中，复合必须满足两个非常重要的性质：

[start=1]
. 复合是可结合的（结合律）。如果你有三个态射，f，g 与 h，它们能够被复合（也就是它们的对象能够首尾相连），那么你就没必要在复合表达式中使用括号。在数学中，可表示为：

[source,text]
----
h∘(g∘f) = (h∘g)∘f = h∘g∘f
----

在 Haskell 伪代码（之所以说『伪』，是因为 Haskell 没有为函数的相等进行定义）中，可表示为：

[source,haskell]
----
f :: A -> B
g :: B -> C
h :: C -> D
h . (g . f) == (h . g) . f == h . g . f
----

对于函数的处理，结合律相当清晰，但是在其他范畴中可能就不这么清晰了。

[start=2]
. 任一对象 A，都有一个箭头，它是复合的最小单位。这个箭头从对象出发又指向对象自身。作为复合的最小单位，意思是当它分别与任何从 A 开始或终止于 A 的箭头复合时，得到的依然是与后者相同的箭头。对象 A 的单位箭头称为 idA，意思是 identity on A，即 A 与自身恒等。在数学表示中，如果 f 从 A 到 B，那么就有

f∘idA = f

以及

idB∘f = f

在处理函数时，恒等箭头就是作为一个恒等函数实现的，这个函数的唯一工作就是直接返回它所接受的参数值。对于所有的类型，都可以这么实现恒等，这意味着这个函数是多态的。在 C++ 中，我们可以以模板的形式来定义它：

[source,cpp]
----
template<class T> T id(T x) { return x; }
----

当然，在 C++ 中，实际情况并非如此简单，因为你需要考虑要给这个函数传递什么以及如何传递（通过值，还是通过引用，还是通过常量引用，还是通过 move 语义等等）。

在 Haskell 中，恒等函数是标准库（即 Prelude）中的一部分，其定义如下：

[source,haskell]
----
id :: a -> a
id x = x
----

正如你所见，在 Haskell 中多态函数是小菜一碟，在其声明中，你只需要用一个具体的类型来替换掉类型变量即可。这就涉及到一个小把戏：具体的类型，名字总是以一个大写字母开头，而类型变量的名字总是以一个小写字母开头。在此，a 表示所有类型。

Haskell 函数的定义由尾随着形参的函数名构成，这里只有一个形参 x。函数体在 = 号之后。这种简洁扼要的风格经常令新手愕然，但你很快就会发现它的魅力所在。函数的定义与调用是函数式编程的面包与黄油，因此它们的语法被简化到了骨瘦如柴的境地。参数值列表不仅不需要括号，参数值之间也没有逗号（下文在定义多个参数的函数时，就可以看到这些）。

函数体总是由一个表达式构成，亦即函数中没有语句。一个函数的返回结果就是这个表达式本身——在此就是 x。

这就是我们的 Haskell 第二课。

恒等条件可写为（还是伪 Haskell 代码）：

[source,haskell]
----
f . id == f
id . f == f
----

可能你会问：为何需要这个什么也不做的恒等函数？其实你应该这样问，为什么需要数字 0？

0 是一个表示无的符号。古罗马人有一个没有 0 的数字系统，他们能够修建出色的道路与水渠，有些直到今天还能用。

类似 0 这样的东西，在处理符号变量的时候特别有用。这就是罗马人不擅长代数学的原因，而阿拉伯人与波斯人因为熟悉 0 的概念，因此他们能够很好的掌握代数学。当恒等函数作为高阶函数的参数值或返回值时，它的价值就会得以体现。高阶函数能够像处理符号那样处理函数，它们是函数的代数。

总结一下：一个范畴由对象与箭头（态射）构成。箭头可以复合，这种复合满足结合律。每个对象都有一个恒等箭头，它是箭头复合的基本单位。

=== 复合是编程的本质

函数式程序员在洞察问题方面会遵循一个奇特的路线。他们首先会问一些似有禅机的问题。例如，在设计一个交互式程序时，他们会问：什么是交互？在实现基于元胞自动机的生命游戏时，他们可能又去沉思生命的意义。秉持这种精神，我将要问：什么是编程？在最基本的层面，编程就是告诉计算机去做什么，例如『从内存地址 x 处获取内容，然后将它与寄存器 EAX 中的内容相加』。但是即使我们使用汇编语言去编程，我们向计算机提供的指令也是某种有意义的表达式。假设我们正在解一个难题（如果它不难，就没必要用计算机了），那么我们是如何求解问题的？我们把大问题分解为更小的问题。如果更小的问题还是还是很大，我们再继续进行分解，以此类推。最后，我们写出求解这些小问题的代码，然后就出现了编程的本质：我么将这些代码片段复合起来，从而产生大问题的解。如果我们不能将代码片段整合起来并还原回去，那么问题的分解就毫无意义。

层次化分解与重新复合的过程，并非是受计算机的限制而产生，它反映的是人类思维的局限性。我们的大脑一次只能处理很少的概念。生物学中被广为引用的一篇论文指出我们我们的大脑中只能保存 7± 2 个信息块。我们对人类短期记忆的认识可能会有变化，但是可以肯定的是它是有限的。底线就是我们不能处理一大堆乱糟糟的对象或像兰州拉面似的代码。我们需要结构化并非是因为结构化的程序看上去有多么美好，而是我们的大脑无法有效的处理非结构化的东西。我们经常说一些代码片段是优雅的或美观的，实际上那只意味着它们更容易被人类有限的思维所处理。优雅的代码创造出尺度合理的代码块，它正好与我们的『心智消化系统』能够吸收的数量相符。

那么，对于程序的复合而言，正确的代码块是怎样的？它们的表面积必须要比它们的体积增长的更为缓慢。我喜欢这个比喻，因为几何对象的表面积是以尺寸的平方的速度增长的，而体积是以尺寸的立方的速度增长的，因此表面积的增长速度小于体积。代码块的表面积是是我们复合代码块时所需要的信息。代码块的体积是我们为了实现它们所需要的信息。一旦代码块的实现过程结束，我们就可以忘掉它的实现细节，只关心它与其他代码块的相互影响。在面向对象编程中，类或接口的声明就是表面。在函数式编程中，函数的声明就是表面。我把事情简化了一些，但是要点就是这些。

在积极阻碍我们探视对象的内部方面，范畴论具有非凡的意义。范畴论中的一个对象，像一个星云。对于它，你所知的只是它与其他对象之间的关系，亦即它与其他对象相连接的箭头。这就是 Internet 搜索引擎对网站进行排名时所用的策略，它只分析输入与输出的链接（除非它受欺骗）。在面向对象编程中，一个理想的对象应该是只暴露它的抽象接口（纯表面，无体积），其方法则扮演箭头的角色。如果为了理解一个对象如何与其他对象进行复合，当你发现不得不深入挖掘对象的实现之时，此时你所用的编程范式的原本优势就荡然无存了。

=== 挑战

. 用你最喜欢的语言（如果你最喜欢的是 Haskell，那么用你第二喜欢的语言）尽力实现一个恒等函数。
. 用你最喜欢的语言实现函数的复合，它接受两个函数作为参数值，返回一个它们的复合函数。
. 写一个程序，测试你写的可以复合函数的函数是否能支持恒等函数。
. 互联网是范畴吗？链接是态射吗？
. 脸书是一个以人为对象，以朋友关系为态射的范畴吗？
. 一个有向图，在什么情况下是一个范畴？

== 类型与函数

类型与函数构成的范畴在编程中担任着重要的角色。我们讨论一下类型是什么，为什么需要它。

=== 谁需要类型？

关于静态 vs 动态，强类型 vs 弱类型，似乎存在着一些争论。下面我用一个思想实验让这些选择变得更直观一些。想象一下，无数只猴子在快乐的随机敲打着键盘，产生程序，编译，然后运行。

image:ctfp4.jpeg[]

对于机器语言而言，猴子们产生的任何字节的组合都会被计算机接受并运行。我们应该庆幸，高级的语言，因为有负责检查词法与语法错误的编译器的存在，导致大部分猴子因为努力敲打键盘却未得到香蕉而拂手而去，而剩下的那些猴子胡乱敲打所生成的程序如果能通过编译，它们更有可能变成有用的程序。类型检查也提供了一个门槛，可以拦截无意义的程序。此外，在强类型的静态语言中，可以在编译期间发现类型错误，从而在大部分不正确的程序运行之前就干掉了它们，而动态类型语言只能在运行时进行类型检查……

那么，问题就来了，我们想让猴子们高兴么，或者我们想产生正确的程序么？

这个关于猴子的思想实验，通常的目标是让打字的猴子们创作一部莎士比亚全集的。在这个过程中，如果有拼写检查与语法检查，就可以提高成功的可能性。类型检查的比喻具有更重要的意义，因为它可以确定，一旦罗密欧被识别为人类，那么他就无法生根发芽长出树叶或者在他强大的重力场中捕获光子。

=== 类型关乎复合

范畴论与箭头的复合有关。但是并非任意两个箭头都可以复合。一个箭头的目标对象必须与下一个箭头的源对象相同，这样的两个箭头方能复合。在编程中，我们将一个函数的返回结果传递给另一个函数。如果目标函数不能正确的解析源函数传递来的数据，程序就不会工作。首尾必须相连，方能实现复合。编程语言的类型系统越强，箭头的配合就越容易描述与检验。

我见过唯一的一场反对强类型检查的严肃争论，认为它可能会扼杀一些程序，而这些程序在语义上却是正确的。现实中，这种情况出现的几率非常之小，并且每一种语言都提供了某种后门，可以让代码在真正需要的时候通过类型检查。即使是 Haskell 这样的语言，也有这种后门。但是这种设施应该谨慎使用。卡夫卡的小说《变形记》中的葛里高尔，当他变异为巨大的甲虫时，打破了类型系统，其结局大家也都看到了。

我见过的另一场争论，是认为类型的处理给程序员带来巨大的负担。在不得不为 C++ 的迭代器写一些类型声明的时候，我深有同感。但是有一种技术叫类型推导，它可以让编译器在需要的时候能够根据上下文推导出大部分类型。在 C++ 中，现在可以用 auto 变量，其类型具体是什么就交付给编译器来确定。

在 Haskell 中，大部分场合，类型声明并非必须。不过 Haskell 程序猿还是趋向于使用类型声明，因为他们可以让代码具有语义，也能使得编译错误更容易理解。Haskell 的实际编程中，往往是在项目的一开始就进行类型设计，然后用类型的声明驱动程序的实现，最终类型声明会变成代码注释，但是这种注释对于编译器是有意义的。

强静态类型通常用于代替代码测试。你可能有时听到 Haskell 程序猿说，『能通过编译，它就是正确的』。当然，没人能担保类型是正确的程序就能够产生正确的输出。这种骑士般的态度所引发的结果就是，有些人研究发现强类型的 Haskell 在代码质量方面的进展并没有像大家预期的那样好。不过，在商业软件开发中，似乎修复 bug 的压力只停留在一个特定的质量级别，这个级别介乎软件开发成本与用户的容忍限度之间，它与编程语言或编程范式的关系不太大。更好的评价指标应该是检查有多少项目延期交付了，或者有多少项目在大幅消减了函数式编程范式之后它及时交付了。

至于单元测试能够替代强类型检查方面也有一些争论，考虑一下强类型语言中的常见的重构行为：改变一个函数的参数类型。在强类型语言中，修改函数的声明就可以修复所有的构建错误。在弱类型语言中，函数的变化却无法传播到它被调用的地方。单元测试虽然能够捕捉到一些错误，但是测试总是概率意义上的，而不是一个确定的过程。测试是一种贫弱的证明。

=== 类型是什么

对于类型，最简单的直觉就是它是值的集合。Bool 类型（记住，Haskell 中具体类型是大写字母开头）是一个含有 2 个元素 True 与 False 的集合。Char 类型是所有 Unicode 字符的集合。

集合可能是有限或无限的。String 类型，它与 Char 列表同义，它就是个无限集的例子。

当我们将 x 声明为 Integer 时：

[source,haskell]
----
x :: Integer
----

我们想说的是，x 是一个整型数集中的一个元素。在Haskell 中，Integer 是无限集，它能够用于任意精度的算术。还有个有限集，叫 Int，它与机器类型有关，就像 C++ 的 int。

有一些微妙的东西，可以使得类型与集合的定义更为精巧。比如多态函数存在一些问题，因为事实上你不可能拥有一个所有集合的集合。但是我承诺过，我不会过于数学化。集合的范畴是个伟大的概念，它的名字就叫做 Set，我们以后只在它上面工作。在 Set 中，对象是集合，态射（箭头）是函数。

Set 是个非常特殊的范畴，因为我们实际上只能从它的内部拮取一些对象，并通过操作这些对象来认识它。例如，我们知道空集不包含任何元素。我们知道存在只含有一个元素的集合。我们知道函数可以将一个集合中的元素映射到另一个集合。它们也能将两个元素映射为一个，但是却不能将一个元素映射为 2 个。我们还知道恒等函数可以将一个元素映射为本身，等等。现在我们不妨将逐步忘记这一切，去使用纯粹的范畴论语言——对象与箭头——去表达这些概念。

在理想世界中，我们可以说 Haskell 的数据类型是集合，Haskell 的函数是集合之间的数学函数。只不过有个小问题：数学函数不可被执行——它只知道答案。Haskell 函数必须要计算出答案。如果答案可以在有限步骤中被计算出来，这不是什么问题，然而步骤的数量可能会很大。有些计算是递归的，它可能永远不会终止。在 Haskell 中我们不能阻止停不下来的函数，因为这就是著名的停机问题。这就是为什么计算机科学家搞出来一个聪明的点子，也可以说是一个巨大的 hack，这取决于你的视角；他们为每一种类型增加了一个特殊值，叫做底（Bottom），用符号表示为 _|_，也可以用 Unicode 字符 ⊥。这个『值』与无休止计算有关。因此，若一个函数声明为：

[source,haskell]
----
f :: Bool -> Bool
----

它可以返回 True，False 或 _|_；后者表示它不会终止。

有趣的是，一旦你接受了将底作为类型系统的一部分，就可以将每一种运行时错误作为底来对待，甚至可以容许函数显式地返回底——通常用于未定义的表达式，例如：

[source,haskell]
----
f :: Bool -> Bool
f x = undefined
----

这种类型的定义之所以能通过类型检查，是因为 undefined 的求值结果是底，而底可以是任何类型的值，所以它也是 Bool 类型的值。甚至，你可以这样不要那个 x，即：

[source,haskell]
----
f :: Bool -> Bool
f = undefined
----

因为底也是类型 Bool->Bool 这种类型的值。

可以返回底的函数被称为偏函数，与全函数相对，后者总是对于每种可能的参数值返回有效的结果。

由于底的存在，你将会看到 Haskell 类型与函数的范畴会被称为 Hask，而不是 Set。从理论上来看，这是导致出现无休止的复杂性的源头，因此在这一点我要动用我的庖丁之刀将复杂砍掉。从实用的角度来看，不理睬无休止的函数与底是没有问题的，将 Hask 视为一个友善的 Set 即可（详见本文末尾的参考文献）。

=== 为何我们需要一个数学模型？

身为程序猿，你所熟悉的是编程语言的语法。编程语言的各个方面在这门语言诞生之初是通过形式化标记描述的。但是语言的语义却很难描述，有时用一本挺厚的书来描述，可能也无法完整的说清楚。因此，语言专家们之间的讨论永无休止，那些讲解语言的工业化标准的书籍已经汗牛充栋了。

有些形式化工具可描述语义，但是由于它们太复杂了，以至于只是在一些简化的学院级语言中使用了它们。此类工具中，有一个工具叫做操作语义（operational semantic），它描述的是程序的执行机制。它定义了形式化理想化的解释器。工业级语言的语义，类似 C++，用的是非正式的操作语义，称之为『抽象机器』。

使用操作语义存在的问题是要难以证明程序的正确性。要展现一个程序的性质，你只能在一个理想化的解释器中去『运行』它。

没关系，反正程序猿不需要去形式化的证明程序的正确性。我们总是『思考』我们在写正确的程序。没有人在键盘前说，『呃，我随手写几行代码，看看会发生什么』。我们思考的是，我们所写的代码会拥有正确的行为，产生我们想要的结果。一旦程序做不到这些，我们通常会相当惊讶。这意味着，我们在写代码的时候没有对程序进行推导，只是在写完后才在自己的大脑中的解释器中运行它的时候才进行正确性推导。这样做的问题是很难跟踪所有的变量。计算机善于运行程序，人类却不能！如果我们能，就没必要发明计算机了。

但是，还有一种选择，它叫指称语义（Denotational semantic），是基于数学的。在指称语义中，每个编程结构都会被给出数学解释。使用它，如果你想证明程序的正确性，只需要证明一个数学定理。你可能觉得数学定理的证明是很难的，但是我们人类建立数学方法已经上千年了，因此有大量的知识资源可以利用。还有，与数学家所证明的那些定理相比，我们在编程中遇到的问题通常是相当简单的，生僻的问题很少。

Haskell 是符合指称语义的语言，考虑用 Haskell 定义一个阶乘函数：

[source,haskell]
----
fact n = product [1..n]
----

表达式 [1..n] 是一个从 1 到 n 的整型数列表。product 函数可以将列表中的所有元素相乘。这跟数学课本里的阶乘几乎别无二致。与 C 代码相比较：

[source,c]
----
int fact(int n) {
    int i;
    int result = 1;
    for (i = 2; i <= n; ++i)
        result *= i;
    return result;
}
----

还要我多说什么？

好吧，我首先得承认我有点恶意中伤！阶乘函数本身就有着明确的数学定义。敏锐的读者可能会问：从键盘读取字符或者通过网络发送数据包，它们有数学模型么？在非常漫长的时间里，此类问题一直都是很尴尬的问题，答案只能是弯弯绕的那种。似乎指称语义不能极好的应用于一些重要的任务，而编程本来就是围绕这些任务而生。操作语义很容易胜任这些任务。直到范畴论的出现才找到摆脱这种尴尬境地的突破口。Eugenio Moggi 发现可通过单子完成此类任务，这一发现不仅扭转了乾坤，使得指称语义大放异彩，并使得纯函数式程序变得更为有用，也使得传统的编程范式绽放出新的光芒。单子，我们以后在发展更多的范畴论工具时再予以探讨。

对于编程而言，拥有一个数学模型的重要的优点就是能够对软件的正确性给予形式化证明。这对于写消费级软件来说可能不是太重要，但是有些领域，失败的代价相当高，甚至会出人命。不过，事实上当你为健康系统写网络应用程序时，你可能会欣赏具有正确性证明的 Haskell 标准库中的函数与算法。

=== 纯函数与脏函数

在 C++ 或其他命令式语言中，我们称之为函数的东西，与数学上被称为函数的东西是不同的。数学上的函数是值到值的映射。

在编程语言中，我们能够实现数学上的函数：一个函数，给它一个输入值，它就计算出一个输出的值。一个平方函数就是输入值自身的乘积。每次被调用时，对于相同的输入，它总是能保证产生同样的输出。一个数的平方不会随着月相的变化而变化。

再者，计算一个数的平方也不会对你的狗粮配方有副作用。如果有一个『函数』就是对你的狗粮配方有副作用，那么它的模型就与数学里的函数存在很大差异。

在命令式语言中，给予相同输入总是能得到相同输出的函数，被称为纯函数。在一种纯函数式语言中，例如 Haskell，所有的函数都是纯的。正是因为这一点，Haskell 更易于赋予语言以指称语义，并使用范畴论进行建模。对于其他语言，也可以构造出一个纯的子集，或者对副作用谨慎对待。以后我们将会看到单子是如何只借助纯函数来对各种副作用进行建模的。总之，我们用数学函数来约束自己，但是却没有任何损失。

=== 类型的示例

一旦意识到类型是集合，你就可以思考一些相当生僻的类型。例如，空集这种类型是什么？在 Haskell 中，空集是 Void，虽然 C++ 中也有个 void，但它俩不是一回事。Haskell 中的 Void 是一个不存储任何值的类型。你可以定义一个接受 Void 的函数，但是你永远无法调用它。因为，要调用这个函数，必须向它提供一个 Void 类型的值，但这种类型的值并不存在。至于这个函数的返回值，不需要作任何限制。它可以返回任何类型，反正它根本没有机会运行。换句话说，它是一个具有多态返回类型的函数。Haskell 程序员将其命名为：

[source,haskell]
----
absurd :: Void -> a
----

记住，a 是一个类型变量，它可接受任何类型。函数的名字不太相符。这种类型与函数，在逻辑学上有更深入的解释，它们被称为 Curry-Howard 自同态。Void 类型表示谎言，absurd 函数的类型相当于『由谎言可以推出任何结论』，也就是逻辑学中所谓的『爆炸原理』。

下一个类型相当于单例集合。它是只有一个值的类型。你可能意识不到，它实际上就是 C++ 中的 void。考虑那些输入是 void 以及返回是 void 的函数。一个输入是 void 的函数总是能够被调用。如果它是纯函数，它就总是能返回相同的结果。例如：

[source,c]
----
int f44() { return 44; }
----

你可能认为这种函数没有输入。但是刚才我们已经见识了，一个函数如果不接受任何值，它永远也无法被调用。那么，这个 f44 接受了什么？从概念上说，它接受了一个空值，而且不会再有第 2 个空值，因此我们就没必要再显式的提及它。然而 haskell 为空值提供了一个符号，即空的序对 ()。因此就有了搞笑的巧合（真的是巧合吗？），输入为 void 的函数，C++ 与 Haskell 的版本看上去是相同的。不过，在 Haskell 中，() 也可以用在类型、构造子上。f44 的 Haskell 版本如下;

[source,haskell]
----
f44 :: () -> Integer
f44 () = 44
----

第一行代码描述了 f44 接受 () 类型（这个类型读作『unit』），将其映射为 Integer 类型。第二行代码是通过 unit 的构造子 () 的模式匹配来定义 f44。只要你提供 unit 的值 () 就可以调用这个函数：

[source,haskell]
----
f44 ()
----

注意，每个 unit 函数都等同于从目标类型中选取一个值的函数（在此，就是选择 Integer 类型的值 44）。实际上，你可以将 f44 作为数字 44 的另一种表示方法，因此这也是如何通过与函数（箭头）的交互来代替集合中一个显式的元素的示例，也就是说数据与计算过程的本质上是没有区别的。从 unit 到类型 A 的函数相当于集合 A 中的元素。

让函数返回 void 类型会怎样，或者说，在 Haskell 中，让函数返回 unit 会怎样？在 C++ 中，这样的函数通常担当具有副作用的函数，但是我们知道这种函数并非数学意义上的函数。一个返回 unit 的纯函数，它什么也不做，或者说，它唯一做的就是丢弃它所接受的输入。

在数学上，一个从集合 A 到单例集合的函数会将 A 中的每个元素映射为单例集合中的元素。对于每个 A 都存在这样的函数。例如对于 Integer，有：

[source,haskell]
----
fInt :: Integer -> ()
fInt x = ()
----

你向这个函数提供任何整数，它都会给你返回一个 unit。本着简明扼要的精神，Haskell 允许你使用通配符模式，可以用下划线来替代要忽略的输入。这样你就不需要再为它重新弄个名字。上述函数可改写为：

[source,haskell]
----
fInt :: Integer -> ()
fInt _ = ()
----

注意，这个函数的实现不仅不依赖传给它的参数，它也不依赖参数的类型。

对于任意类型都具有相同形式的函数，称为参数型多态。用类型变量来代替一个具体的类型，就可以实现一个函数族。我们要怎么称呼一个从任意类型到 unit 的函数？当然，要称它为 unit：

[source,haskell]
----
unit :: a -> ()
unit _ = ()
----

在 C++ 中，你可以这样来写：

[source,cpp]
----
template<class T>
void unit(T) {}
----

