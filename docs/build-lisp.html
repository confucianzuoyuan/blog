<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.13">
<title>从零使用C语言构建一个Lisp解释器</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/* Asciidoctor default stylesheet | MIT License | https://asciidoctor.org */
/* Uncomment @import statement to use as custom stylesheet */
/*@import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700";*/
article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section{display:block}
audio,video{display:inline-block}
audio:not([controls]){display:none;height:0}
html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}
a{background:none}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
abbr[title]{border-bottom:1px dotted}
b,strong{font-weight:bold}
dfn{font-style:italic}
hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type="button"],input[type="reset"],input[type="submit"]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,*::before,*::after{-moz-box-sizing:border-box;-webkit-box-sizing:border-box;box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;font-weight:400;font-style:normal;line-height:1;position:relative;cursor:auto;tab-size:4;word-wrap:anywhere;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:0}
p{font-family:inherit;font-weight:400;font-size:1em;line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #dddddf;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em;height:0}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{font-size:1em;line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0;font-size:1em}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
abbr,acronym{text-transform:uppercase;font-size:90%;color:rgba(0,0,0,.8);border-bottom:1px dotted #ddd;cursor:help}
abbr{text-transform:none}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:solid 1px #dedede;word-wrap:normal}
table thead,table tfoot{background:#f7f8f7}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt{background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.center{margin-left:auto;margin-right:auto}
.stretch{width:100%}
.clearfix::before,.clearfix::after,.float-group::before,.float-group::after{content:" ";display:table}
.clearfix::after,.float-group::after{clear:both}
:not(pre).nobreak{word-wrap:normal}
:not(pre).nowrap{white-space:nowrap}
:not(pre).pre-wrap{white-space:pre-wrap}
:not(pre):not([class^=L])>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background:#f7f7f8;-webkit-border-radius:4px;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed}
pre{color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;line-height:1.45;text-rendering:optimizeSpeed}
pre code,pre pre{color:inherit;font-size:inherit;line-height:inherit}
pre>code{display:block}
pre.nowrap,pre.nowrap pre{white-space:pre;word-wrap:normal}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background:#f7f7f7;border:1px solid #ccc;-webkit-border-radius:3px;border-radius:3px;-webkit-box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em white inset;box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em #fff inset;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button::before,b.button::after{position:relative;top:-1px;font-weight:400}
b.button::before{content:"[";padding:0 3px 0 2px}
b.button::after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin-left:auto;margin-right:auto;margin-top:0;margin-bottom:0;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header::before,#header::after,#content::before,#content::after,#footnotes::before,#footnotes::after,#footer::before,#footer::after{content:" ";display:table}
#header::after,#content::after,#footnotes::after,#footer::after{clear:both}
#content{margin-top:1.25em}
#content::before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #dddddf}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #dddddf;padding-bottom:8px}
#header .details{border-bottom:1px solid #dddddf;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:-ms-flexbox;display:-webkit-flex;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span::before{content:"\00a0\2013\00a0"}
#header .details br+span.author::before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark::before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber::after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #dddddf;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #e7e7e9;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #e7e7e9;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #e7e7e9;left:auto;right:0}}
@media screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:none;background:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:rgba(255,255,255,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #e7e7e9}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor::before,h2>a.anchor::before,h3>a.anchor::before,#toctitle>a.anchor::before,.sidebarblock>.content>.title>a.anchor::before,h4>a.anchor::before,h5>a.anchor::before,h6>a.anchor::before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
details,.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
details>summary:first-of-type{cursor:pointer;display:list-item;outline:none;margin-bottom:.75em}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock.fit-content>caption.title{white-space:nowrap;width:0}
.paragraph.lead>p,#preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:1.21875em;line-height:1.6;color:rgba(0,0,0,.85)}
table.tableblock #preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:inherit}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #dddddf;color:rgba(0,0,0,.6);word-wrap:anywhere}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border-style:solid;border-width:1px;border-color:#e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;-webkit-border-radius:4px;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border-style:solid;border-width:1px;border-color:#dbdbd6;margin-bottom:1.25em;padding:1.25em;background:#f3f3f2;-webkit-border-radius:4px;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock>.content>pre{-webkit-border-radius:4px;border-radius:4px;overflow-x:auto;padding:1em;font-size:.8125em}
@media screen and (min-width:768px){.literalblock pre,.listingblock>.content>pre{font-size:.90625em}}
@media screen and (min-width:1280px){.literalblock pre,.listingblock>.content>pre{font-size:1em}}
.literalblock pre,.listingblock>.content>pre:not(.highlight),.listingblock>.content>pre[class="highlight"],.listingblock>.content>pre[class^="highlight "]{background:#f7f7f8}
.literalblock.output pre{color:#f7f7f8;background:rgba(0,0,0,.9)}
.listingblock>.content{position:relative}
.listingblock code[data-lang]::before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:inherit;opacity:.5}
.listingblock:hover code[data-lang]::before{display:block}
.listingblock.terminal pre .command::before{content:attr(data-prompt);padding-right:.5em;color:inherit;opacity:.5}
.listingblock.terminal pre .command:not([data-prompt])::before{content:"$"}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;-webkit-border-radius:4px;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.prettyprint{background:#f7f7f8}
pre.prettyprint .linenums{line-height:1.45;margin-left:2em}
pre.prettyprint li{background:none;list-style-type:inherit;padding-left:0}
pre.prettyprint li code[data-lang]::before{opacity:1}
pre.prettyprint li:not(:first-child) code[data-lang]::before{display:none}
table.linenotable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.linenotable td[class]{color:inherit;vertical-align:top;padding:0;line-height:inherit;white-space:normal}
table.linenotable td.code{padding-left:.75em}
table.linenotable td.linenos{border-right:1px solid currentColor;opacity:.35;padding-right:.5em}
pre.pygments .lineno{border-right:1px solid currentColor;opacity:.35;display:inline-block;margin-right:.75em}
pre.pygments .lineno::before{content:"";margin-right:-.125em}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock:not(.excerpt)>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote::before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.75em;margin-right:.5ex;text-align:right}
.verseblock{margin:0 1em 1.25em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract blockquote::before,.quoteblock.excerpt blockquote::before,.quoteblock .quoteblock blockquote::before{display:none}
.quoteblock.abstract blockquote,.quoteblock.abstract p,.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{line-height:1.6;word-spacing:0}
.quoteblock.abstract{margin:0 1em 1.25em;display:block}
.quoteblock.abstract>.title{margin:0 0 .375em;font-size:1.15em;text-align:center}
.quoteblock.excerpt>blockquote,.quoteblock .quoteblock{padding:0 0 .25em 1em;border-left:.25em solid #dddddf}
.quoteblock.excerpt,.quoteblock .quoteblock{margin-left:0}
.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{color:inherit;font-size:1.0625rem}
.quoteblock.excerpt .attribution,.quoteblock .quoteblock .attribution{color:inherit;font-size:.85rem;text-align:left;margin-right:0}
p.tableblock:last-child{margin-bottom:0}
td.tableblock>.content{margin-bottom:1.25em;word-wrap:anywhere}
td.tableblock>.content>:last-child{margin-bottom:-1.25em}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>*>tr>*{border-width:1px}
table.grid-cols>*>tr>*{border-width:0 1px}
table.grid-rows>*>tr>*{border-width:1px 0}
table.frame-all{border-width:1px}
table.frame-ends{border-width:1px 0}
table.frame-sides{border-width:0 1px}
table.frame-none>colgroup+*>:first-child>*,table.frame-sides>colgroup+*>:first-child>*{border-top-width:0}
table.frame-none>:last-child>:last-child>*,table.frame-sides>:last-child>:last-child>*{border-bottom-width:0}
table.frame-none>*>tr>:first-child,table.frame-ends>*>tr>:first-child{border-left-width:0}
table.frame-none>*>tr>:last-child,table.frame-ends>*>tr>:last-child{border-right-width:0}
table.stripes-all tr,table.stripes-odd tr:nth-of-type(odd),table.stripes-even tr:nth-of-type(even),table.stripes-hover tr:hover{background:#f8f8f7}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
ol>li p,ul>li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
ul.checklist{margin-left:.625em}
ul.checklist li>p:first-child>.fa-square-o:first-child,ul.checklist li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist li>p:first-child>input[type="checkbox"]:first-child{margin-right:.25em}
ul.inline{display:-ms-flexbox;display:-webkit-box;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
td.hdlist2{word-wrap:anywhere}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:solid 4px #fff;-webkit-box-shadow:0 0 0 1px #ddd;box-shadow:0 0 0 1px #ddd}
.imageblock.left{margin:.25em .625em 1.25em 0}
.imageblock.right{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em;border-width:1px 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
.gist .file-data>table{border:0;background:#fff;width:100%;margin-bottom:0}
.gist .file-data>table td.line-data{width:99%}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background:#00fafa}
.black{color:#000}
.black-background{background:#000}
.blue{color:#0000bf}
.blue-background{background:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background:#fa00fa}
.gray{color:#606060}
.gray-background{background:#7d7d7d}
.green{color:#006000}
.green-background{background:#007d00}
.lime{color:#00bf00}
.lime-background{background:#00fa00}
.maroon{color:#600000}
.maroon-background{background:#7d0000}
.navy{color:#000060}
.navy-background{background:#00007d}
.olive{color:#606000}
.olive-background{background:#7d7d00}
.purple{color:#600060}
.purple-background{background:#7d007d}
.red{color:#bf0000}
.red-background{background:#fa0000}
.silver{color:#909090}
.silver-background{background:#bcbcbc}
.teal{color:#006060}
.teal-background{background:#007d7d}
.white{color:#bfbfbf}
.white-background{background:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background:rgba(0,0,0,.8);-webkit-border-radius:50%;border-radius:50%;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]::after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,span.alt{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background:#fffef7;border-color:#e0e0dc;-webkit-box-shadow:0 1px 4px #e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@page{margin:1.25cm .75cm}
@media print{*{-webkit-box-shadow:none!important;box-shadow:none!important;text-shadow:none!important}
html{font-size:80%}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare)::after,a[href^="https:"]:not(.bare)::after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]::after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#header,#content,#footnotes,#footer{max-width:none}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #dddddf!important;padding-bottom:0!important}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span::before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]::before{display:block}
#footer{padding:0 .9375em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
@media print,amzn-kf8{#header>h1:first-child{margin-top:1.25rem}
.sect1{padding:0!important}
.sect1+.sect1{border:0}
#footer{background:none}
#footer-text{color:rgba(0,0,0,.6);font-size:.9em}}
@media amzn-kf8{#header,#content,#footnotes,#footer{padding:0}}
</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.3/styles/github.min.css">
</head>
<body class="article toc2 toc-left">
<div id="header">
<h1>从零使用C语言构建一个Lisp解释器</h1>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_第一章简介">1. 第一章：简介</a></li>
<li><a href="#_第二章数据">2. 第二章：数据</a>
<ul class="sectlevel2">
<li><a href="#_实现">2.1. 实现</a></li>
<li><a href="#_测试">2.2. 测试</a></li>
<li><a href="#_文本表示">2.3. 文本表示</a></li>
<li><a href="#_实现_2">2.4. 实现</a></li>
<li><a href="#_测试_2">2.5. 测试</a></li>
<li><a href="#_最后一件事情">2.6. 最后一件事情</a></li>
</ul>
</li>
<li><a href="#_第三章解析器">3. 第三章：解析器</a>
<ul class="sectlevel2">
<li><a href="#_错误处理">3.1. 错误处理</a></li>
<li><a href="#_词法分析lexer">3.2. 词法分析（Lexer）</a></li>
<li><a href="#_解析器">3.3. 解析器</a></li>
<li><a href="#_测试_3">3.4. 测试</a></li>
<li><a href="#_完整代码">3.5. 完整代码</a></li>
</ul>
</li>
<li><a href="#_第四章表达式环境和求值">4. 第四章：表达式、环境和求值</a>
<ul class="sectlevel2">
<li><a href="#_表达式">4.1. 表达式</a></li>
<li><a href="#_环境">4.2. 环境</a>
<ul class="sectlevel3">
<li><a href="#_实现_3">4.2.1. 实现</a></li>
</ul>
</li>
<li><a href="#_求值">4.3. 求值</a>
<ul class="sectlevel3">
<li><a href="#_实现_4">4.3.1. 实现</a></li>
<li><a href="#_测试_4">4.3.2. 测试</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_第五章内建函数">5. 第五章：内建函数</a>
<ul class="sectlevel2">
<li><a href="#_一种新的atom类型">5.1. 一种新的Atom类型</a></li>
<li><a href="#_扩展求值器">5.2. 扩展求值器</a></li>
<li><a href="#_初始环境">5.3. 初始环境</a></li>
<li><a href="#_测试_5">5.4. 测试</a></li>
</ul>
</li>
<li><a href="#_第六章算术表达式">6. 第六章：算术表达式</a>
<ul class="sectlevel2">
<li><a href="#_实现_5">6.1. 实现</a></li>
<li><a href="#_测试_6">6.2. 测试</a></li>
</ul>
</li>
<li><a href="#_第七章lambda表达式和闭包">7. 第七章：Lambda表达式和闭包</a>
<ul class="sectlevel2">
<li><a href="#_实现_6">7.1. 实现</a></li>
<li><a href="#_测试_7">7.2. 测试</a></li>
</ul>
</li>
<li><a href="#_第八章布尔值和短路求值">8. 第八章：布尔值和短路求值</a>
<ul class="sectlevel2">
<li><a href="#_布尔值">8.1. 布尔值</a></li>
<li><a href="#_短路求值">8.2. 短路求值</a>
<ul class="sectlevel3">
<li><a href="#_测试_8">8.2.1. 测试</a></li>
</ul>
</li>
<li><a href="#_谓词">8.3. 谓词</a>
<ul class="sectlevel3">
<li><a href="#_测试_9">8.3.1. 测试</a></li>
</ul>
</li>
<li><a href="#_完整代码_2">8.4. 完整代码</a></li>
</ul>
</li>
<li><a href="#_第九章语法糖">9. 第九章：语法糖</a>
<ul class="sectlevel2">
<li><a href="#_单引号">9.1. 单引号</a>
<ul class="sectlevel3">
<li><a href="#_测试_10">9.1.1. 测试</a></li>
</ul>
</li>
<li><a href="#_函数定义">9.2. 函数定义</a>
<ul class="sectlevel3">
<li><a href="#_测试_11">9.2.1. 测试</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_第十章变长参数的函数">10. 第十章：变长参数的函数</a>
<ul class="sectlevel2">
<li><a href="#_实现_7">10.1. 实现</a></li>
<li><a href="#_测试_12">10.2. 测试</a></li>
</ul>
</li>
<li><a href="#_第十一章宏">11. 第十一章：宏</a>
<ul class="sectlevel2">
<li><a href="#_例子">11.1. 例子</a></li>
<li><a href="#_实现_8">11.2. 实现</a></li>
<li><a href="#_测试_13">11.3. 测试</a></li>
</ul>
</li>
<li><a href="#_第十二章库">12. 第十二章：库</a>
<ul class="sectlevel2">
<li><a href="#_测试_14">12.1. 测试</a></li>
<li><a href="#_fold">12.2. fold</a>
<ul class="sectlevel3">
<li><a href="#_测试_15">12.2.1. 测试</a></li>
</ul>
</li>
<li><a href="#_更多内置函数">12.3. 更多内置函数</a>
<ul class="sectlevel3">
<li><a href="#_apply">12.3.1. apply</a></li>
<li><a href="#_eq">12.3.2. eq?</a></li>
<li><a href="#_pair">12.3.3. pair?</a></li>
<li><a href="#_map">12.3.4. map</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_第十三章准引用quasiquote">13. 第十三章：准引用(QUASIQUOTE)</a>
<ul class="sectlevel2">
<li><a href="#_例子_2">13.1. 例子</a></li>
<li><a href="#_语法糖">13.2. 语法糖</a></li>
<li><a href="#_实现_9">13.3. 实现</a>
<ul class="sectlevel3">
<li><a href="#_测试_16">13.3.1. 测试</a></li>
</ul>
</li>
<li><a href="#_let">13.4. let</a>
<ul class="sectlevel3">
<li><a href="#_例子_3">13.4.1. 例子</a></li>
<li><a href="#_测试_17">13.4.2. 测试</a></li>
</ul>
</li>
<li><a href="#_一个小技巧">13.5. 一个小技巧</a>
<ul class="sectlevel3">
<li><a href="#_测试_18">13.5.1. 测试</a></li>
</ul>
</li>
<li><a href="#_完整代码_3">13.6. 完整代码</a></li>
</ul>
</li>
<li><a href="#_第十四章延续和尾递归">14. 第十四章：延续和尾递归</a>
<ul class="sectlevel2">
<li><a href="#_实现_10">14.1. 实现</a>
<ul class="sectlevel3">
<li><a href="#_测试_19">14.1.1. 测试</a></li>
</ul>
</li>
<li><a href="#_尾递归">14.2. 尾递归</a></li>
</ul>
</li>
<li><a href="#_第十五章垃圾收集">15. 第十五章：垃圾收集</a>
<ul class="sectlevel2">
<li><a href="#_测试_20">15.1. 测试</a></li>
</ul>
</li>
<li><a href="#_第十六章接下来做什么">16. 第十六章：接下来做什么？</a></li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="_第一章简介">1. 第一章：简介</h2>
<div class="sectionbody">
<div class="paragraph">
<p>理解事物如何工作的最好方法是尝试自己构建它。阅读别人的解释可能会满足我们的好奇心，但是如果没有踩坑的经验，就很难理解为什么某些事物是以某种方式设计的。</p>
</div>
<div class="paragraph">
<p>有人说，每个程序员都应该编写一个编译器。尽管我认为这是个不错的建议（尽管我自己并没有遵循），但是在解析诸如C之类的语言时需要付出大量的努力，以至于任何潜在的见解都有可能迷失在细节中。也许为一些简单的语言创建一个解释器将是一个很好的第一步。</p>
</div>
<div class="paragraph">
<p>早在几年前，我开始使用LISP。我阅读了《计算机程序的结构和解释》。你需要阅读一下这本书。</p>
</div>
<div class="paragraph">
<p>这本书涵盖了许多主题，但是下半部分详细介绍了如何对LISP程序进行求值(eval)，也就是使用LISP本身实现了一个 <code>eval</code> 函数。我认为这可以很好地转换为C程序，因此决定尝试创建自己的LISP实现。</p>
</div>
<div class="paragraph">
<p>作为一名专业程序员，我将大部分时间都花在编写C和C++上。其余大多数是Java。有很多语言在那里，每个都有自己的优点值得商榷，但我想证明实现一个LISP机器是一件多简单的事情，甚至使用像C语言这样的底层语言来实现。</p>
</div>
<div class="paragraph">
<p>所以这是我的LISP的玩具实现。我已经从各种方言中借用了功能，但是它比Common LISP更接近Scheme。差异是微不足道的，以至于转换不需要对解释程序进行实质性的更改。如果你不熟悉LISP，请不要担心。我将在实现LISP的过程中定义所有内容。</p>
</div>
<div class="paragraph">
<p>它既不是最小的实现，也不是最高效的，也不是最完整的实现。但是它可以说是懒惰的。我的目标是编写功能强大，易于阅读的代码，该代码完全满足其需要，并且不再需要执行任何其他操作，并且我希望它可以传达构建诸如LISP之类的功能强大的环境所需的工作量。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第二章数据">2. 第二章：数据</h2>
<div class="sectionbody">
<div class="paragraph">
<p>我们将首先定义四种对象：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>整数：一个数字。例如：3,-9,0。</p>
</li>
<li>
<p>符号：由字符串组成的名称。例如：FOO,BAR,ADD-TWO。我们将在此项目中将符号规范化为大写，但这不是绝对必要的。</p>
</li>
<li>
<p><code>NIL</code> ：表示“无”。有点像C语言和其他语言中的 <code>NULL</code> 。</p>
</li>
<li>
<p><code>Pair</code> ：<code>Pair</code> 由两个元素组成，出于历史原因，它们被称为 <code>car</code> 和 <code>cdr</code> 。 <code>Pair</code> 中的两个元素可以是整数，符号， <code>NIL</code> ，或者其他 <code>Pair</code> 的引用。每个元素的类型可能不同。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>整数，符号和 <code>NIL</code> 被称作简单数据类型。术语 <strong>atom</strong> 指任何一个简单数据类型或者 <code>Pair</code> 。</p>
</div>
<div class="paragraph">
<p>请注意，整数和符号是 <em>不可变的</em> ，因此我们可以将具有相同值的两个整数视为同一对象。这对符号特别有用，因为它允许我们通过比较指针来测试两个符号是否相等。</p>
</div>
<div class="sect2">
<h3 id="_实现">2.1. 实现</h3>
<div class="paragraph">
<p>让我们声明一些C类型来保存我们的数据。有许多聪明的方法可以有效地存储LISP对象，但是对于此实现，我们将坚持一个非常简单的方案。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">struct Atom {
    enum {
        AtomType_Nil,
        AtomType_Pair,
        AtomType_Symbol,
        AtomType_Integer
    } type;

    union {
        struct Pair *pair;
        const char *symbol;
        long integer;
    } value;
};

struct Pair {
    struct Atom atom[2];
};

typedef struct Atom Atom;</code></pre>
</div>
</div>
<div class="paragraph">
<p>定义一些宏将很方便：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">#define car(p) ((p).value.pair-&gt;atom[0])
#define cdr(p) ((p).value.pair-&gt;atom[1])
#define nilp(atom) ((atom).type == AtomType_Nil)

static const Atom nil = { AtomType_Nil };</code></pre>
</div>
</div>
<div class="paragraph">
<p>整数和指向字符串的指针可以拷贝，但是我们想要初始化 <code>Pair</code> 的话，需要从堆( <code>Heap</code> )上申请内存。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">Atom cons(Atom car_val, Atom cdr_val)
{
    Atom p;

    p.type = AtomType_Pair;
    p.value.pair = malloc(sizeof(struct Pair));

    car(p) = car_val;
    cdr(p) = cdr_val;

    return p;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>cons</code> 是这样一个函数，它在堆上分配一个 <code>Pair</code> ，然后对 <code>Pair</code> 的两个元素进行赋值。</p>
</div>
</div>
<div class="sect2">
<h3 id="_测试">2.2. 测试</h3>
<div class="paragraph">
<p>现在我们可以创建一些LISP对象了。创建一个整数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">Atom make_int(long x)
{
    Atom a;
    a.type = AtomType_Integer;
    a.value.integer = x;
    return a;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>创建一个符号：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">Atom make_sym(const char *s)
{
    Atom a;
    a.type = AtomType_Symbol;
    a.value.symbol = strdup(s);
    return a;
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_文本表示">2.3. 文本表示</h3>
<div class="paragraph">
<p>我们可以将一个 <code>Pair</code> 写作下面这种方式：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-lisp hljs" data-lang="lisp">(a . b)</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>a</code> 是 <code>car</code> ， <code>b</code> 是 <code>cdr</code> 。</p>
</div>
<div class="paragraph">
<p>将 <code>pair</code> 中的 <code>cdr</code> 部分指向另一个 <code>pair</code> ，我们就可以创建一个链了。比如下面这样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-lisp hljs" data-lang="lisp">(a . (b . (c . (d . NIL))))</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，最后一个 <code>pair</code> 的 <code>cdr</code> 部分是一个 <code>NIL</code> ，这标示了链的结束。我们叫这个链为 <code>列表</code> 。为了避免写大量的括号，我们可以将上面的列表写成下面这种格式：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-lisp hljs" data-lang="lisp">(a b c d)</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果列表中的最后一个 <code>pair</code> 的 <code>cdr</code> 部分不是 <code>NIL</code> 的话，可以写作如下形式：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-lisp hljs" data-lang="lisp">(p q . r)</code></pre>
</div>
</div>
<div class="paragraph">
<p>等价于：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-lisp hljs" data-lang="lisp">(p . (q . r))</code></pre>
</div>
</div>
<div class="paragraph">
<p>以上这种写法被成为 <em>improper list</em> 。</p>
</div>
</div>
<div class="sect2">
<h3 id="_实现_2">2.4. 实现</h3>
<div class="paragraph">
<p>打印一个符号或者 <code>Pair</code> 很简单。代码如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">void print_expr(Atom atom)
{
    switch (atom.type) {
    case AtomType_Nil:
        printf("NIL");
        break;
    case AtomType_Pair:
        putchar('(');
        print_expr(car(atom));
        atom = cdr(atom);
        while (!nilp(atom)) {
            if (atom.type == AtomType_Pair) {
                putchar(' ');
                print_expr(car(atom));
                atom = cdr(atom);
            } else {
                printf(" . ");
                print_expr(atom);
                break;
            }
        }
        putchar(')');
        break;
    case AtomType_Symbol:
        printf("%s", atom.value.symbol);
        break;
    case AtomType_Integer:
        printf("%ld", atom.value.integer);
        break;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>通过使用递归的方式，我们可以打印任意复杂的数据结构。当然如果打印一个嵌套很深的数据结构时，可能会出现栈空间不足。而打印一个存在循环引用的数据结构时，也会出现死循环。</p>
</div>
</div>
<div class="sect2">
<h3 id="_测试_2">2.5. 测试</h3>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Atom</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Output</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">make_int(42)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">42</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">make_sym("FOO")</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">FOO</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">cons(make_sym("X"), make_sym("Y"))</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">(X . Y)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">cons(make_int(1),
  cons(make_int(2),
  cons(make_int(3),
  nil)))</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">(1 2 3)</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>可以看到，这些事情很简单。下一章我们将会搞一些更复杂的事情。</p>
</div>
</div>
<div class="sect2">
<h3 id="_最后一件事情">2.6. 最后一件事情</h3>
<div class="paragraph">
<p>还记得我们说过我们将相同的符号视为相同的对象吗？我们可以强制跟踪每一个创建的符号，如果创建了一个之前已经创建过的字符序列，我们将返回同一个符号。</p>
</div>
<div class="paragraph">
<p>如果实现的语言是内置了集合或者哈希表数据结构的语言的话，实现这个功能将会很容易。但是我们也可以使用已经实现的LISP数据结构，将符号存储在一个列表中。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">static Atom sym_table = { AtomType_Nil };

Atom make_sym(const char *s)
{
    Atom a, p;

    p = sym_table;
    while (!nilp(p)) {
        a = car(p);
        if (strcmp(a.value.symbol, s) == 0)
            return a;
        p = cdr(p);
    }

    a.type = AtomType_Symbol;
    a.value.symbol = strdup(s);
    sym_table = cons(a, sym_table);

    return a;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个实现看起来不是很高效，是吗？但足够用了，代码可读性也很好。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第三章解析器">3. 第三章：解析器</h2>
<div class="sectionbody">
<div class="paragraph">
<p>下一个阶段就是解析了。就是读取一行文本，然后创建这个文本所表示的对象。如果这行文本并不表示我们定义过的对象，我们需要抛出错误。</p>
</div>
<div class="sect2">
<h3 id="_错误处理">3.1. 错误处理</h3>
<div class="paragraph">
<p>错误的定义如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">typedef enum {
    Error_OK = 0,
    Error_Syntax
} Error;</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果像我一样，你学过BASIC编程，那么你将很熟悉可怕的 <code>SYNTAX ERROR</code> 。现在是我们从栅栏另一侧看东西的机会。从现在开始，我们的大多数函数都将返回错误，以指示是否出了问题以及出了什么问题。</p>
</div>
</div>
<div class="sect2">
<h3 id="_词法分析lexer">3.2. 词法分析（Lexer）</h3>
<div class="paragraph">
<p>我没有接受过CS的正式培训，但是据我了解，它的想法是将字符串拆分成 <code>token</code> 的列表，这些 <code>token</code> 既是“单词”又是“标点符号”，并丢弃所有无关紧要的空格。因此，如果输入为：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-lisp hljs" data-lang="lisp">(foo bar)</code></pre>
</div>
</div>
<div class="paragraph">
<p>那么经过词法分析生成的4个 <code>token</code> 应该是：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">(</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">foo</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">bar</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">)</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>让我们先来创建一个词法分析器（lexer），词法分析器将返回 <code>token</code> 的开始位置的指针和结束位置的指针。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">int lex(const char *str, const char **start, const char **end)
{
    const char *ws = " \t\n";
    const char *delim = "() \t\n";
    const char *prefix = "()";

    // C 库函数 size_t strspn(const char *str1, const char *str2) 检索字符串 str1 中第一个不在字符串 str2 中出现的字符下标。
    // 检索字符串 str 中第一个不在字符串 ws 中出现的字符下标
    str += strspn(str, ws);

    if (str[0] == '\0') {
        *start = *end = NULL;
        return Error_Syntax;
    }

    *start = str;

    // C 库函数 char *strchr(const char *str, int c) 在参数 str 所指向的字符串中搜索第一次出现字符 c（一个无符号字符）的位置。
    if (strchr(prefix, str[0]) != NULL)
        *end = str + 1;
    else
        // C 库函数 size_t strcspn(const char *str1, const char *str2) 检索字符串 str1 开头连续有几个字符都不含字符串 str2 中的字符。
        *end = str + strcspn(str, delim);

    return Error_OK;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果我们的词法分析器在没有找到 <code>token</code> 的情况下已经来到了字符串的末尾（即，字符串的其余部分完全是空格），则它将返回语法错误并将开始和结束设置为NULL。</p>
</div>
</div>
<div class="sect2">
<h3 id="_解析器">3.3. 解析器</h3>
<div class="paragraph">
<p>现在我们可以考虑解析器本身。入口点是 <code>read_expr</code> 函数，它将读取单个（可能是复杂的）对象，并返回错误状态和指向输入其余部分的指针。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">int read_expr(const char *input, const char **end, Atom *result);</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们将首先处理简单的数据：整数，符号和NIL。如果有一个正则表达式库，那么这很容易，但是使用C语言也不复杂。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">int parse_simple(const char *start, const char *end, Atom *result)
{
    char *buf, *p;

    /* Is it an integer? */
    long val = strtol(start, &amp;p, 10);
    if (p == end) {
        result-&gt;type = AtomType_Integer;
        result-&gt;value.integer = val;
        return Error_OK;
    }

    /* NIL or symbol */
    buf = malloc(end - start + 1);
    p = buf;
    while (start != end)
        *p++ = toupper(*start), ++start;
    *p = '\0';

    if (strcmp(buf, "NIL") == 0)
        *result = nil;
    else
        *result = make_sym(buf);

    free(buf);

    return Error_OK;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意两件事：首先，我们将输入转换为大写。这不是严格必要的-区分大小写的lisp没有错-但这是传统的行为。其次， <code>NIL</code> 是一个特例：它直接解析为 <code>AtomType_Nil</code> ，而不是将其解析为符号。</p>
</div>
<div class="paragraph">
<p>如果你熟悉LISP的各种方言，那么你将知道 <code>NIL</code> 不一定与 <code>()</code> 空列表相同。我们可以选择将 <code>NIL</code> 视为求值结果是自身的符号，但是对于本项目，我们将认为两种表示形式完全相同。</p>
</div>
<div class="paragraph">
<p>接下来是列表（包括 improper 列表和对）。简化的列表语法使此操作有些复杂，因此我们将其全部保留在辅助函数中。递归再次使我们能够处理嵌套列表。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">int read_list(const char *start, const char **end, Atom *result)
{
    Atom p;

    *end = start;
    p = *result = nil;

    for (;;) {
        const char *token;
        Atom item;
        Error err;

        err = lex(*end, &amp;token, end);
        if (err)
            return err;

        if (token[0] == ')')
            return Error_OK;

        if (token[0] == '.' &amp;&amp; *end - token == 1) {
            /* Improper list */
            if (nilp(p))
                return Error_Syntax;

            err = read_expr(*end, end, &amp;item);
            if (err)
                return err;

            cdr(p) = item;

            /* Read the closing ')' */
            err = lex(*end, &amp;token, end);
            if (!err &amp;&amp; token[0] != ')')
                err = Error_Syntax;

            return err;
        }

        err = read_expr(token, end, &amp;item);
        if (err)
            return err;

        if (nilp(p)) {
            /* First item */
            *result = cons(item, nil);
            p = *result;
        } else {
            cdr(p) = cons(item, nil);
            p = cdr(p);
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>我不喜欢写无限循环，但这是我到目前为止写出的结构最清晰的代码。</p>
</div>
<div class="paragraph">
<p>最后，我们有了 <code>read_expr</code> 本身，由于我们已经完成了所有艰苦的工作，所以这很简单：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">int read_expr(const char *input, const char **end, Atom *result)
{
    const char *token;
    Error err;

    err = lex(input, &amp;token, end);
    if (err)
        return err;

    if (token[0] == '(')
        return read_list(*end, end, result);
    else if (token[0] == ')')
        return Error_Syntax;
    else
        return parse_simple(token, *end, result);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里对右括号的检查将会捕获一些不合法的代码形式，例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-scheme hljs" data-lang="scheme">)</code></pre>
</div>
</div>
<div class="paragraph">
<p>以及</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-scheme hljs" data-lang="scheme">(X .)</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_测试_3">3.4. 测试</h3>
<div class="paragraph">
<p>如果使用解析器创建一个简单的读取-打印循环（read-print-loop），则可以在控制台上键入对象的表示形式并检查是否正确解析了它们。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">int main(int argc, char **argv)
{
    char *input;

    while ((input = readline("&gt; ")) != NULL) {
        const char *p = input;
        Error err;
        Atom expr;

        err = read_expr(p, &amp;p, &amp;expr);

        switch (err) {
        case Error_OK:
            print_expr(expr);
            putchar('\n');
            break;
        case Error_Syntax:
            puts("Syntax error");
            break;
        }

        free(input);
    }

    return 0;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>上面的代码使用了 <code>readline</code> 库，该库显示提示并从控制台读取一行文本。它支持的编辑功能很强大，但是围绕 <code>fgets()</code> 的简单封装也可以做到相同的事情。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">&gt; 42
42
&gt; (foo bar)
(FOO BAR)
&gt; (s (t . u) v . (w . nil))
(S (T . U) V W)
&gt; ()
NIL</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_完整代码">3.5. 完整代码</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;ctype.h&gt;
#include &lt;readline/readline.h&gt;

typedef enum {
    Error_OK = 0,
    Error_Syntax
} Error;

struct Atom
{
    enum {
        AtomType_Nil,
        AtomType_Pair,
        AtomType_Symbol,
        AtomType_Integer
    } type;

    union {
        struct Pair *pair;
        const char *symbol;
        long integer;
    } value;
};

struct Pair {
    struct Atom atom[2];
};

typedef struct Atom Atom;

#define car(p) ((p).value.pair-&gt;atom[0])
#define cdr(p) ((p).value.pair-&gt;atom[1])
#define nilp(atom) ((atom).type == AtomType_Nil)

static const Atom nil = { AtomType_Nil };

Atom cons(Atom car_val, Atom cdr_val)
{
    Atom p;

    p.type = AtomType_Pair;
    p.value.pair = malloc(sizeof(struct Pair));

    car(p) = car_val;
    cdr(p) = cdr_val;

    return p;
}

Atom make_int(long x)
{
    Atom a;
    a.type = AtomType_Integer;
    a.value.integer = x;
    return a;
}

Atom make_sym(const char *s)
{
    Atom a;
    a.type = AtomType_Symbol;
    a.value.symbol = strdup(s);
    return a;
}

int lex(const char *str, const char **start, const char **end)
{
    const char *ws = " \t\n";
    const char *delim = "() \t\n";
    const char *prefix = "()";

    str += strspn(str, ws);

    if (str[0] == '\0') {
        *start = *end = NULL;
        return Error_Syntax;
    }

    *start = str;

    // strchr函数功能为在一个串中查找给定字符的第一个匹配之处
    if (strchr(prefix, str[0]) != NULL)
        *end = str + 1;
    else
    // 该函数返回 str1 开头连续都不含字符串 str2 中字符的字符数。
        *end = str + strcspn(str, delim);

    return Error_OK;
}

int read_expr(const char *input, const char **end, Atom *result);

int parse_simple(const char *start, const char *end, Atom *result)
{
    char *buf, *p;

    long val = strtol(start, &amp;p, 10);
    if (p == end) {
        result-&gt;type = AtomType_Integer;
        result-&gt;value.integer = val;
        return Error_OK;
    }

    buf = malloc(end - start + 1);
    p = buf;
    while (start != end)
        *p++ = toupper(*start), ++start;
    *p = '\0';

    if (strcmp(buf, "NIL") == 0) {
        *result = nil;
    } else {
        *result = make_sym(buf);
    }

    free(buf);

    return Error_OK;
}

int read_list(const char *start, const char **end, Atom *result)
{
    Atom p;

    *end = start;
    p = *result = nil;

    for (;;) {
        const char *token;
        Atom item;
        Error err;

        err = lex(*end, &amp;token, end);
        if (err) {
            return err;
        }

        if (token[0] == ')') {
            return Error_OK;
        }

        if (token[0] == '.' &amp;&amp; *end - token == 1) {
            if (nilp(p)) {
                return Error_Syntax;
            }

            err = read_expr(*end, end, &amp;item);
            if (err) {
                return err;
            }

            cdr(p) = item;

            err = lex(*end, &amp;token, end);
            if (!err &amp;&amp; token[0] != ')') {
                err = Error_Syntax;
            }

            return err;
        }

        err = read_expr(token, end, &amp;item);
        if (err) {
            return err;
        }

        if (nilp(p)) {
            *result = cons(item, nil);
            p = *result;
        } else {
            cdr(p) = cons(item, nil);
            p = cdr(p);
        }
    }
}

int read_expr(const char *input, const char **end, Atom *result)
{
    const char *token;
    Error err;

    err = lex(input, &amp;token, end);
    if (err) return err;

    if (token[0] == '(') {
        return read_list(*end, end, result);
    } else if (token[0] == ')') {
        return Error_Syntax;
    } else {
        return parse_simple(token, *end, result);
    }
}

void print_expr(Atom atom)
{
    switch (atom.type)
    {
    case AtomType_Nil:
        printf("NIL");
        break;

    case AtomType_Pair:
        putchar('(');
        print_expr(car(atom));
        atom = cdr(atom);
        while (!nilp(atom)) {
            if (atom.type == AtomType_Pair) {
                putchar(' ');
                print_expr(car(atom));
                atom = cdr(atom);
            } else {
                printf(" . ");
                print_expr(atom);
                break;
            }
        }
        putchar(')');
        break;

    case AtomType_Symbol:
        printf("%s", atom.value.symbol);
        break;

    case AtomType_Integer:
        printf("%ld", atom.value.integer);
        break;

    default:
        break;
    }
}

int main(int argc, char const *argv[])
{
    char *input;

    while ((input = readline("&gt; ")) != NULL) {
        const char *p = input;
        Error err;
        Atom expr;

        err = read_expr(p, &amp;p, &amp;expr);

        switch (err)
        {
        case Error_OK:
            print_expr(expr);
            putchar('\n');
            break;
        case Error_Syntax:
            puts("Syntax error");
            break;
        }

        free(input);
    }

    return 0;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在Ubuntu环境下，可以安装 readline 库，然后再编译的时候需要链接上这个库。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">$ sudo apt-get install libreadline6-dev
$ gcc lisp.c -lreadline -o lisp</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第四章表达式环境和求值">4. 第四章：表达式、环境和求值</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_表达式">4.1. 表达式</h3>
<div class="paragraph">
<p>在LISP中，一切都是表达式。表达式可以是字面量，标识符或由运算符和一个或多个参数组成的列表。</p>
</div>
<div class="paragraph">
<p>字面量是具有内在值的对象。在我们的系统中，它可以是整数或NIL（如果你认为"nothing"是一个值的话）。</p>
</div>
<div class="paragraph">
<p>标识符是对象的名称。符号可以是标识符。</p>
</div>
<div class="paragraph">
<p>其他所有内容都是形式为 <code>(运算符 参数&#8230;&#8203;)</code> 的列表，其中 <code>参数&#8230;&#8203;</code> 表示零个或多个参数。</p>
</div>
</div>
<div class="sect2">
<h3 id="_环境">4.2. 环境</h3>
<div class="paragraph">
<p>为了将标识符和对象关联起来，我们需要 <em>环境</em> 。环境是一系列绑定（binding）的集合。每一个绑定由一个标识符和标识符所对应的值组成。例如：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 1. 绑定（bindings）</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>标识符</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>值</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">FOO</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">42</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">BAR</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">NIL</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">BAZ</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">(X Y Z)</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>注意：所有的标识符都是符号。但是值可以是任意对象。例如BAZ就是一个包含三个符号的列表。</p>
</div>
<div class="paragraph">
<p>一个环境可能会有一个 <em>父环境</em> 。如果在一个环境里面，不存在某个标识符对应的绑定，那么就会去父环境里去找这个标识符的绑定，如果还找不到，那么就会去父环境的父环境寻找标识符的绑定。所以可以看到，我们这里其实是创建了一棵环境树，一个环境会共享它的父环境的绑定。</p>
</div>
<div class="sect3">
<h4 id="_实现_3">4.2.1. 实现</h4>
<div class="paragraph">
<p>下面的代码是表达环境的一种传统方式，使用了LISP中的数据类型。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-scheme hljs" data-lang="scheme">(parent (identifier . value)...)</code></pre>
</div>
</div>
<div class="paragraph">
<p>所以上面的表：绑定所对应的环境如下（没有parent）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-scheme hljs" data-lang="scheme">(NIL (FOO . 42) (BAR . NIL) (BAZ . (X Y Z)))</code></pre>
</div>
</div>
<div class="paragraph">
<p>以下的C代码创建了一个空环境，这个空环境的父环境是parent（parent也可以是NIL）</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">Atom env_create(Atom parent)
{
    return cons(parent, nil);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>接下来我们写两个函数用来获取和创建环境中的绑定。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">int env_get(Atom env, Atom symbol, Atom *result)
{
    Atom parent = car(env);
    Atom bs = cdr(env);

    while (!nilp(bs)) {
        Atom b = car(bs);
        if (car(b).value.symbol == symbol.value.symbol) {
            *result = cdr(b);
            return Error_OK;
        }
        bs = cdr(bs);
    }

    if (nilp(parent))
        return Error_Unbound;

    return env_get(parent, symbol, result);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>由于我们禁止命名两个相同名字的符号，所以我们这里不需要调用 <code>strcmp</code> 函数，这意味着 <code>lookup</code> 函数运行起来速度不会太慢。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">int env_set(Atom env, Atom symbol, Atom value)
{
    Atom bs = cdr(env);
    Atom b = nil;

    while (!nilp(bs)) {
        b = car(bs);
        if (car(b).value.symbol == symbol.value.symbol) {
            cdr(b) = value;
            return Error_OK;
        }
        bs = cdr(bs);
    }

    b = cons(symbol, value);
    cdr(env) = cons(b, cdr(env));

    return Error_OK;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>只有 <code>env_get</code> 函数会递归的去检查父环境。因为我们并不想修改父环境的绑定。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_求值">4.3. 求值</h3>
<div class="paragraph">
<p>我们需要对表达式进行求值。求值过程的输入是一个表达式和一个环境，输出是一个值。让我们规定一下求值的规则。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>字面量的求值结果是它本身。</p>
</li>
<li>
<p>环境可以让我们找到一个标识符所对应的值是什么。如果环境中不存在一个标识符所对应的值，那么对这个标识符求值会返回错误。</p>
</li>
<li>
<p>一个列表表达式如果具有以下某个操作符，就成为一个 <em>特殊形式</em> (special form)：</p>
</li>
<li>
<p><strong>QUOTE</strong> ：表达式 <code>(QUOTE EXPR)</code> 的求值结果是： <code>EXPR</code> 。这个 <code>EXPR</code> 被直接返回，并没有进行求值。</p>
</li>
<li>
<p><strong>DEFINE</strong> ：对表达式 <code>(DEFINE SYMBOL EXPR)</code> 进行求值将会创建一个针对 <code>SYMBOL</code> 在环境中的绑定，或者修改这个 <code>SYMBOL</code> 在环境中的绑定。 <code>SYMBOL</code> 将会绑定到 <code>EXPR</code> 的求值结果。 <code>DEFINE</code> 表达式的求值结果将返回 <code>SYMBOL</code> 。</p>
</li>
<li>
<p>对其他任何形式的表达式进行求值都是无效的。</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_实现_4">4.3.1. 实现</h4>
<div class="paragraph">
<p>我们需要检查一下一个表达式是否是正规列表（proper list）。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">int listp(Atom expr)
{
    while (!nilp(expr)) {
        if (expr.type != AtomType_Pair)
            return 0;
        expr = cdr(expr);
    }
    return 1;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Error枚举类型需要一些更多的选项：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Error_Unbound</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">试图去对一个不存在绑定的符号求值</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Error_Args</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">一个列表表达式比预期的长或者短</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Error_Type</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">表达式中对象的类型和预期的不一样（类型错误）</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>我们直接将表达式的求值规则翻译成C语言就可以了。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">int eval_expr(Atom expr, Atom env, Atom *result)
{
    Atom op, args;
    Error err;

    if (expr.type == AtomType_Symbol) {
        return env_get(env, expr, result);
    } else if (expr.type != AtomType_Pair) {
        *result = expr;
        return Error_OK;
    }

    if (!listp(expr))
        return Error_Syntax;

    op = car(expr);
    args = cdr(expr);

    if (op.type == AtomType_Symbol) {
        if (strcmp(op.value.symbol, "QUOTE") == 0) {
            if (nilp(args) || !nilp(cdr(args)))
                return Error_Args;

            *result = car(args);
            return Error_OK;
        } else if (strcmp(op.value.symbol, "DEFINE") == 0) {
            Atom sym, val;

            if (nilp(args) || nilp(cdr(args)) || !nilp(cdr(cdr(args))))
                return Error_Args;

            sym = car(args);
            if (sym.type != AtomType_Symbol)
                return Error_Type;

            err = eval_expr(car(cdr(args)), env, &amp;val);
            if (err)
                return err;

            *result = sym;
            return env_set(env, sym, val);
        }
    }

    return Error_Syntax;
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_测试_4">4.3.2. 测试</h4>
<div class="paragraph">
<p>将读取-打印循环扩展成为 <code>读取-求值-打印</code> 循环（REPL）。REPL是LISP解释器的核心功能。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">int main(int argc, char **argv)
{
    Atom env;
    char *input;

    env = env_create(nil);

    while ((input = readline("&gt; ")) != NULL) {
        const char *p = input;
        Error err;
        Atom expr, result;

        err = read_expr(p, &amp;p, &amp;expr);

        if (!err)
            err = eval_expr(expr, env, &amp;result);

        switch (err) {
        case Error_OK:
            print_expr(result);
            putchar('\n');
            break;
        case Error_Syntax:
            puts("Syntax error");
            break;
        case Error_Unbound:
            puts("Symbol not bound");
            break;
        case Error_Args:
            puts("Wrong number of arguments");
            break;
        case Error_Type:
            puts("Wrong type");
            break;
        }

        free(input);
    }

    return 0;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>让我们看一下结果：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">&gt; foo
Symbol not bound
&gt; (quote foo)
FOO
&gt; (define foo 42)
FOO
&gt; foo
42
&gt; (define foo (quote bar))
FOO
&gt; foo
BAR</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第五章内建函数">5. 第五章：内建函数</h2>
<div class="sectionbody">
<div class="paragraph">
<p>到目前为止，在我们的实现中，我们已经使用了 <code>car</code> ， <code>cdr</code> 和 <code>cons</code> 函数来构造和访问LISP数据。现在，我们将在解释环境中提供相同的功能。</p>
</div>
<div class="paragraph">
<p>我们将扩展列表表达式语法以添加一些新的运算符：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>(CAR EXPR)</code> ：对 <code>EXPR</code> 进行求值，然后返回求值结果的 <code>car</code> 部分。如果 <code>EXPR</code> 的求值结果既不是 <code>pair</code> 也不是 <code>NIL</code> ，则返回错误。</p>
</li>
<li>
<p><code>(CDR EXPR)</code> ：对 <code>EXPR</code> 进行求值，然后返回求值结果的 <code>cdr</code> 部分。如果 <code>EXPR</code> 的求值结果既不是 <code>pair</code> 也不是 <code>NIL</code> ，则返回错误。</p>
</li>
<li>
<p><code>(CONS A B)</code> ：Evaluates both arguments A and B, and returns a newly constructed pair containing the results.对 <code>A</code> 和 <code>B</code> 进行求值，然后返回包含 <code>A</code> 和 <code>B</code> 的求值结果的 <code>pair</code> 。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在上面的定义中，我们允许对 <code>NIL</code> 取 <code>car</code> 部分和 <code>cdr</code> 部分，不像我们之前C版本对 <code>car</code> 和 <code>cdr</code> 的实现。如果对 <code>NIl</code> 取 <code>car</code> 和 <code>cdr</code> 的值定义为 <code>NIL</code> ，那么一些算法会相对容易实现一些。</p>
</div>
<div class="paragraph">
<p>我们选择在 <code>eval_expr</code> 函数中添加一些分支条件来实现上面定义的内置函数，就像我们之前实现 <code>QUOTE</code> 和 <code>DEFINE</code> 一样。尽管如此，我们想在未来添加更多的运算符，而将每个运算符都添加到 <code>eval_expr</code> 中会让函数变得很长。所以我们现在来介绍一下函数的概念。</p>
</div>
<div class="paragraph">
<p><strong>函数</strong></p>
</div>
<div class="paragraph">
<p>一个函数就是一个代码片段，这个代码片段将一些参数转换成了一个值。如果 <code>eval_expr</code> 碰到了一个列表表达式，而列表表达式中有一个函数是运算符，那么 <code>eval_expr</code> 所要做的就是执行函数的代码片段，然后将所得到的求值结果作为表达式的结果返回。</p>
</div>
<div class="paragraph">
<p>实现函数的方式就是创建一些C函数，可以被 <code>eval_expr</code> 所调用。我们称这些函数为内置函数或者原始函数。让我们来看一下如何扩展我们的LISP解释器将函数包含进来。</p>
</div>
<div class="sect2">
<h3 id="_一种新的atom类型">5.1. 一种新的Atom类型</h3>
<div class="paragraph">
<p><code>eval_expr</code> 将通过C的函数指针来调用内置函数，所以内置函数的类型必须一样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">typedef int (*Builtin)(struct Atom args, struct Atom *result);</code></pre>
</div>
</div>
<div class="paragraph">
<p>上面是一个函数指针类型，这个函数指针的类型是 <code>Builtin</code> ，接收两个参数，返回值是 <code>int</code> 。</p>
</div>
<div class="paragraph">
<p>为了可以在表达式中出现函数，我们需要一种新的 <code>atom</code> 类型来表示它们。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">struct Atom {
    enum {
        .
        .
        .
        AtomType_Builtin
    } type;

    union {
        .
        .
        .
        Builtin builtin;
    } value;
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们之前写过的代码用". . ."表示省略。为了代码的完整性， <code>print_expr</code> 需要知道如何显示新的 <code>atom</code> 类型：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">void print_expr(Atom atom)
{
    switch (atom.type) {
    .
    .
    .
    case AtomType_Builtin:
        printf("#&lt;BUILTIN:%p&gt;", atom.value.builtin);
        break;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>最终，我们写一个辅助方法来创建新的 <code>atom</code> 类型：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">Atom make_builtin(Builtin fn)
{
    Atom a;
    a.type = AtomType_Builtin;
    a.value.builtin = fn;
    return a;
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_扩展求值器">5.2. 扩展求值器</h3>
<div class="paragraph">
<p>我们将对参数列表进行 <em>浅拷贝</em> 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">Atom copy_list(Atom list)
{
    Atom a, p;

    if (nilp(list))
        return nil;

    a = cons(car(list), nil);
    p = a;
    list = cdr(list);

    while (!nilp(list)) {
        cdr(p) = cons(car(list), nil);
        p = cdr(p);
        list = cdr(list);
    }

    return a;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>apply</strong> 仅仅只是针对一个参数列表调用内置函数。我们将在后面扩展这个函数，因为我们需要处理一些其他的求值函数。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">int apply(Atom fn, Atom args, Atom *result)
{
    if (fn.type == AtomType_Builtin)
        return (*fn.value.builtin)(args, result);

    return Error_Type;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果列表表达式不是我们之前定义过的 <em>特殊形式</em> ，那么我们将假设运算符将会被求值成一个函数。我们将对参数列表中的每一个参数进行求值，然后使用 <code>apply</code> 来将函数作用到参数列表求值以后的结果列表上。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">int eval_expr(Atom expr, Atom env, Atom *result)
{
    Atom op, args, p;
    Error err;

    .
    .
    .

    if (op.type == AtomType_Symbol) {
        .
        .
        .
    }

    /* Evaluate operator */
    err = eval_expr(op, env, &amp;op);
    if (err)
        return err;

    /* Evaulate arguments */
    args = copy_list(args);
    p = args;
    while (!nilp(p)) {
        err = eval_expr(car(p), env, &amp;car(p));
        if (err)
            return err;

        p = cdr(p);
    }

    return apply(op, args, result);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们在对参数列表进行求值时，先对参数列表进行浅拷贝。这样就避免了把旧的参数列表覆盖掉。因为我们可能会再一次使用旧的参数列表。</p>
</div>
</div>
<div class="sect2">
<h3 id="_初始环境">5.3. 初始环境</h3>
<div class="paragraph">
<p>之前我们为LISP的 <code>读取——求值——打印</code> 循环创建过一个空环境。用户没有办法创建表示内置函数的 <code>atom</code> 类型。所以我们会在初始环境中绑定好内置函数。</p>
</div>
<div class="paragraph">
<p>以下是函数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">int builtin_car(Atom args, Atom *result)
{
    if (nilp(args) || !nilp(cdr(args)))
        return Error_Args;

    if (nilp(car(args)))
        *result = nil;
    else if (car(args).type != AtomType_Pair)
        return Error_Type;
    else
        *result = car(car(args));

    return Error_OK;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>函数中的大部分代码都是错误处理和类型检查。这样来创建函数真是一件烦人的事情。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">int builtin_cdr(Atom args, Atom *result)
{
    if (nilp(args) || !nilp(cdr(args)))
        return Error_Args;

    if (nilp(car(args)))
        *result = nil;
    else if (car(args).type != AtomType_Pair)
        return Error_Type;
    else
        *result = cdr(car(args));

    return Error_OK;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>builtin_cdr</code> 和 <code>builtin_car</code> 几乎是一样的。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">int builtin_cons(Atom args, Atom *result)
{
    if (nilp(args) || nilp(cdr(args)) || !nilp(cdr(cdr(args))))
        return Error_Args;

    *result = cons(car(args), car(cdr(args)));

    return Error_OK;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>有了以上的函数，我们就可以使用 <code>env_set</code> 函数来创建绑定了。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">int main(int argc, char **argv)
{
    Atom env;
    char *input;

    env = env_create(nil);

    /* Set up the initial environment */
    env_set(env, make_sym("CAR"), make_builtin(builtin_car));
    env_set(env, make_sym("CDR"), make_builtin(builtin_cdr));
    env_set(env, make_sym("CONS"), make_builtin(builtin_cons));

    while ((input = readline("&gt; ")) != NULL) {
        .
        .
        .
    }

    return 0;
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_测试_5">5.4. 测试</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">&gt; (define foo 1)
FOO
&gt; (define bar 2)
BAR
&gt; (cons foo bar)
(1 . 2)
&gt; (define baz (quote (a b c)))
BAZ
&gt; (car baz)
A
&gt; (cdr baz)
(B C)</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>(CONS FOO BAR)</code> 和 <code>(QUOTE (FOO . BAR))</code> 是不一样的。前者将会对参数列表进行求值，然后创建一个新的 <code>pair</code> 。
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第六章算术表达式">6. 第六章：算术表达式</h2>
<div class="sectionbody">
<div class="paragraph">
<p>到目前为止，我们所能做的就是创建和命名对象。这些对象中有些是数字——自然，我们想对这些数字进行计算。</p>
</div>
<div class="paragraph">
<p>在上一章中，我们看到了如何创建内置函数来告诉eval_expr如何将参数处理为返回值。现在，我们将再创建四个内建函数来执行基本的算术运算。</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Expression</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Result</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">(+ X Y)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The sum of X and Y</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">(- X Y)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The difference of X and Y</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">(* X Y)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The product of X and Y</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">(/ X Y)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The quotient of X and Y</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>在上面的定义中，当我们写“X和Y的总和”时，我们真正的意思是“通过求值X和Y所获得的值的总和”。请记住，默认情况下，eval_expr将对函数的所有参数求值；这通常是我们想要发生的事情，因此从现在开始，我们将不会在意图明显的地方明确声明这一点。</p>
</div>
<div class="sect2">
<h3 id="_实现_5">6.1. 实现</h3>
<div class="paragraph">
<p>再一次，几乎我们所有的函数都包括检查是否提供了正确的参数。最后，通过调用 <code>make_int</code> 构造结果。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">int builtin_add(Atom args, Atom *result)
{
    Atom a, b;

    if (nilp(args) || nilp(cdr(args)) || !nilp(cdr(cdr(args))))
        return Error_Args;

    a = car(args);
    b = car(cdr(args));

    if (a.type != AtomType_Integer || b.type != AtomType_Integer)
        return Error_Type;

    *result = make_int(a.value.integer + b.value.integer);

    return Error_OK;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>其他三个函数仅相差一个字符，因此在此将其省略。</p>
</div>
<div class="paragraph">
<p>最后，我们需要在初始环境中为我们的新功能创建绑定：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">env_set(env, make_sym("+"), make_builtin(builtin_add));
env_set(env, make_sym("-"), make_builtin(builtin_subtract));
env_set(env, make_sym("*"), make_builtin(builtin_multiply));
env_set(env, make_sym("/"), make_builtin(builtin_divide));</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_测试_6">6.2. 测试</h3>
<div class="paragraph">
<p>现在，我们有了自己的LISP风格的计算器。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">&gt; (+ 1 1)
2
&gt; (define x (* 6 9))
X
&gt; x
54
&gt; (- x 12)
42</code></pre>
</div>
</div>
<div class="paragraph">
<p>在上面的最后一个表达式中，请注意X是一个符号，而不是整数。我们必须对参数进行求值，以便builtin_subtract可以对绑定到X的整数值进行运算，而不是对符号X本身进行运算。同样，绑定到X的值是计算表达式（* 6 9）的整数结果。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第七章lambda表达式和闭包">7. 第七章：Lambda表达式和闭包</h2>
<div class="sectionbody">
<div class="paragraph">
<p>这是事情开始变得有趣的地方。现在，我们将实现对lambda表达式的支持，这是一种在我们已经可以处理的LISP表达式之外动态构建函数的方法。</p>
</div>
<div class="paragraph">
<p>Lambda表达式是具有特定语法的列表表达式：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-scheme hljs" data-lang="scheme">(LAMBDA (arg...) expr...)</code></pre>
</div>
</div>
<div class="paragraph">
<p>求值lambda表达式的结果是一种新型的对象，我们称其为闭包。闭包可以以与内置函数相同的方式在列表表达式中使用。在这种情况下，参数将绑定到lambda表达式中以 <code>arg&#8230;&#8203;</code> 列出的符号。函数的主体由表达式 <code>expr&#8230;&#8203;</code> 组成，这些表达式将依次求值。求值最终表达式的结果是将参数应用于闭包的结果。</p>
</div>
<div class="paragraph">
<p>这是一个非常密集的定义，因此这是一个我们如何使用lambda表达式的示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-scheme hljs" data-lang="scheme">(DEFINE SQUARE (LAMBDA (X) (* X X)))</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>SQUARE</code> 现在是一个函数，有一个参数X，返回值是X的平方。所以对 <code>(SQUARE 3)</code> 进行求值应该返回9。</p>
</div>
<div class="sect2">
<h3 id="_实现_6">7.1. 实现</h3>
<div class="paragraph">
<p>我们将使用列表来表示闭包：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-scheme hljs" data-lang="scheme">(env (arg...) expr...)</code></pre>
</div>
</div>
<div class="paragraph">
<p>env是定义闭包的环境。这是必需的，以允许lambda函数使用绑定而不必将其作为参数传递。例如，回想一下，CAR在初始环境中绑定到了我们原始的builtin_car函数。</p>
</div>
<div class="paragraph">
<p>第一个任务是为Atom结构的type字段添加一个新的常量：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">struct Atom {
    enum {
        .
        .
        .
        AtomType_Closure
    } type;

    union {
        .
        .
        .
    } value;
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>由于闭包只是常规列表，因此无需添加任何值。</p>
</div>
<div class="paragraph">
<p>像其他原子类型一样，我们将创建一个实用程序函数来初始化它们。 <code>make_closure</code> 与其他命令不同，对参数执行一些验证，因此需要返回错误代码。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">int make_closure(Atom env, Atom args, Atom body, Atom *result)
{
    Atom p;

    if (!listp(args) || !listp(body))
        return Error_Syntax;

    /* Check argument names are all symbols */
    p = args;
    while (!nilp(p)) {
        if (car(p).type != AtomType_Symbol)
            return Error_Type;
        p = cdr(p);
    }

    *result = cons(env, cons(args, body));
    result-&gt;type = AtomType_Closure;

    return Error_OK;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>接下来是eval中的另一种特殊情况，每当遇到lambda表达式时都创建一个闭包。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">int eval_expr(Atom expr, Atom env, Atom *result)
{
    .
    .
    .
    if (op.type == AtomType_Symbol) {
        if (strcmp(op.value.symbol, "QUOTE") == 0) {
        .
        .
        .
        } else if (strcmp(op.value.symbol, "LAMBDA") == 0) {
            if (nilp(args) || nilp(cdr(args)))
                return Error_Args;

            return make_closure(env, car(args), cdr(args), result);
        }
    }
    .
    .
    .
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>上面的SQUARE示例的函数体用X表示。为了对函数体进行求值，我们需要创建一个新环境，其中X绑定到参数的值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-scheme hljs" data-lang="scheme">(closure-env (X . 3))</code></pre>
</div>
</div>
<div class="paragraph">
<p>父环境 <code>closure-env</code> 是存储在闭包中的环境。</p>
</div>
<div class="paragraph">
<p>最后，我们扩展 <code>apply</code> 函数以创建新环境，并为函数体中的每个表达式调用eval。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">int apply(Atom fn, Atom args, Atom *result)
{
    Atom env, arg_names, body;

    if (fn.type == AtomType_Builtin)
        return (*fn.value.builtin)(args, result);
    else if (fn.type != AtomType_Closure)
        return Error_Type;

    env = env_create(car(fn));
    arg_names = car(cdr(fn));
    body = cdr(cdr(fn));

    /* Bind the arguments */
    while (!nilp(arg_names)) {
        if (nilp(args))
            return Error_Args;
        env_set(env, car(arg_names), car(args));
        arg_names = cdr(arg_names);
        args = cdr(args);
    }
    if (!nilp(args))
        return Error_Args;

    /* Evaluate the body */
    while (!nilp(body)) {
        Error err = eval_expr(car(body), env, result);
        if (err)
            return err;
        body = cdr(body);
    }

    return Error_OK;
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_测试_7">7.2. 测试</h3>
<div class="paragraph">
<p>让我们检查一下我们的SQUARE函数是否按预期工作。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-scheme hljs" data-lang="scheme">&gt; (define square (lambda (x) (* x x)))
SQUARE
&gt; (square 3)
9
&gt; (square 4)
16</code></pre>
</div>
</div>
<div class="paragraph">
<p>当然，lambda表达式不必绑定到符号——我们可以创建匿名函数。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-scheme hljs" data-lang="scheme">&gt; ((lambda (x) (- x 2)) 7)
5</code></pre>
</div>
</div>
<div class="paragraph">
<p>函数式编程的爱好者将很高兴看到我们现在可以做这种事情：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-scheme hljs" data-lang="scheme">&gt; (define make-adder (lambda (x) (lambda (y) (+ x y))))
MAKE-ADDER
&gt; (define add-two (make-adder 2))
ADD-TWO
&gt; (add-two 5)
7</code></pre>
</div>
</div>
<div class="paragraph">
<p>你知道值“2”存储在哪里吗？</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第八章布尔值和短路求值">8. 第八章：布尔值和短路求值</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_布尔值">8.1. 布尔值</h3>
<div class="paragraph">
<p>布尔值是称为true和false的两类值之一。如果我们希望将值解释为布尔值，则如果它属于true值类，则认为它为true，否则为false。</p>
</div>
</div>
<div class="sect2">
<h3 id="_短路求值">8.2. 短路求值</h3>
<div class="paragraph">
<p>到目前为止，我们求值了传递给eval的每个表达式。除特殊形式（如DEFINE和LAMBDA）存储了供以后求值的表达式外，eval必须在遍历整个树之前返回结果。</p>
</div>
<div class="paragraph">
<p>在本章中，我们将定义另一种特殊形式的IF，它将使eval选择要求值的两个可能表达式中的哪个，而舍弃另一个表达式。</p>
</div>
<div class="paragraph">
<p>语法如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-scheme hljs" data-lang="scheme">(IF test true-expr false-expr)</code></pre>
</div>
</div>
<div class="paragraph">
<p>其中test，true-expr和false-expr是任意表达式。如果对test求值的结果为真，则IF表达式的结果为true-expr的求值结果，否则为false-expr的求值结果。仅对true-expr和false-expr之一进行求值；另一个表达式将被忽略。</p>
</div>
<div class="paragraph">
<p>但是什么样的值才是真的？在我们的环境中，我们将NIL定义为false。任何其他值都为true。</p>
</div>
<div class="paragraph">
<p>这是处理IF表达式的代码。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">int eval_expr(Atom expr, Atom env, Atom *result)
{
    .
    .
    .
    if (op.type == AtomType_Symbol) {
        if (strcmp(op.value.symbol, "QUOTE") == 0) {
        .
        .
        .
        } else if (strcmp(op.value.symbol, "IF") == 0) {
            Atom cond, val;

            if (nilp(args) || nilp(cdr(args)) || nilp(cdr(cdr(args)))
                    || !nilp(cdr(cdr(cdr(args)))))
                return Error_Args;

            err = eval_expr(car(args), env, &amp;cond);
            if (err)
                return err;

            val = nilp(cond) ? car(cdr(cdr(args))) : car(cdr(args));
            return eval_expr(val, env, result);
        }
    }
    .
    .
    .
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>传统上，如果LISP函数需要返回布尔值并且没有明显的对象可用，则返回符号T。T是绑定到自身的，因此对其进行求值将再次返回符号T。如果符号不是NIL，那就是true。</p>
</div>
<div class="paragraph">
<p>将T的绑定添加到初始环境：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">env_set(env, make_sym("T"), make_sym("T"));</code></pre>
</div>
</div>
<div class="paragraph">
<p>请记住，如果多次调用具有相同字符串的同一个符号对象，make_sym将返回该对象。</p>
</div>
<div class="sect3">
<h4 id="_测试_8">8.2.1. 测试</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">&gt; (if t 3 4)
3
&gt; (if nil 3 4)
4
&gt; (if 0 t nil)
T</code></pre>
</div>
</div>
<div class="paragraph">
<p>和C不一样，0是true，而不是false。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_谓词">8.3. 谓词</h3>
<div class="paragraph">
<p>虽然我们可以在这里停下来，但进行一些测试（除了“is it NIL”之外）会很有用。这是谓词出现的地方。谓词是一个根据某些条件返回true/false值的函数。</p>
</div>
<div class="paragraph">
<p>我们将定义两个内置谓词，“=”测试数字相等性，“&lt;”测试一个数字是否小于另一个。</p>
</div>
<div class="paragraph">
<p>函数类似于我们的其他数字内置函数。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">int builtin_numeq(Atom args, Atom *result)
{
    Atom a, b;

    if (nilp(args) || nilp(cdr(args)) || !nilp(cdr(cdr(args))))
        return Error_Args;

    a = car(args);
    b = car(cdr(args));

    if (a.type != AtomType_Integer || b.type != AtomType_Integer)
        return Error_Type;

    *result = (a.value.integer == b.value.integer) ? make_sym("T") : nil;

    return Error_OK;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>builtin_less</code> 遵循相同的模式，此处未显示。</p>
</div>
<div class="paragraph">
<p>最后，我们必须将它们添加到初始环境中。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">env_set(env, make_sym("="), make_builtin(builtin_numeq));
env_set(env, make_sym("&lt;"), make_builtin(builtin_less));</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_测试_9">8.3.1. 测试</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">&gt; (= 3 3)
T
&gt; (&lt; 11 4)
NIL</code></pre>
</div>
</div>
<div class="paragraph">
<p>除非存在内存和堆栈限制，否则我们的LISP环境现在已经图灵完备！如果你一直在写代码，则可以确认我们已经在1000行以下C代码中实现了可用编程语言的核心。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_完整代码_2">8.4. 完整代码</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;ctype.h&gt;
#include &lt;readline/readline.h&gt;

typedef enum {
    Error_OK = 0,
    Error_Syntax,
    Error_Unbound,
    Error_Args,
    Error_Type
} Error;

typedef struct Atom Atom;
typedef int (*Builtin)(struct Atom args, struct Atom *result);

struct Atom
{
    enum {
        AtomType_Nil,
        AtomType_Pair,
        AtomType_Symbol,
        AtomType_Integer,
        AtomType_Builtin,
        AtomType_Closure
    } type;

    union {
        struct Pair *pair;
        const char *symbol;
        long integer;
        Builtin builtin;
    } value;
};

struct Pair {
    struct Atom atom[2];
};

#define car(p) ((p).value.pair-&gt;atom[0])
#define cdr(p) ((p).value.pair-&gt;atom[1])
#define nilp(atom) ((atom).type == AtomType_Nil)

static const Atom nil = { AtomType_Nil };
static Atom sym_table = { AtomType_Nil };

Atom cons(Atom car_val, Atom cdr_val)
{
    Atom p;

    p.type = AtomType_Pair;
    p.value.pair = malloc(sizeof(struct Pair));

    car(p) = car_val;
    cdr(p) = cdr_val;

    return p;
}

int listp(Atom expr);
int env_get(Atom env, Atom symbol, Atom *result);
int env_set(Atom env, Atom symbol, Atom value);
int eval_expr(Atom expr, Atom env, Atom *result);

int listp(Atom expr)
{
    while (!nilp(expr)) {
        if (expr.type != AtomType_Pair)
            return 0;
        expr = cdr(expr);
    }
    return 1;
}

Atom make_int(long x)
{
    Atom a;
    a.type = AtomType_Integer;
    a.value.integer = x;
    return a;
}

Atom make_sym(const char *s)
{
    Atom a, p;

    p = sym_table;
    while (!nilp(p)) {
        a = car(p);
        if (strcmp(a.value.symbol, s) == 0)
            return a;
        p = cdr(p);
    }

    a.type = AtomType_Symbol;
    a.value.symbol = strdup(s);
    sym_table = cons(a, sym_table);

    return a;
}

Atom make_builtin(Builtin fn)
{
    Atom a;
    a.type = AtomType_Builtin;
    a.value.builtin = fn;
    return a;
}

int make_closure(Atom env, Atom args, Atom body, Atom *result)
{
    Atom p;

    if (!listp(args) || !listp(body))
        return Error_Syntax;

    p = args;
    while (!nilp(p)) {
        if (car(p).type != AtomType_Symbol)
            return Error_Type;
        p = cdr(p);
    }

    *result = cons(env, cons(args, body));
    result-&gt;type = AtomType_Closure;

    return Error_OK;
}

Atom copy_list(Atom list)
{
    Atom a, p;

    if (nilp(list))
        return nil;

    a = cons(car(list), nil);
    p = a;
    list = cdr(list);

    while (!nilp(list)) {
        cdr(p) = cons(car(list), nil);
        p = cdr(p);
        list = cdr(list);
    }

    return a;
}

Atom env_create(Atom parent)
{
    return cons(parent, nil);
}

int apply(Atom fn, Atom args, Atom *result)
{
    Atom env, arg_names, body;

    if (fn.type == AtomType_Builtin)
        return (*fn.value.builtin)(args, result);
    else if (fn.type != AtomType_Closure)
        return Error_Type;

    env = env_create(car(fn));
    arg_names = car(cdr(fn));
    body = cdr(cdr(fn));

    while (!nilp(arg_names)) {
        if (nilp(args))
            return Error_Args;
        env_set(env, car(arg_names), car(args));
        arg_names = cdr(arg_names);
        args = cdr(args);
    }
    if (!nilp(args))
        return Error_Args;

    while (!nilp(body)) {
        Error err = eval_expr(car(body), env, result);
        if (err)
            return err;
        body = cdr(body);
    }

    return Error_OK;
}

int env_get(Atom env, Atom symbol, Atom *result)
{
    Atom parent = car(env);
    Atom bs = cdr(env);

    while(!nilp(bs)) {
        Atom b = car(bs);
        if (car(b).value.symbol == symbol.value.symbol) {
            *result = cdr(b);
            return Error_OK;
        }
        bs = cdr(bs);
    }

    if (nilp(parent))
        return Error_Unbound;

    return env_get(parent, symbol, result);
}

int env_set(Atom env, Atom symbol, Atom value)
{
    Atom bs = cdr(env);
    Atom b = nil;

    while (!nilp(bs)) {
        b = car(bs);
        if (car(b).value.symbol == symbol.value.symbol) {
            cdr(b) = value;
            return Error_OK;
        }
        bs = cdr(bs);
    }

    b = cons(symbol, value);
    cdr(env) = cons(b, cdr(env));

    return Error_OK;
}


int eval_expr(Atom expr, Atom env, Atom *result)
{
    Atom op, args, p;
    Error err;

    if (expr.type == AtomType_Symbol) {
        return env_get(env, expr, result);
    } else if (expr.type != AtomType_Pair) {
        *result = expr;
        return Error_OK;
    }

    if (!listp(expr))
        return Error_Syntax;

    op = car(expr);
    args = cdr(expr);

    if (op.type == AtomType_Symbol) {
        if (strcmp(op.value.symbol, "QUOTE") == 0) {
            if (nilp(args) || !nilp(cdr(args)))
                return Error_Args;

            *result = car(args);
            return Error_OK;
        } else if (strcmp(op.value.symbol, "IF") == 0) {
            Atom cond, val;

            if (nilp(args) || nilp(cdr(args)) || nilp(cdr(cdr(args))) || !nilp(cdr(cdr(cdr(args)))))
                return Error_Args;

            err = eval_expr(car(args), env, &amp;cond);
            if (err)
                return err;

            val = nilp(cond) ? car(cdr(cdr(args))) : car(cdr(args));
            return eval_expr(val, env, result);
        } else if (strcmp(op.value.symbol, "LAMBDA") == 0) {
            if (nilp(args) || nilp(cdr(args)))
                return Error_Args;

            return make_closure(env, car(args), cdr(args), result);
        } else if (strcmp(op.value.symbol, "DEFINE") == 0) {
            Atom sym, val;

            if (nilp(args) || nilp(cdr(args)) || !nilp(cdr(cdr(args))))
                return Error_Args;

            sym = car(args);
            if (sym.type != AtomType_Symbol)
                return Error_Type;

            err = eval_expr(car(cdr(args)), env, &amp;val);
            if (err)
                return err;

            *result = sym;
            return env_set(env, sym, val);
        }
    }

    err = eval_expr(op, env, &amp;op);
    if (err)
        return err;

    args = copy_list(args);
    p = args;
    while (!nilp(p)) {
        err = eval_expr(car(p), env, &amp;car(p));
        if (err)
            return err;

        p = cdr(p);
    }

    return apply(op, args, result);
}

int lex(const char *str, const char **start, const char **end)
{
    const char *ws = " \t\n";
    const char *delim = "() \t\n";
    const char *prefix = "()";

    str += strspn(str, ws);

    if (str[0] == '\0') {
        *start = *end = NULL;
        return Error_Syntax;
    }

    *start = str;

    // strchr函数功能为在一个串中查找给定字符的第一个匹配之处
    if (strchr(prefix, str[0]) != NULL)
        *end = str + 1;
    else
    // 该函数返回 str1 开头连续都不含字符串 str2 中字符的字符数。
        *end = str + strcspn(str, delim);

    return Error_OK;
}

int read_expr(const char *input, const char **end, Atom *result);

int parse_simple(const char *start, const char *end, Atom *result)
{
    char *buf, *p;

    long val = strtol(start, &amp;p, 10);
    if (p == end) {
        result-&gt;type = AtomType_Integer;
        result-&gt;value.integer = val;
        return Error_OK;
    }

    buf = malloc(end - start + 1);
    p = buf;
    while (start != end)
        *p++ = toupper(*start), ++start;
    *p = '\0';

    if (strcmp(buf, "NIL") == 0) {
        *result = nil;
    } else {
        *result = make_sym(buf);
    }

    free(buf);

    return Error_OK;
}

int read_list(const char *start, const char **end, Atom *result)
{
    Atom p;

    *end = start;
    p = *result = nil;

    for (;;) {
        const char *token;
        Atom item;
        Error err;

        err = lex(*end, &amp;token, end);
        if (err) {
            return err;
        }

        if (token[0] == ')') {
            return Error_OK;
        }

        if (token[0] == '.' &amp;&amp; *end - token == 1) {
            if (nilp(p)) {
                return Error_Syntax;
            }

            err = read_expr(*end, end, &amp;item);
            if (err) {
                return err;
            }

            cdr(p) = item;

            err = lex(*end, &amp;token, end);
            if (!err &amp;&amp; token[0] != ')') {
                err = Error_Syntax;
            }

            return err;
        }

        err = read_expr(token, end, &amp;item);
        if (err) {
            return err;
        }

        if (nilp(p)) {
            *result = cons(item, nil);
            p = *result;
        } else {
            cdr(p) = cons(item, nil);
            p = cdr(p);
        }
    }
}

int read_expr(const char *input, const char **end, Atom *result)
{
    const char *token;
    Error err;

    err = lex(input, &amp;token, end);
    if (err) return err;

    if (token[0] == '(') {
        return read_list(*end, end, result);
    } else if (token[0] == ')') {
        return Error_Syntax;
    } else {
        return parse_simple(token, *end, result);
    }
}

void print_expr(Atom atom)
{
    switch (atom.type) {
    case AtomType_Nil:
        printf("NIL");
        break;
    case AtomType_Pair:
        putchar('(');
        print_expr(car(atom));
        atom = cdr(atom);
        while (!nilp(atom)) {
            if (atom.type == AtomType_Pair) {
                putchar(' ');
                print_expr(car(atom));
                atom = cdr(atom);
            } else {
                printf(" . ");
                print_expr(atom);
                break;
            }
        }
        putchar(')');
        break;
    case AtomType_Symbol:
        printf("%s", atom.value.symbol);
        break;
    case AtomType_Integer:
        printf("%ld", atom.value.integer);
        break;
    case AtomType_Builtin:
        printf("#&lt;BUILTIN:%p&gt;", atom.value.builtin);
        break;
    }
}

int builtin_car(Atom args, Atom *result)
{
    if (nilp(args) || !nilp(cdr(args)))
        return Error_Args;

    if (nilp(car(args)))
        *result = nil;
    else if (car(args).type != AtomType_Pair)
        return Error_Type;
    else
        *result = car(car(args));

    return Error_OK;
}

int builtin_cdr(Atom args, Atom *result)
{
    if (nilp(args) || !nilp(cdr(args)))
        return Error_Args;

    if (nilp(car(args)))
        *result = nil;
    else if (car(args).type != AtomType_Pair)
        return Error_Type;
    else
        *result = cdr(car(args));

    return Error_OK;
}

int builtin_cons(Atom args, Atom *result)
{
    if (nilp(args) || nilp(cdr(args)) || !nilp(cdr(cdr(args))))
        return Error_Args;

    *result = cons(car(args), car(cdr(args)));

    return Error_OK;
}

int builtin_add(Atom args, Atom *result)
{
    Atom a, b;

    if (nilp(args) || nilp(cdr(args)) || !nilp(cdr(cdr(args))))
        return Error_Args;

    a = car(args);
    b = car(cdr(args));

    if (a.type != AtomType_Integer || b.type != AtomType_Integer)
        return Error_Type;

    *result = make_int(a.value.integer + b.value.integer);

    return Error_OK;
}

int builtin_subtract(Atom args, Atom *result)
{
    Atom a, b;

    if (nilp(args) || nilp(cdr(args)) || !nilp(cdr(cdr(args))))
        return Error_Args;

    a = car(args);
    b = car(cdr(args));

    if (a.type != AtomType_Integer || b.type != AtomType_Integer)
        return Error_Type;

    *result = make_int(a.value.integer - b.value.integer);

    return Error_OK;
}

int builtin_multiply(Atom args, Atom *result)
{
    Atom a, b;

    if (nilp(args) || nilp(cdr(args)) || !nilp(cdr(cdr(args))))
        return Error_Args;

    a = car(args);
    b = car(cdr(args));

    if (a.type != AtomType_Integer || b.type != AtomType_Integer)
        return Error_Type;

    *result = make_int(a.value.integer * b.value.integer);

    return Error_OK;
}

int builtin_divide(Atom args, Atom *result)
{
    Atom a, b;

    if (nilp(args) || nilp(cdr(args)) || !nilp(cdr(cdr(args))))
        return Error_Args;

    a = car(args);
    b = car(cdr(args));

    if (a.type != AtomType_Integer || b.type != AtomType_Integer)
        return Error_Type;

    *result = make_int(a.value.integer / b.value.integer);

    return Error_OK;
}

int builtin_numeq(Atom args, Atom *result)
{
    Atom a, b;

    if (nilp(args) || nilp(cdr(args)) || !nilp(cdr(cdr(args))))
        return Error_Args;

    a = car(args);
    b = car(cdr(args));

    if (a.type != AtomType_Integer || b.type != AtomType_Integer)
        return Error_Type;

    *result = (a.value.integer == b.value.integer) ? make_sym("T") : nil;

    return Error_OK;
}

int builtin_less(Atom args, Atom *result)
{
    Atom a, b;

    if (nilp(args) || nilp(cdr(args)) || !nilp(cdr(cdr(args))))
        return Error_Args;

    a = car(args);
    b = car(cdr(args));

    if (a.type != AtomType_Integer || b.type != AtomType_Integer)
        return Error_Type;

    *result = (a.value.integer &lt; b.value.integer) ? make_sym("T") : nil;

    return Error_OK;
}

int main(int argc, char **argv)
{
    Atom env;
    char *input;

    env = env_create(nil);

    env_set(env, make_sym("CAR"), make_builtin(builtin_car));
    env_set(env, make_sym("CDR"), make_builtin(builtin_cdr));
    env_set(env, make_sym("CONS"), make_builtin(builtin_cons));
    env_set(env, make_sym("+"), make_builtin(builtin_add));
    env_set(env, make_sym("-"), make_builtin(builtin_subtract));
    env_set(env, make_sym("*"), make_builtin(builtin_multiply));
    env_set(env, make_sym("/"), make_builtin(builtin_divide));
    env_set(env, make_sym("T"), make_sym("T"));
    env_set(env, make_sym("="), make_builtin(builtin_numeq));
    env_set(env, make_sym("&lt;"), make_builtin(builtin_less));

    while ((input = readline("&gt; ")) != NULL) {
        const char *p = input;
        Error err;
        Atom expr, result;

        err = read_expr(p, &amp;p, &amp;expr);

        if (!err)
            err = eval_expr(expr, env, &amp;result);

        switch (err) {
        case Error_OK:
            print_expr(result);
            putchar('\n');
            break;
        case Error_Syntax:
            puts("Syntax error");
            break;
        case Error_Unbound:
            puts("Symbol not bound");
            break;
        case Error_Args:
            puts("Wrong number of arguments");
            break;
        case Error_Type:
            puts("Wrong type");
            break;
        }

        free(input);
    }

    return 0;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>编译：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">$ gcc lisp.c -lreadline -o lisp</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第九章语法糖">9. 第九章：语法糖</h2>
<div class="sectionbody">
<div class="paragraph">
<p>我们将定义一些其他语法，以方便输入一些常用表达式。回想一下，我们已经允许用户输入</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-scheme hljs" data-lang="scheme">(A B C)</code></pre>
</div>
</div>
<div class="paragraph">
<p>用来替换</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-scheme hljs" data-lang="scheme">(A . (B . (C . NIL)))</code></pre>
</div>
</div>
<div class="sect2">
<h3 id="_单引号">9.1. 单引号</h3>
<div class="paragraph">
<p>为了在表达式中包含文字符号或列表，我们需要使用QUOTE运算符。作为快捷方式，我们将定义</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-scheme hljs" data-lang="scheme">'EXPR</code></pre>
</div>
</div>
<div class="paragraph">
<p>相当于</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-scheme hljs" data-lang="scheme">(QUOTE EXPR)</code></pre>
</div>
</div>
<div class="paragraph">
<p>因此，例如以下形式是等效的：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Abbreviation</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Canonical form</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Evaluates to</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">'FOO</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">(QUOTE FOO)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">FOO</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">'(+ 1 2)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">(QUOTE (+ 1 2))</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">(+ 1 2)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">'(A . B)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">(QUOTE (A . B))</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">(A . B)</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>词法分析器需要知道引号是前缀（即，引号可以紧接在另一个 <code>token</code> 之前出现，但不一定是分隔符）。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">int lex(const char *str, const char **start, const char **end)
{
    const char *ws = " \t\n";
    const char *delim = "() \t\n";
    const char *prefix = "()\'";
    .
    .
    .
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>同样，read_expr必须将其转换为正确的列表表达式。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">int read_expr(const char *input, const char **end, Atom *result)
{
    const char *token;
    Error err;

    err = lex(input, &amp;token, end);
    if (err)
        return err;

    if (token[0] == '(') {
        return read_list(*end, end, result);
    } else if (token[0] == ')') {
        return Error_Syntax;
    } else if (token[0] == '\'') {
        *result = cons(make_sym("QUOTE"), cons(nil, nil));
        return read_expr(*end, end, &amp;car(cdr(*result)));
    } else {
        return parse_simple(token, *end, result);
    }
}</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_测试_10">9.1.1. 测试</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">&gt; (define x '(a b c))
X
&gt; x
(A B C)
&gt; 'x
X
&gt; (define foo 'bar)
FOO
&gt; foo
BAR
&gt; ''()
(QUOTE NIL)</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_函数定义">9.2. 函数定义</h3>
<div class="paragraph">
<p>每次我们想要定义一个函数时都必须键入一个lambda表达式，因此很麻烦，因此我们将修改DEFINE运算符来避免这种情况。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-scheme hljs" data-lang="scheme">(DEFINE (name args...) body...)</code></pre>
</div>
</div>
<div class="paragraph">
<p>相当于</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-scheme hljs" data-lang="scheme">(DEFINE name (LAMBDA (args...) body...))</code></pre>
</div>
</div>
<div class="paragraph">
<p>下面是实现代码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">int eval_expr(Atom expr, Atom env, Atom *result)
{
    .
    .
    .
    if (op.type == AtomType_Symbol) {
        if (strcmp(op.value.symbol, "QUOTE") == 0) {
        .
        .
        .
        } else if (strcmp(op.value.symbol, "DEFINE") == 0) {
            Atom sym, val;

            if (nilp(args) || nilp(cdr(args)))
                return Error_Args;

            sym = car(args);
            if (sym.type == AtomType_Pair) {
                err = make_closure(env, cdr(sym), cdr(args), &amp;val);
                sym = car(sym);
                if (sym.type != AtomType_Symbol)
                    return Error_Type;
            } else if (sym.type == AtomType_Symbol) {
                if (!nilp(cdr(cdr(args))))
                    return Error_Args;
                err = eval_expr(car(cdr(args)), env, &amp;val);
            } else {
                return Error_Type;
            }

            if (err)
                return err;

            *result = sym;
            return env_set(env, sym, val);
        } else if (strcmp(op.value.symbol, "LAMBDA") == 0) {
        .
        .
        .
        }
    }
    .
    .
    .
}</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_测试_11">9.2.1. 测试</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">&gt; (define (square x) (* x x))
SQUARE
&gt; (square 3)
9</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第十章变长参数的函数">10. 第十章：变长参数的函数</h2>
<div class="sectionbody">
<div class="paragraph">
<p>到目前为止，所有函数都具有指定数量的命名参数。现在，我们将介绍一种用于定义可变参数的语法，该语法可以采用固定数量的命名参数和可变数量的附加参数，这些参数被收集到命名列表中。</p>
</div>
<div class="paragraph">
<p>可变参数函数的参数声明是不正规的列表（improper list）：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">λ-syntax</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Combined DEFINE</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">3 args</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">(LAMBDA (arg1 arg2 arg3) body&#8230;&#8203;)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">(DEFINE (name arg1 arg2 arg3) body&#8230;&#8203;)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">≥2 args</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">(LAMBDA (arg1 arg2 . rest) body&#8230;&#8203;)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">(DEFINE (name arg1 arg2 . rest) body&#8230;&#8203;)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">≥1 args</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">(LAMBDA (arg1 . rest) body&#8230;&#8203;)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">(DEFINE (name arg1 . rest) body&#8230;&#8203;)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">≥0 args</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">(LAMBDA args body&#8230;&#8203;)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">(DEFINE (name . args) body&#8230;&#8203;)</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>在上面的定义中，参数的绑定如下：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 66.6667%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">定义</p></td>
<td class="tableblock halign-center valign-top"><div class="content"><table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 100%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">(f a b c)</p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Value of a</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Value of b</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Value of c</p></td>
</tr>
</tbody>
</table></div></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">(DEFINE (f a b c) body&#8230;&#8203;)</p></td>
<td class="tableblock halign-center valign-top"><div class="content"><table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">3</p></td>
</tr>
</tbody>
</table></div></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">(DEFINE (f a b . c) body&#8230;&#8203;)</p></td>
<td class="tableblock halign-center valign-top"><div class="content"><table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">(3)</p></td>
</tr>
</tbody>
</table></div></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">(DEFINE (f . a) body&#8230;&#8203;)</p></td>
<td class="tableblock halign-center valign-top"><div class="content"><table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">(2 3)</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
</tbody>
</table></div></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">(DEFINE (f . a) body&#8230;&#8203;)</p></td>
<td class="tableblock halign-center valign-top"><div class="content"><table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">(1 2 3)</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
</tbody>
</table></div></td>
</tr>
</tbody>
</table>
<div class="sect2">
<h3 id="_实现_7">10.1. 实现</h3>
<div class="paragraph">
<p>所需要做的只是对make_closure进行一个小的修改以接受该声明：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">int make_closure(Atom env, Atom args, Atom body, Atom *result)
{
    Atom p;

    if (!listp(body))
        return Error_Syntax;

    /* Check argument names are all symbols */
    p = args;
    while (!nilp(p)) {
        if (p.type == AtomType_Symbol)
            break;
        else if (p.type != AtomType_Pair
                || car(p).type != AtomType_Symbol)
            return Error_Type;
        p = cdr(p);
    }

    *result = cons(env, cons(args, body));
    result-&gt;type = AtomType_Closure;

    return Error_OK;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>另一个适用于将其他参数绑定到列表中的方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">int apply(Atom fn, Atom args, Atom *result)
{
    .
    .
    .
    /* Bind the arguments */
    while (!nilp(arg_names)) {
        if (arg_names.type == AtomType_Symbol) {
            env_set(env, arg_names, args);
            args = nil;
            break;
        }

        if (nilp(args))
            return Error_Args;
        env_set(env, car(arg_names), car(args));
        arg_names = cdr(arg_names);
        args = cdr(args);
    }
    if (!nilp(args))
        return Error_Args;
    .
    .
    .
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_测试_12">10.2. 测试</h3>
<div class="paragraph">
<p>一个繁琐的例子</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">&gt; ((lambda (a . b) a) 1 2 3)
1
&gt; ((lambda (a . b) b) 1 2 3)
(2 3)
&gt; ((lambda args args) 1 2 3)
(1 2 3)</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们可以创建一个变长参数的累加器：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">&gt; (define (sum-list xs)
    (if xs
        (+ (car xs) (sum-list (cdr xs)))
        0))
SUM-LIST
&gt; (sum-list '(1 2 3))
6
&gt; (define (add . xs) (sum-list xs))
ADD
&gt; (add 1 2 3)
6
&gt; (add 1 (- 4 2) (/ 9 3))
6</code></pre>
</div>
</div>
<div class="paragraph">
<p>由于始终可以将列表传递给常规函数，因此这实际上只是另一种语法糖。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第十一章宏">11. 第十一章：宏</h2>
<div class="sectionbody">
<div class="paragraph">
<p>宏允许我们在运行时创建新的特殊形式。与函数不同，不会对宏的参数进行求值。然后，对宏的函数体的求值结果进行求值。</p>
</div>
<div class="paragraph">
<p>注意：这些（基本上是）常见的LISP宏。Scheme具有不同的宏系统，该系统避免了由宏引入的标识符的问题，但更为复杂。</p>
</div>
<div class="paragraph">
<p>我们将使用以下语法定义宏：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-scheme hljs" data-lang="scheme">(DEFMACRO (name arg...) body...)</code></pre>
</div>
</div>
<div class="paragraph">
<p>这有点像我们定义函数时的DEFINE语法，但和Common LISP中的形式有点区别。</p>
</div>
<div class="sect2">
<h3 id="_例子">11.1. 例子</h3>
<div class="paragraph">
<p>我们先来定义一个宏IGNORE</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-scheme hljs" data-lang="scheme">(DEFMACRO (IGNORE X)
  (CONS 'QUOTE
    (CONS X NIL)))</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果我们对以下表达式进行求值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-scheme hljs" data-lang="scheme">(IGNORE FOO)</code></pre>
</div>
</div>
<div class="paragraph">
<p>由于FOO没有绑定存在，所以IGNORE的宏代码将会把参数X绑定到未求值的符号FOO。那么对嵌套的CONS表达式在这个环境中求值的结果如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-scheme hljs" data-lang="scheme">(QUOTE . (FOO . NIL))</code></pre>
</div>
</div>
<div class="paragraph">
<p>当然上面的表达式等价于</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-scheme hljs" data-lang="scheme">(QUOTE FOO)</code></pre>
</div>
</div>
<div class="paragraph">
<p>最终，对上面的表达式进行求值（也就是对宏的代码进行求值的结果）就是：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-scheme hljs" data-lang="scheme">FOO</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_实现_8">11.2. 实现</h3>
<div class="paragraph">
<p>我们将会定义一个新的 atom 类型：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">AtomType_Macro</code></pre>
</div>
</div>
<div class="paragraph">
<p>上面类型的值和AtomType_Closure是一样的，我们只需要告诉eval_expr如何对我们新的宏类型进行求值就好了。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">int eval_expr(Atom expr, Atom env, Atom *result)
{
    .
    .
    .
    if (op.type == AtomType_Symbol) {
        if (strcmp(op.value.symbol, "QUOTE") == 0) {
        .
        .
        .
        } else if (strcmp(op.value.symbol, "DEFMACRO") == 0) {
            Atom name, macro;
            Error err;

            if (nilp(args) || nilp(cdr(args)))
                return Error_Args;

            if (car(args).type != AtomType_Pair)
                return Error_Syntax;

            name = car(car(args));
            if (name.type != AtomType_Symbol)
                return Error_Type;

            err = make_closure(env, cdr(car(args)),
                cdr(args), &amp;macro);
            if (err)
                return err;

            macro.type = AtomType_Macro;
            *result = name;
            return env_set(env, name, macro);
        }
    }

    /* Evaluate operator */
    .
    .
    .

    /* Is it a macro? */
    if (op.type == AtomType_Macro) {
        Atom expansion;
        op.type = AtomType_Closure;
        err = apply(op, args, &amp;expansion);
        if (err)
            return err;
        return eval_expr(expansion, env, result);
    }

    /* Evaulate arguments */
    .
    .
    .
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_测试_13">11.3. 测试</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">&gt; (defmacro (ignore x) (cons 'quote (cons x nil)))
IGNORE
&gt; (ignore foo)
FOO
&gt; foo
Symbol not bound</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们在后面将使用宏来定义一些新的特殊形式。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第十二章库">12. 第十二章：库</h2>
<div class="sectionbody">
<div class="paragraph">
<p>现在，我们将为LISP系统创建一个有用的函数的小型库。让我们利用以下事实：我们可以利用较低级别的功能在LISP本身中实现许多LISP标准库，而不是为每个构建新的内建函数。</p>
</div>
<div class="paragraph">
<p>首先，我们需要一个函数来从磁盘读取库定义。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">char *slurp(const char *path)
{
    FILE *file;
    char *buf;
    long len;

    file = fopen(path, "r");
    if (!file)
        return NULL;
    fseek(file, 0, SEEK_END);
    len = ftell(file);
    fseek(file, 0, SEEK_SET);

    buf = malloc(len + 1);
    if (!buf)
        return NULL;

    fread(buf, 1, len, file);
    buf[len] = 0;
    fclose(file);

    return buf;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>还有一个类似于我们的REPL的例程，用于处理这些定义。因为我们一次性读取了整个文件，所以将定义拆分成几行是没有问题的。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">void load_file(Atom env, const char *path)
{
    char *text;

    printf("Reading %s...\n", path);
    text = slurp(path);
    if (text) {
        const char *p = text;
        Atom expr;
        while (read_expr(p, &amp;p, &amp;expr) == Error_OK) {
            Atom result;
            Error err = eval_expr(expr, env, &amp;result);
            if (err) {
                printf("Error in expression:\n\t");
                print_expr(expr);
                putchar('\n');
            } else {
                print_expr(result);
                putchar('\n');
            }
        }
        free(text);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>设置完内置函数后，最后在库中读取。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">int main(int argc, char **argv)
{
    .
     .
    .

    /* Set up the initial environment */
    .
    .
    .

    load_file(env, "library.lisp");

    /* Main loop */
    .
    .
    .
}</code></pre>
</div>
</div>
<div class="sect2">
<h3 id="_测试_14">12.1. 测试</h3>
<div class="paragraph">
<p>使用下面的定义创建一个 <code>library.lisp</code> 文件：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-scheme hljs" data-lang="scheme">(define (abs x) (if (&lt; x 0) (- 0 x) x))</code></pre>
</div>
</div>
<div class="paragraph">
<p>运行解释器</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">Reading library.lisp...
ABS
&gt; (abs -2)
2</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>ABS</code> 函数现在在每一个lisp代码中都可以使用了，不需要每次都定义一遍。</p>
</div>
</div>
<div class="sect2">
<h3 id="_fold">12.2. fold</h3>
<div class="paragraph">
<p><code>foldl</code> 和 <code>foldr</code> 允许我们轻松的创建聚合列表的函数。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-scheme hljs" data-lang="scheme">(define (foldl proc init list)
  (if list
      (foldl proc
             (proc init (car list))
             (cdr list))
      init))

(define (foldr proc init list)
  (if list
      (proc (car list)
            (foldr proc init (cdr list)))
      init))</code></pre>
</div>
</div>
<div class="paragraph">
<p>看一下怎么用</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-scheme hljs" data-lang="scheme">(define (list . items)
  (foldr cons nil items))

(define (reverse list)
  (foldl (lambda (a x) (cons x a)) nil list))</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_测试_15">12.2.1. 测试</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">&gt; (list (+ 3 5) 'foo)
(8 FOO)
&gt; (reverse '(1 2 3))
(3 2 1)</code></pre>
</div>
</div>
<div class="paragraph">
<p>这比我们用C实现成内置函数要容易多了吧。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_更多内置函数">12.3. 更多内置函数</h3>
<div class="paragraph">
<p>有一些原始函数需要访问系统的内部API。</p>
</div>
<div class="sect3">
<h4 id="_apply">12.3.1. apply</h4>
<div class="paragraph">
<p>apply 函数</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-scheme hljs" data-lang="scheme">(APPLY fn arg-list)</code></pre>
</div>
</div>
<div class="paragraph">
<p>将fn中的参数列表绑定到arg-list，然后执行fn的函数体。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">int builtin_apply(Atom args, Atom *result)
{
    Atom fn;

    if (nilp(args) || nilp(cdr(args)) || !nilp(cdr(cdr(args))))
        return Error_Args;

    fn = car(args);
    args = car(cdr(args));

    if (!listp(args))
        return Error_Syntax;

    return apply(fn, args, result);
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_eq">12.3.2. eq?</h4>
<div class="paragraph">
<p><code>eq?</code> 测试两个原子类型是不是同一个对象。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">int builtin_eq(Atom args, Atom *result)
{
    Atom a, b;
    int eq;

    if (nilp(args) || nilp(cdr(args)) || !nilp(cdr(cdr(args))))
        return Error_Args;

    a = car(args);
    b = car(cdr(args));

    if (a.type == b.type) {
        switch (a.type) {
        case AtomType_Nil:
            eq = 1;
            break;
        case AtomType_Pair:
        case AtomType_Closure:
        case AtomType_Macro:
            eq = (a.value.pair == b.value.pair);
            break;
        case AtomType_Symbol:
            eq = (a.value.symbol == b.value.symbol);
            break;
        case AtomType_Integer:
            eq = (a.value.integer == b.value.integer);
            break;
        case AtomType_Builtin:
            eq = (a.value.builtin == b.value.builtin);
            break;
        }
    } else {
        eq = 0;
    }

    *result = eq ? make_sym("T") : nil;
    return Error_OK;
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_pair">12.3.3. pair?</h4>
<div class="paragraph">
<p>测试一个原子类型是不是 <code>pair</code> 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">int builtin_pairp(Atom args, Atom *result)
{
    if (nilp(args) || !nilp(cdr(args)))
        return Error_Args;

    *result = (car(args).type == AtomType_Pair) ? make_sym("T") : nil;
    return Error_OK;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>别忘了将内置函数绑定到初始环境中。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">env_set(env, make_sym("APPLY"), make_builtin(builtin_apply));
env_set(env, make_sym("EQ?"), make_builtin(builtin_eq));
env_set(env, make_sym("PAIR?"), make_builtin(builtin_pairp));</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_map">12.3.4. map</h4>
<div class="paragraph">
<p>我们使用 <code>foldr</code> 和 <code>apply</code> 来实现另一个重要的函数 <code>map</code> ，也就是将列表中的每一个元素都一一对应的转换成另一种元素。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-scheme hljs" data-lang="scheme">(define (unary-map proc list)
  (foldr (lambda (x rest) (cons (proc x) rest))
         nil
         list))

(define (map proc . arg-lists)
  (if (car arg-lists)
      (cons (apply proc (unary-map car arg-lists))
            (apply map (cons proc
                             (unary-map cdr arg-lists))))
      nil))</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意还有其他实现方式。</p>
</div>
<div class="paragraph">
<p>这样使用map：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-scheme hljs" data-lang="scheme">&gt; (map + '(1 2 3) '(4 5 6))
(5 7 9)</code></pre>
</div>
</div>
<div class="paragraph">
<p>结果列表中包含的结果是：(+ 1 4)，(+ 2 5)和(+ 3 6)的求值结果。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第十三章准引用quasiquote">13. 第十三章：准引用(QUASIQUOTE)</h2>
<div class="sectionbody">
<div class="paragraph">
<p>QUASIQUOTE是QUOTE特殊形式的扩展，可以方便地编写宏。</p>
</div>
<div class="paragraph">
<p>对于符号和其他简单数据，QUASIQUOTE的行为类似于QUOTE，返回未经求值的数据结构。列表也将返回而不进行求值，但有两个例外。如果列表（或子列表）的元素具有 <code>(UNQUOTE expr)</code> 形式，则将求值expr，并将结果插入到列表中。 <code>(UNQUOTE-SPLICING expr)</code> 相似，但是求值expr的结果必须是一个列表，其项被拼接到父列表中。</p>
</div>
<div class="sect2">
<h3 id="_例子_2">13.1. 例子</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-scheme hljs" data-lang="scheme">(QUASIQUOTE (+ 1 (UNQUOTE (+ 2 3))))</code></pre>
</div>
</div>
<div class="paragraph">
<p>将会求值为：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-scheme hljs" data-lang="scheme">(+ 1 5)</code></pre>
</div>
</div>
<div class="paragraph">
<p>If we define L to be the list (3 4 5) then</p>
</div>
<div class="paragraph">
<p>如果我们定义L为列表(3 4 5)，那么</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-scheme hljs" data-lang="scheme">(QUASIQUOTE (1 2 (UNQUOTE-SPLICING L)))</code></pre>
</div>
</div>
<div class="paragraph">
<p>将会求值为：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-scheme hljs" data-lang="scheme">(1 2 3 4 5)</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_语法糖">13.2. 语法糖</h3>
<div class="paragraph">
<p>就像QUOTE一样，我们可以定义下列缩写形式：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Abbreviation</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Equivalent to</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">`expr</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">(QUASIQUOTE expr)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">,expr</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">(UNQUOTE expr)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">,@expr</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">(UNQUOTE-SPLICING expr)</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>将上面的例子用语法糖重写一下</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-scheme hljs" data-lang="scheme">`(+ 1 ,(+ 2 3))</code></pre>
</div>
</div>
<div class="paragraph">
<p>以及</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-scheme hljs" data-lang="scheme">`(1 2 ,@L)</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_实现_9">13.3. 实现</h3>
<div class="paragraph">
<p>我们将扩展词法分析器来理解上面那些特殊的 <code>token</code> 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">int lex(const char *str, const char **start, const char **end)
{
    const char *ws = " \t\n";
    const char *delim = "() \t\n";
    const char *prefix = "()\'`";

    str += strspn(str, ws);

    if (str[0] == '\0') {
        *start = *end = NULL;
        return Error_Syntax;
    }

    *start = str;

    if (strchr(prefix, str[0]) != NULL)
        *end = str + 1;
    else if (str[0] == ',')
        *end = str + (str[1] == '@' ? 2 : 1);
    else
        *end = str + strcspn(str, delim);

    return Error_OK;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>read_expr 需要扩展上面那些缩写形式，像对 QUOTE 那么扩展</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">int read_expr(const char *input, const char **end, Atom *result)
{
    .
    .
    .
    if (token[0] == '(') {
    .
    .
    .
    } else if (token[0] == '`') {
        *result = cons(make_sym("QUASIQUOTE"), cons(nil, nil));
        return read_expr(*end, end, &amp;car(cdr(*result)));
    } else if (token[0] == ',') {
        *result = cons(make_sym(
            token[1] == '@' ? "UNQUOTE-SPLICING" : "UNQUOTE"),
            cons(nil, nil));
        return read_expr(*end, end, &amp;car(cdr(*result)));
    } else {
        .
        .
        .
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>QUASIQUOTE运算符可以定义为一个宏。我们先来定义一些辅助函数。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-scheme hljs" data-lang="scheme">(define (append a b) (foldr cons b a))

(define (caar x) (car (car x)))

(define (cadr x) (car (cdr x)))</code></pre>
</div>
</div>
<div class="paragraph">
<p>(append a b) 将列表a和b拼接在一起。宏如下定义：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-scheme hljs" data-lang="scheme">(defmacro (and a b) (list 'if a b nil))

(defmacro (quasiquote x)
  (if (pair? x)
      (if (eq? (car x) 'unquote)
          (cadr x)
          (if (and (pair? (car x)) (eq? (caar x) 'unquote-splicing))
              (list 'append
                    (cadr (car x))
                    (list 'quasiquote (cdr x)))
              (list 'cons
                    (list 'quasiquote (car x))
                    (list 'quasiquote (cdr x)))))
      (list 'quote x)))</code></pre>
</div>
</div>
<div class="paragraph">
<p>上面的宏定义有一些难理解，因为结果表达式也是用LIST构建的，并且也调用了其他的QUASIQUOTE。</p>
</div>
<div class="paragraph">
<p>Quasiquotation允许我们在写宏定义的函数体时看起来像这个宏返回的表达式一样。例如在十一章中写过的IGNORE宏</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-scheme hljs" data-lang="scheme">(DEFMACRO (IGNORE X)
  (CONS 'QUOTE (CONS X NIL)))</code></pre>
</div>
</div>
<div class="paragraph">
<p>可以改写成</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-scheme hljs" data-lang="scheme">(DEFMACRO (IGNORE X)
  `(QUOTE ,X))</code></pre>
</div>
</div>
<div class="paragraph">
<p>这样IGNORE看起来就好理解了。</p>
</div>
<div class="sect3">
<h4 id="_测试_16">13.3.1. 测试</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">&gt; `(+ 1 ,(+ 2 3))
(+ 1 5)
&gt; (define l '(3 4 5))
L
&gt; `(1 2 ,@l)
(1 2 3 4 5)</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_let">13.4. let</h3>
<div class="paragraph">
<p>我们现在使用QUASITUOTE来定义一种新的特殊形式：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-scheme hljs" data-lang="scheme">(LET ((sym1 expr1)
      (sym2 expr2)
      ...)
  body...)</code></pre>
</div>
</div>
<div class="paragraph">
<p>LET先对expr1求值，并绑定到sym1,再对expr2求值，并绑定到sym2,等等。然后将body的求值结果返回。定义很简单：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-scheme hljs" data-lang="scheme">(defmacro (let defs . body)
  `((lambda ,(map car defs) ,@body)
    ,@(map cadr defs)))</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_例子_3">13.4.1. 例子</h4>
<div class="paragraph">
<p>当我们对下面的形式进行求值时：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-scheme hljs" data-lang="scheme">(LET ((X 3) (Y 5)) (+ X Y))</code></pre>
</div>
</div>
<div class="paragraph">
<p>它将会被LET宏转换成：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-scheme hljs" data-lang="scheme">((LAMBDA (X Y) (+ X Y)) 3 5)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_测试_17">13.4.2. 测试</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">&gt; (let ((x 3) (y 5)) (+ x y))
8
&gt; x
Symbol not bound</code></pre>
</div>
</div>
<div class="paragraph">
<p>LET表达式可以让我们定义临时变量。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_一个小技巧">13.5. 一个小技巧</h3>
<div class="paragraph">
<p>我们可以使用LET来扩展内置运算符 <code>+</code> ，使得可以对任意数量的参数进行相加。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-scheme hljs" data-lang="scheme">(define +
  (let ((old+ +))
    (lambda xs (foldl old+ 0 xs))))</code></pre>
</div>
</div>
<div class="paragraph">
<p>将上面的定义和在第十章中定义的ADD对比一下。</p>
</div>
<div class="sect3">
<h4 id="_测试_18">13.5.1. 测试</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">&gt; (+ 1 2 3 4)
10</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们甚至不需要触碰builtin_add函数或者重新编译解释器。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_完整代码_3">13.6. 完整代码</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;ctype.h&gt;
#include &lt;readline/readline.h&gt;

char *slurp(const char *path)
{
    FILE *file;
    char *buf;
    long len;

    file = fopen(path, "r");
    if (!file)
        return NULL;
    fseek(file, 0, SEEK_END);
    len = ftell(file);
    fseek(file, 0, SEEK_SET);

    buf = malloc(len + 1);
    if (!buf)
        return NULL;

    fread(buf, 1, len, file);
    buf[len] = 0;
    fclose(file);

    return buf;
}

typedef enum {
    Error_OK = 0,
    Error_Syntax,
    Error_Unbound,
    Error_Args,
    Error_Type
} Error;

typedef struct Atom Atom;
typedef int (*Builtin)(struct Atom args, struct Atom *result);

struct Atom
{
    enum {
        AtomType_Nil,
        AtomType_Pair,
        AtomType_Symbol,
        AtomType_Integer,
        AtomType_Builtin,
        AtomType_Closure,
        AtomType_Macro
    } type;

    union {
        struct Pair *pair;
        const char *symbol;
        long integer;
        Builtin builtin;
    } value;
};

struct Pair {
    struct Atom atom[2];
};

#define car(p) ((p).value.pair-&gt;atom[0])
#define cdr(p) ((p).value.pair-&gt;atom[1])
#define nilp(atom) ((atom).type == AtomType_Nil)

static const Atom nil = { AtomType_Nil };
static Atom sym_table = { AtomType_Nil };

Atom cons(Atom car_val, Atom cdr_val)
{
    Atom p;

    p.type = AtomType_Pair;
    p.value.pair = malloc(sizeof(struct Pair));

    car(p) = car_val;
    cdr(p) = cdr_val;

    return p;
}

int listp(Atom expr);
int env_get(Atom env, Atom symbol, Atom *result);
int env_set(Atom env, Atom symbol, Atom value);
int eval_expr(Atom expr, Atom env, Atom *result);
int read_expr(const char *input, const char **end, Atom *result);
void print_expr(Atom atom);

void load_file(Atom env, const char *path)
{
    char *text;

    printf("Reading %s...\n", path);
    text = slurp(path);
    if (text) {
        const char *p = text;
        Atom expr;
        while (read_expr(p, &amp;p, &amp;expr) == Error_OK) {
            Atom result;
            Error err = eval_expr(expr, env, &amp;result);
            if (err) {
                printf("Error in expression:\n\t");
                print_expr(expr);
                putchar('\n');
            } else {
                print_expr(result);
                putchar('\n');
            }
        }
        free(text);
    }
}

int listp(Atom expr)
{
    while (!nilp(expr)) {
        if (expr.type != AtomType_Pair)
            return 0;
        expr = cdr(expr);
    }
    return 1;
}

Atom make_int(long x)
{
    Atom a;
    a.type = AtomType_Integer;
    a.value.integer = x;
    return a;
}

Atom make_sym(const char *s)
{
    Atom a, p;

    p = sym_table;
    while (!nilp(p)) {
        a = car(p);
        if (strcmp(a.value.symbol, s) == 0)
            return a;
        p = cdr(p);
    }

    a.type = AtomType_Symbol;
    a.value.symbol = strdup(s);
    sym_table = cons(a, sym_table);

    return a;
}

Atom make_builtin(Builtin fn)
{
    Atom a;
    a.type = AtomType_Builtin;
    a.value.builtin = fn;
    return a;
}

int make_closure(Atom env, Atom args, Atom body, Atom *result)
{
    Atom p;

    if (!listp(body))
        return Error_Syntax;

    p = args;
    while (!nilp(p)) {
        if (p.type == AtomType_Symbol)
            break;
        else if (p.type != AtomType_Pair
                || car(p).type != AtomType_Symbol) {
                    return Error_Type;
                }
        p = cdr(p);
    }

    *result = cons(env, cons(args, body));
    result-&gt;type = AtomType_Closure;

    return Error_OK;
}

Atom copy_list(Atom list)
{
    Atom a, p;

    if (nilp(list))
        return nil;

    a = cons(car(list), nil);
    p = a;
    list = cdr(list);

    while (!nilp(list)) {
        cdr(p) = cons(car(list), nil);
        p = cdr(p);
        list = cdr(list);
    }

    return a;
}

Atom env_create(Atom parent)
{
    return cons(parent, nil);
}

int apply(Atom fn, Atom args, Atom *result)
{
    Atom env, arg_names, body;

    if (fn.type == AtomType_Builtin)
        return (*fn.value.builtin)(args, result);
    else if (fn.type != AtomType_Closure) {
        return Error_Type;
    }

    env = env_create(car(fn));
    arg_names = car(cdr(fn));
    body = cdr(cdr(fn));

    while (!nilp(arg_names)) {
        if (arg_names.type == AtomType_Symbol) {
            env_set(env, arg_names, args);
            args = nil;
            break;
        }

        if (nilp(args))
            return Error_Args;
        env_set(env, car(arg_names), car(args));
        arg_names = cdr(arg_names);
        args = cdr(args);
    }
    if (!nilp(args))
        return Error_Args;

    while (!nilp(body)) {
        Error err = eval_expr(car(body), env, result);
        if (err)
            return err;
        body = cdr(body);
    }

    return Error_OK;
}

int env_get(Atom env, Atom symbol, Atom *result)
{
    Atom parent = car(env);
    Atom bs = cdr(env);

    while(!nilp(bs)) {
        Atom b = car(bs);
        if (car(b).value.symbol == symbol.value.symbol) {
            *result = cdr(b);
            return Error_OK;
        }
        bs = cdr(bs);
    }

    if (nilp(parent))
        return Error_Unbound;

    return env_get(parent, symbol, result);
}

int env_set(Atom env, Atom symbol, Atom value)
{
    Atom bs = cdr(env);
    Atom b = nil;

    while (!nilp(bs)) {
        b = car(bs);
        if (car(b).value.symbol == symbol.value.symbol) {
            cdr(b) = value;
            return Error_OK;
        }
        bs = cdr(bs);
    }

    b = cons(symbol, value);
    cdr(env) = cons(b, cdr(env));

    return Error_OK;
}


int eval_expr(Atom expr, Atom env, Atom *result)
{
    Atom op, args, p;
    Error err;

    if (expr.type == AtomType_Symbol) {
        return env_get(env, expr, result);
    } else if (expr.type != AtomType_Pair) {
        *result = expr;
        return Error_OK;
    }

    if (!listp(expr))
        return Error_Syntax;

    op = car(expr);
    args = cdr(expr);

    if (op.type == AtomType_Symbol) {
        if (strcmp(op.value.symbol, "QUOTE") == 0) {
            if (nilp(args) || !nilp(cdr(args)))
                return Error_Args;

            *result = car(args);
            return Error_OK;
        } else if (strcmp(op.value.symbol, "DEFMACRO") == 0) {
            Atom name, macro;
            Error err;

            if (nilp(args) || nilp(cdr(args)))
                return Error_Args;

            if (car(args).type != AtomType_Pair)
                return Error_Syntax;

            name = car(car(args));
            if (name.type != AtomType_Symbol) {
                return Error_Type;
            }

            err = make_closure(env, cdr(car(args)),
                cdr(args), &amp;macro);
            if (err)
                return err;

            macro.type = AtomType_Macro;
            *result = name;
            return env_set(env, name, macro);
        } else if (strcmp(op.value.symbol, "IF") == 0) {
            Atom cond, val;

            if (nilp(args) || nilp(cdr(args)) || nilp(cdr(cdr(args))) || !nilp(cdr(cdr(cdr(args)))))
                return Error_Args;

            err = eval_expr(car(args), env, &amp;cond);
            if (err)
                return err;

            val = nilp(cond) ? car(cdr(cdr(args))) : car(cdr(args));
            return eval_expr(val, env, result);
        } else if (strcmp(op.value.symbol, "DEFINE") == 0) {
            Atom sym, val;

            if (nilp(args) || nilp(cdr(args))) {
                return Error_Args;
            }

            sym = car(args);
            if (sym.type == AtomType_Pair) {
                err = make_closure(env, cdr(sym), cdr(args), &amp;val);
                sym = car(sym);
                if (sym.type != AtomType_Symbol) {
                    return Error_Type;
                }
            } else if (sym.type == AtomType_Symbol) {
                if (!nilp(cdr(cdr(args)))) {
                    return Error_Args;
                }
                err = eval_expr(car(cdr(args)), env, &amp;val);
            } else {
                return Error_Type;
            }

            if (err)
                return err;

            *result = sym;
            return env_set(env, sym, val);
        } else if (strcmp(op.value.symbol, "LAMBDA") == 0) {
            if (nilp(args) || nilp(cdr(args)))
                return Error_Args;

            return make_closure(env, car(args), cdr(args), result);
        }
    }

    err = eval_expr(op, env, &amp;op);
    if (err)
        return err;

    if (op.type == AtomType_Macro) {
        Atom expansion;
        op.type = AtomType_Closure;
        err = apply(op, args, &amp;expansion);
        if (err)
            return err;
        return eval_expr(expansion, env, result);
    }

    args = copy_list(args);
    p = args;
    while (!nilp(p)) {
        err = eval_expr(car(p), env, &amp;car(p));
        if (err)
            return err;

        p = cdr(p);
    }

    return apply(op, args, result);
}

int lex(const char *str, const char **start, const char **end)
{
    const char *ws = " \t\n";
    const char *delim = "() \t\n";
    const char *prefix = "()\'`";

    str += strspn(str, ws);

    if (str[0] == '\0') {
        *start = *end = NULL;
        return Error_Syntax;
    }

    *start = str;

    // strchr函数功能为在一个串中查找给定字符的第一个匹配之处
    if (strchr(prefix, str[0]) != NULL)
        *end = str + 1;
    else if (str[0] == ',')
        *end = str + (str[1] == '@' ? 2 : 1);
    else
    // 该函数返回 str1 开头连续都不含字符串 str2 中字符的字符数。
        *end = str + strcspn(str, delim);

    return Error_OK;
}


int parse_simple(const char *start, const char *end, Atom *result)
{
    char *buf, *p;

    long val = strtol(start, &amp;p, 10);
    if (p == end) {
        result-&gt;type = AtomType_Integer;
        result-&gt;value.integer = val;
        return Error_OK;
    }

    buf = malloc(end - start + 1);
    p = buf;
    while (start != end)
        *p++ = toupper(*start), ++start;
    *p = '\0';

    if (strcmp(buf, "NIL") == 0) {
        *result = nil;
    } else {
        *result = make_sym(buf);
    }

    free(buf);

    return Error_OK;
}

int read_list(const char *start, const char **end, Atom *result)
{
    Atom p;

    *end = start;
    p = *result = nil;

    for (;;) {
        const char *token;
        Atom item;
        Error err;

        err = lex(*end, &amp;token, end);
        if (err) {
            return err;
        }

        if (token[0] == ')') {
            return Error_OK;
        }

        if (token[0] == '.' &amp;&amp; *end - token == 1) {
            if (nilp(p)) {
                return Error_Syntax;
            }

            err = read_expr(*end, end, &amp;item);
            if (err) {
                return err;
            }

            cdr(p) = item;

            err = lex(*end, &amp;token, end);
            if (!err &amp;&amp; token[0] != ')') {
                err = Error_Syntax;
            }

            return err;
        }

        err = read_expr(token, end, &amp;item);
        if (err) {
            return err;
        }

        if (nilp(p)) {
            *result = cons(item, nil);
            p = *result;
        } else {
            cdr(p) = cons(item, nil);
            p = cdr(p);
        }
    }
}

int read_expr(const char *input, const char **end, Atom *result)
{
    const char *token;
    Error err;

    err = lex(input, &amp;token, end);
    if (err) return err;

    if (token[0] == '(') {
        return read_list(*end, end, result);
    } else if (token[0] == '`') {
        *result = cons(make_sym("QUASIQUOTE"), cons(nil, nil));
        return read_expr(*end, end, &amp;car(cdr(*result)));
    } else if (token[0] == ',') {
        *result = cons(make_sym(
            token[1] == '@' ? "UNQUOTE-SPLICING" : "UNQUOTE"),
            cons(nil, nil));
        return read_expr(*end, end, &amp;car(cdr(*result)));
    } else if (token[0] == ')') {
        return Error_Syntax;
    } else if (token[0] == '\'') {
        *result = cons(make_sym("QUOTE"), cons(nil, nil));
        return read_expr(*end, end, &amp;car(cdr(*result)));
    } else {
        return parse_simple(token, *end, result);
    }
}

void print_expr(Atom atom)
{
    switch (atom.type) {
    case AtomType_Nil:
        printf("NIL");
        break;
    case AtomType_Pair:
        putchar('(');
        print_expr(car(atom));
        atom = cdr(atom);
        while (!nilp(atom)) {
            if (atom.type == AtomType_Pair) {
                putchar(' ');
                print_expr(car(atom));
                atom = cdr(atom);
            } else {
                printf(" . ");
                print_expr(atom);
                break;
            }
        }
        putchar(')');
        break;
    case AtomType_Symbol:
        printf("%s", atom.value.symbol);
        break;
    case AtomType_Integer:
        printf("%ld", atom.value.integer);
        break;
    case AtomType_Builtin:
        printf("#&lt;BUILTIN:%p&gt;", atom.value.builtin);
        break;
    }
}

int builtin_car(Atom args, Atom *result)
{
    if (nilp(args) || !nilp(cdr(args)))
        return Error_Args;

    if (nilp(car(args)))
        *result = nil;
    else if (car(args).type != AtomType_Pair)
        return Error_Type;
    else
        *result = car(car(args));

    return Error_OK;
}

int builtin_cdr(Atom args, Atom *result)
{
    if (nilp(args) || !nilp(cdr(args)))
        return Error_Args;

    if (nilp(car(args)))
        *result = nil;
    else if (car(args).type != AtomType_Pair)
        return Error_Type;
    else
        *result = cdr(car(args));

    return Error_OK;
}

int builtin_cons(Atom args, Atom *result)
{
    if (nilp(args) || nilp(cdr(args)) || !nilp(cdr(cdr(args))))
        return Error_Args;

    *result = cons(car(args), car(cdr(args)));

    return Error_OK;
}

int builtin_add(Atom args, Atom *result)
{
    Atom a, b;

    if (nilp(args) || nilp(cdr(args)) || !nilp(cdr(cdr(args))))
        return Error_Args;

    a = car(args);
    b = car(cdr(args));

    if (a.type != AtomType_Integer || b.type != AtomType_Integer)
        return Error_Type;

    *result = make_int(a.value.integer + b.value.integer);

    return Error_OK;
}

int builtin_subtract(Atom args, Atom *result)
{
    Atom a, b;

    if (nilp(args) || nilp(cdr(args)) || !nilp(cdr(cdr(args))))
        return Error_Args;

    a = car(args);
    b = car(cdr(args));

    if (a.type != AtomType_Integer || b.type != AtomType_Integer)
        return Error_Type;

    *result = make_int(a.value.integer - b.value.integer);

    return Error_OK;
}

int builtin_multiply(Atom args, Atom *result)
{
    Atom a, b;

    if (nilp(args) || nilp(cdr(args)) || !nilp(cdr(cdr(args))))
        return Error_Args;

    a = car(args);
    b = car(cdr(args));

    if (a.type != AtomType_Integer || b.type != AtomType_Integer)
        return Error_Type;

    *result = make_int(a.value.integer * b.value.integer);

    return Error_OK;
}

int builtin_divide(Atom args, Atom *result)
{
    Atom a, b;

    if (nilp(args) || nilp(cdr(args)) || !nilp(cdr(cdr(args))))
        return Error_Args;

    a = car(args);
    b = car(cdr(args));

    if (a.type != AtomType_Integer || b.type != AtomType_Integer)
        return Error_Type;

    *result = make_int(a.value.integer / b.value.integer);

    return Error_OK;
}

int builtin_numeq(Atom args, Atom *result)
{
    Atom a, b;

    if (nilp(args) || nilp(cdr(args)) || !nilp(cdr(cdr(args))))
        return Error_Args;

    a = car(args);
    b = car(cdr(args));

    if (a.type != AtomType_Integer || b.type != AtomType_Integer)
        return Error_Type;

    *result = (a.value.integer == b.value.integer) ? make_sym("T") : nil;

    return Error_OK;
}

int builtin_less(Atom args, Atom *result)
{
    Atom a, b;

    if (nilp(args) || nilp(cdr(args)) || !nilp(cdr(cdr(args))))
        return Error_Args;

    a = car(args);
    b = car(cdr(args));

    if (a.type != AtomType_Integer || b.type != AtomType_Integer)
        return Error_Type;

    *result = (a.value.integer &lt; b.value.integer) ? make_sym("T") : nil;

    return Error_OK;
}

int builtin_apply(Atom args, Atom *result)
{
    Atom fn;

    if (nilp(args) || nilp(cdr(args)) || !nilp(cdr(cdr(args))))
        return Error_Args;

    fn = car(args);
    args = car(cdr(args));

    if (!listp(args))
        return Error_Syntax;

    return apply(fn, args, result);
}

int builtin_eq(Atom args, Atom *result)
{
    Atom a, b;
    int eq;

    if (nilp(args) || nilp(cdr(args)) || !nilp(cdr(cdr(args))))
        return Error_Args;

    a = car(args);
    b = car(cdr(args));

    if (a.type == b.type) {
        switch (a.type)
        {
        case AtomType_Nil:
            eq = 1;
            break;
        case AtomType_Pair:
        case AtomType_Closure:
        case AtomType_Macro:
            eq = (a.value.pair == b.value.pair);
            break;
        case AtomType_Symbol:
            eq = (a.value.symbol == b.value.symbol);
            break;
        case AtomType_Integer:
            eq = (a.value.integer == b.value.integer);
            break;
        case AtomType_Builtin:
            eq = (a.value.builtin == b.value.builtin);
            break;
        }
    } else {
        eq = 0;
    }

    *result = eq ? make_sym("T") : nil;
    return Error_OK;
}

int builtin_pairp(Atom args, Atom *result)
{
    if (nilp(args) || !nilp(cdr(args)))
        return Error_Args;

    *result = (car(args).type == AtomType_Pair) ? make_sym("T") : nil;
    return Error_OK;
}

int main(int argc, char **argv)
{
    Atom env;
    char *input;

    env = env_create(nil);

    env_set(env, make_sym("CAR"), make_builtin(builtin_car));
    env_set(env, make_sym("CDR"), make_builtin(builtin_cdr));
    env_set(env, make_sym("CONS"), make_builtin(builtin_cons));
    env_set(env, make_sym("+"), make_builtin(builtin_add));
    env_set(env, make_sym("-"), make_builtin(builtin_subtract));
    env_set(env, make_sym("*"), make_builtin(builtin_multiply));
    env_set(env, make_sym("/"), make_builtin(builtin_divide));
    env_set(env, make_sym("T"), make_sym("T"));
    env_set(env, make_sym("="), make_builtin(builtin_numeq));
    env_set(env, make_sym("&lt;"), make_builtin(builtin_less));
    env_set(env, make_sym("APPLY"), make_builtin(builtin_apply));
    env_set(env, make_sym("EQ?"), make_builtin(builtin_eq));
    env_set(env, make_sym("PAIR?"), make_builtin(builtin_pairp));

    load_file(env, "library.lisp");

    while ((input = readline("&gt; ")) != NULL) {
        const char *p = input;
        Error err;
        Atom expr, result;

        err = read_expr(p, &amp;p, &amp;expr);

        if (!err)
            err = eval_expr(expr, env, &amp;result);

        switch (err) {
        case Error_OK:
            print_expr(result);
            putchar('\n');
            break;
        case Error_Syntax:
            puts("Syntax error");
            break;
        case Error_Unbound:
            puts("Symbol not bound");
            break;
        case Error_Args:
            puts("Wrong number of arguments");
            break;
        case Error_Type:
            puts("Wrong type");
            break;
        }

        free(input);
    }

    return 0;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>library.lisp</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-scheme hljs" data-lang="scheme">(define (abs x) (if (&lt; x 0) (- 0 x) x))

(define (foldl proc init list)
  (if list
      (foldl proc
             (proc init (car list))
             (cdr list))
      init))

(define (foldr proc init list)
  (if list
      (proc (car list)
            (foldr proc init (cdr list)))
      init))

(define (list . items)
  (foldr cons nil items))

(define (reverse list)
  (foldl (lambda (a x) (cons x a)) nil list))

(define (unary-map proc list)
  (foldr (lambda (x rest) (cons (proc x) rest))
         nil
         list))

(define (map proc . arg-lists)
  (if (car arg-lists)
      (cons (apply proc (unary-map car arg-lists))
            (apply map (cons proc
                             (unary-map cdr arg-lists))))
      nil))

(define (append a b) (foldr cons b a))

(define (caar x) (car (car x)))

(define (cadr x) (car (cdr x)))

(defmacro (and a b) (list 'if a b nil))

(defmacro (quasiquote x)
  (if (pair? x)
      (if (eq? (car x) 'unquote)
          (cadr x)
          (if (and (pair? (car x)) (eq? (caar x) 'unquote-splicing))
              (list 'append
                    (cadr (car x))
                    (list 'quasiquote (cdr x)))
              (list 'cons
                    (list 'quasiquote (car x))
                    (list 'quasiquote (cdr x)))))
      (list 'quote x)))

(defmacro (let defs . body)
  `((lambda ,(map car defs) ,@body)
    ,@(map cadr defs)))

(define +
  (let ((old+ +))
    (lambda xs (foldl old+ 0 xs))))</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第十四章延续和尾递归">14. 第十四章：延续和尾递归</h2>
<div class="sectionbody">
<div class="paragraph">
<p>延续 &#8594; continuation</p>
</div>
<div class="paragraph">
<p>尾递归 &#8594; tail recursion</p>
</div>
<div class="paragraph">
<p>我们的eval_expr函数是递归实现的——也就是说，当在求值表达式的过程中有必要求值子表达式时，eval_expr调用自身以获得结果。</p>
</div>
<div class="paragraph">
<p>这工作得很好，并且易于遵循，但是在我们的LISP环境中，递归的深度受到解释器堆栈大小的限制。传统上，LISP代码大量使用递归，因此我们希望在可用内存限制内支持此功能。</p>
</div>
<div class="paragraph">
<p>以以下不太好的递归示例为例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-scheme hljs" data-lang="scheme">(define (count n)
  (if (= n 0)
      0
      (+ 1 (count (- n 1)))))</code></pre>
</div>
</div>
<div class="paragraph">
<p>COUNT函数将递归到深度n，并返回n的总和。诸如(COUNT 10)之类的表达式应使用我们当前的解释器计算确定，但即使(COUNT 10000)也足以导致我的计算机上的堆栈溢出。</p>
</div>
<div class="paragraph">
<p>为此，我们将eval_expr重写为一个循环，并使用辅助函数来跟踪进行中的求值并返回要求值的下一个表达式。如果没有更多的表达式了，eval_expr可以将最终结果返回给调用者。</p>
</div>
<div class="paragraph">
<p>当eval_expr在表达式树中工作时，我们将在一系列帧（链接在一起形成一个堆栈）中跟踪已求值的参数和待求值的参数。这与以递归方式编写的eval_expr的版本的工作方式大致相同；在这种情况下，我们将使用LISP数据结构替换机器代码堆栈，并对其进行显式操作。</p>
</div>
<div class="paragraph">
<p>一旦计算了当前表达式，堆栈也可以被认为代表了计算的未来。从这个意义上讲，它被称为当前延续。</p>
</div>
<div class="paragraph">
<p>由于eval_expr调用的任何函数都不能调用eval_expr（以避免递归），因此我们必须将apply和buildin_apply集成到eval_expr的函数体中。</p>
</div>
<div class="sect2">
<h3 id="_实现_10">14.1. 实现</h3>
<div class="paragraph">
<p>一个栈帧拥有以下形式：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-scheme hljs" data-lang="scheme">(parent env evaluated-op (pending-arg...) (evaluated-arg...) (body...))</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>parent</code> 是与父表达式（即正在等待当前表达式的结果的表达式）相对应的堆栈帧。 <code>env</code> 是当前环境， <code>evaluated-op</code> 是求值的运算符， <code>pending-arg&#8230;&#8203;</code> 和 <code>evaluated-arg&#8230;&#8203;</code> 分别是未决和后续求值的参数。 <code>body&#8230;&#8203;</code> 是函数体中待执行的表达式。</p>
</div>
<div class="paragraph">
<p>与其写出包含很多的 <code>car()</code> 和 <code>cdr()</code> 的代码，我们不如定义一些辅助函数来操纵列表中的成员。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">Atom list_get(Atom list, int k)
{
    while (k--)
        list = cdr(list);
    return car(list);
}

void list_set(Atom list, int k, Atom value)
{
    while (k--)
        list = cdr(list);
    car(list) = value;
}

void list_reverse(Atom *list)
{
    Atom tail = nil;
    while (!nilp(*list)) {
        Atom p = cdr(*list);
        cdr(*list) = tail;
        tail = *list;
        *list = p;
    }
    *list = tail;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>另一个函数用来创建一个新的栈帧，来对新的函数调用求值。这个新的函数有特定的parent，环境，以及一个将要求值的参数列表（tail）。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">Atom make_frame(Atom parent, Atom env, Atom tail)
{
    return cons(parent,
        cons(env,
        cons(nil, /* op */
        cons(tail,
        cons(nil, /* args */
        cons(nil, /* body */
        nil))))));
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>下面是我们新的 <code>exec_expr</code> 函数中最核心的部分。这个函数将 expr 设置到了函数体的下一个部分中，然后当我们到达函数体的最后时，将栈弹出。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">int eval_do_exec(Atom *stack, Atom *expr, Atom *env)
{
    Atom body;

    *env = list_get(*stack, 1);
    body = list_get(*stack, 5);
    *expr = car(body);
    body = cdr(body);
    if (nilp(body)) {
        /* Finished function; pop the stack */
        *stack = car(*stack);
    } else {
        list_set(*stack, 5, body);
    }

    return Error_OK;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个辅助函数将函数的参数绑定到一个新的环境中，前提是这些参数没有被绑定过。然后调用 <code>eval_do_exec</code> 方法获取函数体中的下一个表达式。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">int eval_do_bind(Atom *stack, Atom *expr, Atom *env)
{
    Atom op, args, arg_names, body;

    body = list_get(*stack, 5);
    if (!nilp(body))
        return eval_do_exec(stack, expr, env);

    op = list_get(*stack, 2);
    args = list_get(*stack, 4);

    *env = env_create(car(op));
    arg_names = car(cdr(op));
    body = cdr(cdr(op));
    list_set(*stack, 1, *env);
    list_set(*stack, 5, body);

    /* Bind the arguments */
    while (!nilp(arg_names)) {
        if (arg_names.type == AtomType_Symbol) {
            env_set(*env, arg_names, args);
            args = nil;
            break;
        }

        if (nilp(args))
            return Error_Args;
        env_set(*env, car(arg_names), car(args));
        arg_names = cdr(arg_names);
        args = cdr(args);
    }
    if (!nilp(args))
        return Error_Args;

    list_set(*stack, 4, nil);

    return eval_do_exec(stack, expr, env);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>一旦参数都被求值以后，下一个函数将被调用。下一个函数负责要么产生一个调用内置函数的表达式，要么代理到 <code>eval_do_bind</code> 函数。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">int eval_do_apply(Atom *stack, Atom *expr, Atom *env, Atom *result)
{
    Atom op, args;

    op = list_get(*stack, 2);
    args = list_get(*stack, 4);

    if (!nilp(args)) {
        list_reverse(&amp;args);
        list_set(*stack, 4, args);
    }

    if (op.type == AtomType_Symbol) {
        if (strcmp(op.value.symbol, "APPLY") == 0) {
            /* Replace the current frame */
            *stack = car(*stack);
            *stack = make_frame(*stack, *env, nil);
            op = car(args);
            args = car(cdr(args));
            if (!listp(args))
                return Error_Syntax;

            list_set(*stack, 2, op);
            list_set(*stack, 4, args);
        }
    }

    if (op.type == AtomType_Builtin) {
        *stack = car(*stack);
        *expr = cons(op, args);
        return Error_OK;
    } else if (op.type != AtomType_Closure) {
        return Error_Type;
    }

    return eval_do_bind(stack, expr, env);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个部分将会在一个表达式求值以后就调用。它负责存储结果。这个结果可能是一个运算符，一个参数，或者一个中间函数体表达式，然后获取下一个将要求值的表达式。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">int eval_do_return(Atom *stack, Atom *expr, Atom *env, Atom *result)
{
    Atom op, args, body;

    *env = list_get(*stack, 1);
    op = list_get(*stack, 2);
    body = list_get(*stack, 5);

    if (!nilp(body)) {
        /* Still running a procedure; ignore the result */
        return eval_do_apply(stack, expr, env, result);
    }

    if (nilp(op)) {
        /* Finished evaluating operator */
        op = *result;
        list_set(*stack, 2, op);

        if (op.type == AtomType_Macro) {
            /* Don't evaluate macro arguments */
            args = list_get(*stack, 3);
            *stack = make_frame(*stack, *env, nil);
            op.type = AtomType_Closure;
            list_set(*stack, 2, op);
            list_set(*stack, 4, args);
            return eval_do_bind(stack, expr, env);
        }
    } else if (op.type == AtomType_Symbol) {
        /* Finished working on special form */
        if (strcmp(op.value.symbol, "DEFINE") == 0) {
            Atom sym = list_get(*stack, 4);
            (void) env_set(*env, sym, *result);
            *stack = car(*stack);
            *expr = cons(make_sym("QUOTE"), cons(sym, nil));
            return Error_OK;
        } else if (strcmp(op.value.symbol, "IF") == 0) {
            args = list_get(*stack, 3);
            *expr = nilp(*result) ? car(cdr(args)) : car(args);
            *stack = car(*stack);
            return Error_OK;
        } else {
            goto store_arg;
        }
    } else if (op.type == AtomType_Macro) {
        /* Finished evaluating macro */
        *expr = *result;
        *stack = car(*stack);
        return Error_OK;
    } else {
    store_arg:
        /* Store evaluated argument */
        args = list_get(*stack, 4);
        list_set(*stack, 4, cons(*result, args));
    }

    args = list_get(*stack, 3);
    if (nilp(args)) {
        /* No more arguments left to evaluate */
        return eval_do_apply(stack, expr, env, result);
    }

    /* Evaluate next argument */
    *expr = car(args);
    list_set(*stack, 3, cdr(args));
    return Error_OK;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>最后来到了我们新的 <code>eval_expr</code> 。有很多代码来构建特殊形式，剩下的就仅仅是一个循环，负责等待栈被清空。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">int eval_expr(Atom expr, Atom env, Atom *result)
{
    Error err = Error_OK;
    Atom stack = nil;

    do {
        if (expr.type == AtomType_Symbol) {
            err = env_get(env, expr, result);
        } else if (expr.type != AtomType_Pair) {
            *result = expr;
        } else if (!listp(expr)) {
            return Error_Syntax;
        } else {
            Atom op = car(expr);
            Atom args = cdr(expr);

            if (op.type == AtomType_Symbol) {
                /* Handle special forms */

                if (strcmp(op.value.symbol, "QUOTE") == 0) {
                    if (nilp(args) || !nilp(cdr(args)))
                        return Error_Args;

                    *result = car(args);
                } else if (strcmp(op.value.symbol, "DEFINE") == 0) {
                    Atom sym;

                    if (nilp(args) || nilp(cdr(args)))
                        return Error_Args;

                    sym = car(args);
                    if (sym.type == AtomType_Pair) {
                        err = make_closure(env, cdr(sym), cdr(args), result);
                        sym = car(sym);
                        if (sym.type != AtomType_Symbol)
                            return Error_Type;
                        (void) env_set(env, sym, *result);
                        *result = sym;
                    } else if (sym.type == AtomType_Symbol) {
                        if (!nilp(cdr(cdr(args))))
                            return Error_Args;
                        stack = make_frame(stack, env, nil);
                        list_set(stack, 2, op);
                        list_set(stack, 4, sym);
                        expr = car(cdr(args));
                        continue;
                    } else {
                        return Error_Type;
                    }
                } else if (strcmp(op.value.symbol, "LAMBDA") == 0) {
                    if (nilp(args) || nilp(cdr(args)))
                        return Error_Args;

                    err = make_closure(env, car(args), cdr(args), result);
                } else if (strcmp(op.value.symbol, "IF") == 0) {
                    if (nilp(args) || nilp(cdr(args)) || nilp(cdr(cdr(args)))
                            || !nilp(cdr(cdr(cdr(args)))))
                        return Error_Args;

                    stack = make_frame(stack, env, cdr(args));
                    list_set(stack, 2, op);
                    expr = car(args);
                    continue;
                } else if (strcmp(op.value.symbol, "DEFMACRO") == 0) {
                    Atom name, macro;

                    if (nilp(args) || nilp(cdr(args)))
                        return Error_Args;

                    if (car(args).type != AtomType_Pair)
                        return Error_Syntax;

                    name = car(car(args));
                    if (name.type != AtomType_Symbol)
                        return Error_Type;

                    err = make_closure(env, cdr(car(args)),
                        cdr(args), &amp;macro);
                    if (!err) {
                        macro.type = AtomType_Macro;
                        *result = name;
                        (void) env_set(env, name, macro);
                    }
                } else if (strcmp(op.value.symbol, "APPLY") == 0) {
                    if (nilp(args) || nilp(cdr(args)) || !nilp(cdr(cdr(args))))
                        return Error_Args;

                    stack = make_frame(stack, env, cdr(args));
                    list_set(stack, 2, op);
                    expr = car(args);
                    continue;
                } else {
                    goto push;
                }
            } else if (op.type == AtomType_Builtin) {
                err = (*op.value.builtin)(args, result);
            } else {
            push:
                /* Handle function application */
                stack = make_frame(stack, env, args);
                expr = op;
                continue;
            }
        }

        if (nilp(stack))
            break;

        if (!err)
            err = eval_do_return(&amp;stack, &amp;expr, &amp;env, result);
    } while (!err);

    return err;
}</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_测试_19">14.1.1. 测试</h4>
<div class="paragraph">
<p>让我们再来试一下之前的COUNT函数。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">&gt; (count 100000)
100000</code></pre>
</div>
</div>
<div class="paragraph">
<p>万岁！现在，我们可以根据需要进行尽可能多的递归操作，而不会引起堆栈溢出。如果有大量的RAM，那么甚至应该能够完成一百万个级别的深度。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_尾递归">14.2. 尾递归</h3>
<div class="paragraph">
<p>如果函数中的最后一个表达式是对另一个函数的调用，则结果可以直接返回给第一个函数的调用者。这被称为尾调用。如果被调用的函数通过一系列的尾调用导致第一个函数被调用，则我们具有尾递归。</p>
</div>
<div class="paragraph">
<p>尾调用不需要保留调用者的栈帧，因此尾递归函数可以在不增加堆栈深度的情况下递归所需的多个级别。</p>
</div>
<div class="paragraph">
<p>可以将count函数表示为尾递归过程，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-scheme hljs" data-lang="scheme">(define (count n a)
  (if (= n 0)
      a
      (count (- n 1) (+ a 1))))

(count 100000 0)</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果使用调试器观看eval_expr，则可以确认堆栈从不超过几层。</p>
</div>
<div class="paragraph">
<p>剩下要做的就是清理新求值程序创建的所有临时对象。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第十五章垃圾收集">15. 第十五章：垃圾收集</h2>
<div class="sectionbody">
<div class="paragraph">
<p>垃圾收集 &#8594; Garbage collection</p>
</div>
<div class="paragraph">
<p>我们将实现一个非常简单的标记——清除垃圾收集器。这不是要在实际应用程序中使用的东西，但可以满足我们的目的。</p>
</div>
<div class="paragraph">
<p>请记住，我们所有的LISP数据都是通过cons函数分配的。首先，我们对其进行修改以跟踪链表中的每个分配。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">struct Allocation {
    struct Pair pair;
    int mark : 1;
    struct Allocation *next;
};

struct Allocation *global_allocations = NULL;

Atom cons(Atom car_val, Atom cdr_val)
{
    struct Allocation *a;
    Atom p;

    a = malloc(sizeof(struct Allocation));
    a-&gt;mark = 0;
    a-&gt;next = global_allocations;
    global_allocations = a;

    p.type = AtomType_Pair;
    p.value.pair = &amp;a-&gt;pair;

    car(p) = car_val;
    cdr(p) = cdr_val;

    return p;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>下面的函数将整个树的 <code>pair</code> 标记为 <code>in user</code> 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">void gc_mark(Atom root)
{
    struct Allocation *a;

    if (!(root.type == AtomType_Pair
        || root.type == AtomType_Closure
        || root.type == AtomType_Macro))
        return;

    a = (struct Allocation *)
        ((char *) root.value.pair
            - offsetof(struct Allocation, pair));

    if (a-&gt;mark)
        return;

    a-&gt;mark = 1;

    gc_mark(car(root));
    gc_mark(cdr(root));
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>垃圾收集器将释放所有未标记的内容，然后清除这些标记，以备下次运行。我们也标记符号表，因为这些符号表是由静态变量引用的。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">void gc()
{
    struct Allocation *a, **p;

    gc_mark(sym_table);

    /* Free unmarked allocations */
    p = &amp;global_allocations;
    while (*p != NULL) {
        a = *p;
        if (!a-&gt;mark) {
            *p = a-&gt;next;
            free(a);
        } else {
            p = &amp;a-&gt;next;
        }
    }

    /* Clear marks */
    a = global_allocations;
    while (a != NULL) {
        a-&gt;mark = 0;
        a = a-&gt;next;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>为了避免在深度递归下耗尽内存，我们需要在eval_expr的每几次迭代中调用一次垃圾收集器。该时间间隔将大致确定在垃圾回收之间进行多少内存的分配。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">int eval_expr(Atom expr, Atom env, Atom *result)
{
    static int count = 0;
    Error err = Error_OK;
    Atom stack = nil;

    do {
        if (++count == 100000) {
            gc_mark(expr);
            gc_mark(env);
            gc_mark(stack);
            gc();
            count = 0;
        }

    .
    .
    .
}</code></pre>
</div>
</div>
<div class="sect2">
<h3 id="_测试_20">15.1. 测试</h3>
<div class="paragraph">
<p>来看一下之前写的COUNT的例子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">&gt; (define (count n) (if (= n 0) t (count (- n 1))))
COUNT
&gt; (count 1000000)
T</code></pre>
</div>
</div>
<div class="paragraph">
<p>瞧！操作完成而不会耗尽我们的所有RAM。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第十六章接下来做什么">16. 第十六章：接下来做什么？</h2>
<div class="sectionbody">
<div class="paragraph">
<p>该项目的目的是演示LISP的轻松实现。优化或不经意地实现库函数没有多大意义——这项工作已经在其他项目中完成。</p>
</div>
<div class="paragraph">
<p>以下是一些可能有趣的扩展：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>使用 <code>call/cc</code> 关键字将延续暴露出来</p>
</li>
<li>
<p>其他数值类型 (float, rational, bignum, complex)</p>
</li>
<li>
<p>字符串、向量和布尔类型</p>
</li>
<li>
<p>I/O支持</p>
</li>
<li>
<p>调用系统库</p>
</li>
<li>
<p>即时编译(JIT)</p>
</li>
<li>
<p>Slab allocation</p>
</li>
<li>
<p>可配置GC</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>现在是时候停止在C语言中搞乱了，而是在LISP中构建东西了！</p>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2021-05-27 17:13:28 +0800
</div>
</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.3/highlight.min.js"></script>
<script>
if (!hljs.initHighlighting.called) {
  hljs.initHighlighting.called = true
  ;[].slice.call(document.querySelectorAll('pre.highlight > code')).forEach(function (el) { hljs.highlightBlock(el) })
}
</script>
</body>
</html>